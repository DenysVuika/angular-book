<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TypeScript Features - Angular Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Angular Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="ch01-02-vscode.html"><strong aria-hidden="true">1.2.</strong> Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-es6.html"><strong aria-hidden="true">2.</strong> ES6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-classes.html"><strong aria-hidden="true">2.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch02-02-inheritance.html"><strong aria-hidden="true">2.2.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="ch02-03-arrow-functions.html"><strong aria-hidden="true">2.3.</strong> Arrow Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-template-literals.html"><strong aria-hidden="true">2.4.</strong> Template Literals</a></li><li class="chapter-item expanded "><a href="ch02-05-extended-parameters.html"><strong aria-hidden="true">2.5.</strong> Extended Parameter Handling</a></li><li class="chapter-item expanded "><a href="ch02-06-destructuring.html"><strong aria-hidden="true">2.6.</strong> Destructuring Assignment</a></li><li class="chapter-item expanded "><a href="ch02-07-modules.html"><strong aria-hidden="true">2.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch02-08-see-also.html"><strong aria-hidden="true">2.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-typescript.html"><strong aria-hidden="true">3.</strong> TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch03-02-features.html" class="active"><strong aria-hidden="true">3.2.</strong> TypeScript Features</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Angular CLI</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.1.</strong> Installing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.2.</strong> Your first application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.3.</strong> Running application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.4.</strong> Code Linting</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.5.</strong> Unit tests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.6.</strong> Code coverage</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.7.</strong> Development and Production builds</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.8.</strong> Using blueprints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.9.</strong> Creating modules</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.10.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.11.</strong> Generating standalone scripts</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Components</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Creating a simple component</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Generating components with Angular CLI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Component metadata</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Templates</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Styles</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Output events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> Providers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.10.</strong> Host</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.</strong> Queries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.12.</strong> Content Projection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.</strong> Dependency Injection</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.1.</strong> Preparing a project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.2.</strong> Services</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.3.</strong> Providers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.4.</strong> Injecting multiple instances</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.5.</strong> Optional dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.6.</strong> Manual injection with ReflectiveInjector</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.7.</strong> Summary</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.1.</strong> Component events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.2.</strong> DOM events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.3.</strong> Service events</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.</strong> Directives</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.1.</strong> Introduction to Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.2.</strong> Attribute Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.3.</strong> Structural Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.4.</strong> Modifying host element layout</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.16.</strong> Walkthrough: Upload Directive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.</strong> Pipes</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.1.</strong> Introduction to Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.2.</strong> Pipes with Parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.3.</strong> Chaining Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.4.</strong> Built-in Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.5.</strong> Custom Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.6.</strong> Pure And Impure Pipes</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.</strong> Global Application Configuration</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.1.</strong> Preparing the configuration file</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.2.</strong> Creating the configuration service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.3.</strong> Loading server-side configuration file</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.4.</strong> Registering configuration service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.5.</strong> Using configuration settings</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.</strong> Internationalisation (i18n)</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.1.</strong> Creating Translate Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.2.</strong> Creating Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.3.</strong> Using Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.4.</strong> Switching languages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.5.</strong> Summary</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Reusable Component Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Creating new application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Creating component libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Building the packages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Publishing to NPM</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Dynamic Content in Angular</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Using with Docker</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Additional Resources</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Preparing new project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Creating Dockerfile</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Testing in a container</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Creating docker-compose.yml</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Consuming from Docker Hub</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.7.</strong> Automating with Travis</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.8.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Webpack</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Initial project structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Typescript configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Basic webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Advanced webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> Unit testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Building a Mobile App with Cordova and Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Installing command-line tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Generating a new Angular App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Summary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Angular Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/DenysVuika/angular-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="typescript-features"><a class="header" href="#typescript-features">TypeScript Features</a></h2>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/4">todo: Needs introduction</a></em></p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>TypeScript supports all the types used in JavaScript:</p>
<ul>
<li><strong>boolean</strong></li>
<li><strong>number</strong></li>
<li><strong>string</strong></li>
<li><strong>arrays</strong></li>
</ul>
<p>TypeScript also adds the following types:</p>
<ul>
<li><strong>enum</strong></li>
<li><strong>any</strong></li>
<li><strong>void</strong></li>
</ul>
<h4 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h4>
<h5 id="boolean"><a class="header" href="#boolean">Boolean</a></h5>
<blockquote>
<p>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a boolean value.</p>
</blockquote>
<pre><code class="language-ts">let isEnabled: boolean = true;
</code></pre>
<p>Assigning non-Boolean value to the variable will produce an error.</p>
<pre><code class="language-ts">isEnabled = 'YES';
// logger.ts(2,1): error TS2322: Type '&quot;YES&quot;' is not assignable to type 'boolean'.
</code></pre>
<p>It is also possible annotating function or method return types.</p>
<pre><code class="language-ts">function isEmpty(str: string): boolean {
    return !str;
}
</code></pre>
<h5 id="number"><a class="header" href="#number">Number</a></h5>
<p>TypeScript maps all JavaScript numbers to the <code>number</code> type:</p>
<ul>
<li>floating point numbers (default JavaScript type for all numbers)</li>
<li>decimal numbers</li>
<li>hexadecimal numbers</li>
<li>binary literals (ES6)</li>
<li>octal literals (ES6)</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-ts">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre>
<h5 id="string"><a class="header" href="#string">String</a></h5>
<p>Typescript supports ES6 <strong>template literals</strong> (formerly known as <strong>template strings</strong>).</p>
<p>As in ECMAScript 6, you use backticks (`) to enclose a string literal and <strong>${}</strong> to interpolate JavaScript variables or arbitrary expressions.</p>
<p>Either double quotes (&quot;) or single quotes (') can be used to surround string data.</p>
<pre><code class="language-ts">let firstName: string = &quot;Joan&quot;;
let lastName: string = 'Doe';
let fullName: string = `${firstName} ${lastName}`;
let template: string = `
    &lt;h1&gt;Title&lt;h1&gt;
    &lt;p&gt;Hello, ${fullName}&lt;/p&gt;
`;
</code></pre>
<h4 id="arrays"><a class="header" href="#arrays">Arrays</a></h4>
<p>There are two main ways you can provide type definition for arrays of values in TypeScript:</p>
<pre><code class="language-ts">let arr1: string[] = [];
let arr2: Array&lt;string&gt; = new Array();
</code></pre>
<p>You can also initialize arrays upon declaring them:</p>
<pre><code class="language-ts">let arr1: string[] = ['hello', 'world'];
let arr2: Array&lt;string&gt; = ['hello', 'world'];

let flags1: boolean[] = [true, false, true, false];
let flags2: boolean[] = new Array(false, true);
</code></pre>
<p>As in JavaScript arrays, you can <strong>push</strong> elements and access them by <strong>index</strong></p>
<pre><code class="language-ts">let users: string[] = [];

users.push('user1');

console.log(`First user: ${users[0]}`);
</code></pre>
<p>The sample above demonstrates array element access together with string interpolation.
When executed it should produce:</p>
<pre><code class="language-text">First user: user1
</code></pre>
<h4 id="enum"><a class="header" href="#enum">Enum</a></h4>
<p>TypeScript provides support for an <strong>enumerated type</strong> known in many languages (Swift, C#, Java, C, and others).
This data type consists of a set of named values mapped to numbers.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

let s: Suit = Suit.Spade;
</code></pre>
<p>By default numbering of enum members starts with 0 and increments by one.
You have full control of the values if needed.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };
enum Suit { Club = 1, Diamond = 2, Heart = 4, Spade = 8 }
</code></pre>
<p>Another valuable feature is accessing by a numeric value.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

console.log(Suit[0]); // Club
</code></pre>
<p>It must be noted however that you access names by the numeric values, not by an array index as it may seem.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };

console.log(Suit[0]); // undefined
console.log(Suit[1]); // Club
</code></pre>
<h4 id="any"><a class="header" href="#any">Any</a></h4>
<p>A special <strong>any</strong> type is used to opt-out of the TypeScript type-checking process and addresses the following cases:</p>
<ul>
<li>dynamic content (objects created on the fly)</li>
<li>3rd party libraries (having no TypeScript support via definition files)</li>
</ul>
<pre><code class="language-ts">let obj: any = {
    log(message) {
        console.log(message);
    }
};
obj.log('hello world');
</code></pre>
<p>Please note that by opting-out of the type-checking process you take full responsibility for safety checks,
as now TypeScript compiler is not able to verify the code at compile time.</p>
<p>The following example shows valid TypeScript code:</p>
<pre><code class="language-ts">obj.log('hello world'); 
obj.helloWorld('log');
</code></pre>
<p>However, at runtime the second line causes a TypeError exception:</p>
<pre><code class="language-text">hello world
TypeError: obj.helloWorld is not a function
</code></pre>
<p>So it is recommended using <strong>any</strong> type only where necessary.</p>
<h4 id="void"><a class="header" href="#void">Void</a></h4>
<p>The <strong>void</strong> type is used to declare a function does not return any value explicitly.</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
        return true;
    }

}
</code></pre>
<p>If you try compiling the code above you should get an error:</p>
<pre><code class="language-text">error TS2322: Type 'true' is not assignable to type 'void'.
</code></pre>
<p>You can fix the type-check error by removing <strong>return</strong> statement from the <strong>log</strong> method:</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
    }

}
</code></pre>
<p>You might also be using <strong>void</strong> types as function parameters or with <strong>Interfaces</strong>:</p>
<pre><code class="language-ts">function fn(x: () =&gt; void) {
  x();
}

interface Logger {

  log(message: string): void;
  warn(message: string): void;
  error(message: string): void;

}
</code></pre>
<p><em>You will get more information on <strong>Interfaces</strong> later in this book.</em></p>
<h3 id="classes"><a class="header" href="#classes">Classes</a></h3>
<p>TypeScript provides support for classes introduced with ES6 (ECMAScript 2015) and adds a set of features to improve object-oriented development.</p>
<pre><code class="language-ts">class Widget {

    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        console.log(`Rendering widget &quot;${this.id}&quot;`);
    }

}

let widget = new Widget('text1');
widget.render();
</code></pre>
<p>You should get the following output when executed:</p>
<pre><code class="language-text">Rendering widget &quot;text1&quot;
</code></pre>
<h4 id="properties"><a class="header" href="#properties">Properties</a></h4>
<p>With ES6 you define class properties from with the class constructor:</p>
<pre><code class="language-js">// ES6
class Widget {

    constructor(id) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }

}
</code></pre>
<p>If you try compiling example above with <code>tsc</code> utility (TypeScript compiler) you should get the following errors:</p>
<pre><code class="language-text">error TS2339: Property 'id' does not exist on type 'Widget'.
error TS2339: Property 'x' does not exist on type 'Widget'.
error TS2339: Property 'y' does not exist on type 'Widget'.
</code></pre>
<p>The errors are raised because TypeScript requires you to define properties separately.
It is needed to enable many other features TypeScript provides.</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number;
    x: number;

    constructor(id: string) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }
}
</code></pre>
<p>Properties in TypeScript can have default values:</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number = 0;
    x: number = 0;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<h4 id="setters-and-getters"><a class="header" href="#setters-and-getters">Setters and Getters</a></h4>
<p>TypeScript supports <em>computed properties</em>, which do not store a value.
Instead, they provide <em>getters</em> and <em>setters</em> to retrieve and assign values in a controlled way.</p>
<p><strong>TBD</strong>: describe get/set format</p>
<p>One of the common cases for a <em>getter</em> is computing a return value based on other property values:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}

let user = new User('Joan', 'Doe');
console.log(`User full name is: ${user.fullName}`);
</code></pre>
<p>If you save this example to file <code>script.ts</code>, compile it and run like shown below:</p>
<pre><code class="language-sh">tsc --target ES6 script.ts
node script.js
</code></pre>
<p>You should see the output with the full username as expected:</p>
<pre><code class="language-text">User full name is: Joan Doe
</code></pre>
<p>Now let's introduce a simple <em>setter</em> for the <code>firstName</code> property.</p>
<p>Every time a new property value is set we are going to remove leading and trailing white space.
Such values as &quot; Joan&quot; and &quot;Joan  &quot; are automatically converted to &quot;Joan&quot;.</p>
<pre><code class="language-ts">class User {

    private _firstName: string;

    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        if (value) {
            this._firstName = value.trim();
        }
    }
}

let user = new User();
user.firstName = '  Joan   ';
console.log(`The first name is &quot;${user.firstName}&quot;.`);
</code></pre>
<p>The console output, in this case, should be:</p>
<pre><code class="language-text">The first name is &quot;Joan&quot;.
</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p>Methods are functions that operate on a class object and are bound to an instance of that object.
You can use <code>this</code> keyword to access properties and call other methods like in the example below:</p>
<pre><code class="language-ts">class Sprite {

    x: number;
    y: number;

    render() {
        console.log(`rendering widget at ${this.x}:${this.y}`);
    }
    
    moveTo(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.render();
    }

}

let sprite = new Sprite();
sprite.moveTo(5, 10);
// rendering widget at 5:10
</code></pre>
<h5 id="return-values"><a class="header" href="#return-values">Return values</a></h5>
<pre><code class="language-ts">class NumberWidget {

    getId(): string {
        return 'number1';
    }

    getValue(): number {
        return 10;
    }

}
</code></pre>
<p>You can use a <code>void</code> type if the method does not return any value.</p>
<pre><code class="language-ts">class TextWidget {

    text: string;

    reset(): void {
        this.text = '';
    }

}
</code></pre>
<h5 id="method-parameters"><a class="header" href="#method-parameters">Method parameters</a></h5>
<p>You can add types to each parameter of the method.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level: number) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>TypeScript will automatically perform type checking at compile time.
Let's try providing a string value for the <code>level</code> parameter:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 'not a number');
</code></pre>
<p>You should get a compile error with the following message:</p>
<pre><code class="language-text">error TS2345: Argument of type '&quot;string&quot;' is not assignable to parameter of type 'number'.
</code></pre>
<p>Now let's change <code>level</code> parameter to a number to fix compilation</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 2);
</code></pre>
<p>Now we should get the expected output:</p>
<pre><code class="language-text">(2): test
</code></pre>
<h5 id="optional-parameters"><a class="header" href="#optional-parameters">Optional parameters</a></h5>
<p>By default, all method/function parameters in TypeScript are <code>required</code>.
However, it is possible making parameters optional by appending <strong>?</strong> (question mark) symbol to the parameter name.</p>
<p>Let's update our <code>Logger</code> class and make <code>level</code> parameter optional.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level?: number) {
        if (level === undefined) {
            level = 1;
        }
        console.log(`(${level}): ${message}`);
    }

}

let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The <code>log</code> method provides default value automatically if <code>level</code> is omitted.</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<p>Please note that optional parameters must always follow required ones.</p>
<h5 id="default-parameters"><a class="header" href="#default-parameters">Default parameters</a></h5>
<p>TypeScript also supports default values for parameters.
Instead of checking every parameter for <code>undefined</code> value you can provide defaults directly within the method declaration:</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string = 'Unknown error', level: number = 1) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>Let's try calling <code>log</code> without any parameters:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The output, in this case, should be:</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<h5 id="rest-parameters-and-spread-operator"><a class="header" href="#rest-parameters-and-spread-operator">Rest Parameters and Spread Operator</a></h5>
<p>In TypeScript, you can gather multiple arguments into a single variable known as <em>rest parameter</em>.
Rest parameters were introduced as part of ES6, and TypesScripts extends them with type checking support.</p>
<pre><code class="language-ts">class Logger {

    showErrors(...errors: string[]) {
        for (let err of errors) {
            console.error(err);
        }
    }

}
</code></pre>
<p>Now you can provide an arbitrary number of arguments for <code>showErrors</code> method:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.showErrors('Something', 'went', 'wrong');
</code></pre>
<p>That should produce three errors as an output:</p>
<pre><code class="language-text">Something
went
wrong
</code></pre>
<p><em>Rest parameters</em> in TypeScript work great with <em>Spread Operator</em> allowing you to expand a collection into multiple arguments.
It is also possible mixing regular parameters with <em>spread</em> ones:</p>
<pre><code class="language-ts">let logger = new Logger();
let messages = ['something', 'went', 'wrong'];

logger.showErrors('Error', ...messages, '!');
</code></pre>
<p>In the example above we compose a collection of arguments from arbitrary parameters and content of the <code>messages</code> array in the middle.</p>
<p>The <code>showErrors</code> method should handle all entries correctly and produce the following output:</p>
<pre><code class="language-text">Error
something
went
wrong
!
</code></pre>
<h4 id="constructors"><a class="header" href="#constructors">Constructors</a></h4>
<p>Constructors in TypeScript got same features as methods.
You can have default and optional parameters, use rest parameters and spread operators with class constructor functions.</p>
<p>Besides, TypeScript provides support for automatic property creation based on constructor parameters.
Let's create a typical <code>User</code> class implementation:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}
</code></pre>
<p>Instead of assigning parameter values to the corresponding properties we can instruct TypeScript to perform an automatic assignment instead.
You can do that by putting one of the access modifiers <strong>public</strong>, <strong>private</strong> or <strong>protected</strong> before the parameter name.</p>
<p>You are going to get more details on <em>access modifiers</em> later in this book.
For now, let's see the updated <code>User</code> class using automatic property assignment:</p>
<pre><code class="language-ts">class User {

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(public firstName: string, public lastName: string) {
    }

}

let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<p>TypeScript creates <code>firstName</code> and <code>lastName</code> properties when generating JavaScript output.
You need targeting at least ES5 to use this feature.</p>
<p>Save example above to file <code>script.ts</code> then compile and run with <code>node</code>:</p>
<pre><code class="language-sh">tsc script.ts --target ES5
node script.js
</code></pre>
<p>The output should be as following:</p>
<pre><code class="language-text">Full name is: Joan Doe
</code></pre>
<p>You have not defined properties explicitly, but <code>fullName</code> getter was still able accessing them via <code>this</code>.
If you take a look at the emitted JavaScript you should see the properties are defined there as expected:</p>
<pre><code class="language-js">// ES5
var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    Object.defineProperty(User.prototype, &quot;fullName&quot;, {
        get: function () {
            return (this.firstName + &quot; &quot; + this.lastName).trim();
        },
        enumerable: true,
        configurable: true
    });
    return User;
}());
var user = new User('Joan', 'Doe');
console.log(&quot;Full name is: &quot; + user.fullName);
</code></pre>
<p>Now you can also switch to ES6 target to see how TypeScript assigns properties:</p>
<pre><code class="language-sh">tsc script.ts --target ES6
</code></pre>
<p>The generated JavaScript, in this case, is even smaller and cleaner:</p>
<pre><code class="language-js">// ES6
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName() {
        return `${this.firstName} ${this.lastName}`.trim();
    }
}
let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<h4 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h4>
<p>One of the important TypeScript features is the class inheritance that enables OOP patterns for developers.
Under the hood TypeScript is using the same <code>extends</code> syntactic sugar when targeting ES6 JavaScript,
and prototypical inheritance wrappers when generating output in ES5.</p>
<p>We can refer to animals as a classic example of class-based programming and inheritance.</p>
<pre><code class="language-ts">class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    makeSound() {
        console.log('Unknown sound');
    }
}
</code></pre>
<p>You have created a basic <code>Animal</code> class that contains a <code>name</code> property and <code>makeSound</code> method.
That translates to ES5 as following:</p>
<pre><code class="language-js">// ES5
var Animal = (function () {
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.makeSound = function () {
        console.log('Unknown sound');
    };
    return Animal;
}());
</code></pre>
<p>Now you can create a <code>Dog</code> implementation that provides a right sound:</p>
<pre><code class="language-ts">class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Woof-woof');
    }
}
</code></pre>
<p>Please note that if you have a constructor in the base class, then you must call it from all derived classes.
Otherwise, TypeScript should raise a compile-time error:</p>
<pre><code class="language-text">error TS2377: Constructors for derived classes must contain a 'super' call.
</code></pre>
<p>Here's how a <code>Dog</code> gets converted to ES5:</p>
<pre><code class="language-ts">var Dog = (function (_super) {
    __extends(Dog, _super);
    function Dog(name) {
        return _super.call(this, name) || this;
    }
    Dog.prototype.makeSound = function () {
        console.log('Woof-woof');
    };
    return Dog;
}(Animal));
</code></pre>
<p>Now let's add a <code>Cat</code> implementation with its sound and test both classes:</p>
<pre><code class="language-ts">class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Meow');
    }
}

let dog = new Dog('Spot');
let cat = new Cat('Tom');

dog.makeSound();
cat.makeSound();
</code></pre>
<p>Once the code compiles and executes you should get the following output:</p>
<pre><code class="language-text">Woof-woof
Meow
</code></pre>
<h4 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h4>
<p>TypeScript supports <code>public</code>, <code>private</code> and <code>protected</code> modifiers for defining accessibility of the class members.</p>
<h5 id="public"><a class="header" href="#public">Public</a></h5>
<p>By default, each member of the class is <code>public</code> so that you can omit it.
However, nothing stops you from declaring <code>public</code> modifier explicitly if needed:</p>
<pre><code class="language-ts">class User {
    public firstName: string;
    public lastName: string;

    public speak() {
        console.log('Hello');
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre>
<p>Now if you compile example above to JavaScript you should see the following:</p>
<pre><code class="language-js">var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    User.prototype.speak = function () {
        console.log('Hello');
    };
    return User;
}());
</code></pre>
<h5 id="private"><a class="header" href="#private">Private</a></h5>
<p>You mark a member as <code>private</code> when it should never be accessed from outside of its containing class.
One of the most common scenarios is creating private fields to hold values for properties.
For example:</p>
<pre><code class="language-ts">class User {
    private _firstName: string;
    private _lastName: string;

    get firstName() {
        return this._firstName;
    }

    get lastName() {
        return this._lastName;
    }

    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
}
</code></pre>
<p>The class we have created above allows setting user's first and last name only from within the constructor.</p>
<p>If you try changing name properties from outside the class, TypeScript will raise an error at compile time:</p>
<pre><code class="language-ts">let user = new User('John', 'Doe');
user.firstName = 'Rob';
// error TS2540: Cannot assign to 'firstName' because it is a constant or a read-only property.
</code></pre>
<h5 id="protected"><a class="header" href="#protected">Protected</a></h5>
<p>The <code>protected</code> modifier restricts member visibility from outside of the containing class but provides access from the derived classes.</p>
<p>Let's start with base <code>Page</code> class implementation:</p>
<pre><code class="language-ts">class Page {

    protected renderHeader()    { /* ... */ }
    protected renderContent()   { /* ... */ }
    protected renderFooter()    { /* ... */ }

    render() {
        this.renderHeader();
        this.renderContent();        
        this.renderFooter();
    }
}
</code></pre>
<p>We created a <code>Page</code> class that has public method <code>render</code>.
Internally <code>render</code> calls three separate methods to render header, content and footer of the page.
These methods are not available from the outside the the class.</p>
<p>Now we are going to create a simple derived <code>AboutPage</code> class:</p>
<pre><code class="language-ts">class AboutPage extends Page {

    private renderAboutContent() { /* ... */ }

    render() {
        this.renderHeader();
        this.renderAboutContent();
        this.renderFooter();
    }

}
</code></pre>
<p>As you can see the <code>AboutPage</code> defines its <code>render</code> method that calls
<code>renderHeader</code> and <code>renderFooter</code> in parent class but puts custom content in the middle.</p>
<p>You can also use <code>protected</code> modifier with class constructors.
In this case, the class can be instantiated only by the derived classes that extend it.
That becomes handy when you want to have properties and methods available for multiple classes as a base implementation,
but don't want a base class to be instantiated outside its containing class.</p>
<p>For example</p>
<pre><code class="language-ts">class Page {
    protected constructor(id: string) {
        // ...
    }

    render() { /* base render */ }
}

class MainPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render main page */ }
}

class AboutPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render about page */ }
}

let main = new MainPage('main');
let about = new AboutPage('about');
</code></pre>
<p>You can create instances of <code>MainPage</code> and <code>AboutPage</code> both having access to protected members of the <code>Page</code> class.
However, you are not able creating an instance of the <code>Page</code> class directly.</p>
<pre><code class="language-ts">let page = new Page(); 
// error TS2674: Constructor of class 'Page' is protected and only accessible within the class declaration.
</code></pre>
<h4 id="readonly-modifier"><a class="header" href="#readonly-modifier">Readonly modifier</a></h4>
<p>One of the common ways to create a read-only property in many object-oriented programming languages
is by having a private local variable with a <code>getter</code> only.</p>
<pre><code class="language-ts">class Widget {

    private _id: string;

    get id(): string {
        return this._id;
    }

    constructor(id: string) {
        this._id = id;
    }
}

let widget = new Widget('textBox');
console.log(`Widget id: ${widget.id}`);
// Widget id: textBox
</code></pre>
<p>You can also make properties read-only by using the <code>readonly</code> keyword.
That reduces repetitive typing when dealing with many read-only properties, and greatly improves overall code readability.</p>
<p>Let's update the previous example to use <code>readonly</code>:</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<p>If you try changing the value of the property outside of the constructor TypeScript will raise an error:</p>
<pre><code class="language-ts">let widget = new Widget('text');
widget.id = 'newId';
// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p>You can provide default values for read-only properties only in two places: property declaration and constructor.</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;
    readonly minWidth: number = 200;
    readonly minHeight: number = 100;

    constructor(id: string) {
        this.id = id;
    }
}

let widget = new Widget('text');
widget.minWidth = 1000;
// error TS2540: Cannot assign to 'minWidth' because it is a constant or a read-only property.
</code></pre>
<h3 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h3>
<p>An <em>interface</em> is a description of the actions that an object can do.</p>
<p>You might already be familiar with <em>interfaces</em> in other programming languages like C# and Java,
or <em>contracts</em> in Swift.</p>
<p>Interfaces are not part of the ECMAScript.
It is a level of abstraction supported by TypeScript to improve the type-checking process, and not converted to JavaScript code.</p>
<p>Here's an example of an interface describing generic <strong>Text</strong> component:</p>
<pre><code class="language-ts">interface TextComponent {

    text: string;
    render(): void;

}
</code></pre>
<p>Now you can use the interface above to describe the requirement of having the <strong>text</strong> property that is a string and a <strong>render</strong> method:</p>
<pre><code class="language-ts">class PlainTextComponent implements TextComponent {

    text: string;

    render() {
        console.log('rendering plain text component');
    }

}
</code></pre>
<p>We are using <code>implements</code> keyword to wire class with a particular interface.
It is not important in what order class members are defined as long as all properties and methods the interface requires
are present and have required types.</p>
<p>Let's create another class that implements <code>TextComponent</code> interface partially:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent {
    text: string;
}
</code></pre>
<p>Upon compilation TypeScript will produce the following error:</p>
<pre><code class="language-text">error TS2420: Class 'RichTextComponent' incorrectly implements interface 'TextComponent'.
Property 'render' is missing in type 'RichTextComponent'.
</code></pre>
<p>You can use multiple interfaces delimited by a comma:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent, OnInit, OnDestroy {
    // ...
}
</code></pre>
<p>The example above shows a class that must implement three different interfaces to compile.</p>
<h3 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h3>
<p>Interfaces describe only requirements for classes; you cannot create an instance of the interface.
You need <code>abstract</code> classes un order to provide implementation details.</p>
<pre><code class="language-ts">abstract class PageComponent {

    abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Same as with interfaces you cannot create instances of abstract classes directly, only other classes derived from an abstract one.
Also, it is possible marking class methods as <code>abstract</code>.
Abstract methods do not contain implementation, and similar to <code>interface</code> methods provide requirements for derived classes.</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Note how <code>HomePageComponent</code> implements abstract <code>renderContent</code> that has access to <code>renderHeader</code> and <code>renderFooter</code> methods carried out in the parent class.</p>
<p>You can also use access modifiers with abstract methods.
The most frequent scenario is when methods need to be accessible only from within the child classes, and invisible from the outside:</p>
<p>For example:</p>
<pre><code class="language-ts">abstract class PageComponent {

    protected abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Now <code>HomePageComponent</code> can make <code>renderContent</code> protected like shown below:</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    constructor() {
        super();
        this.renderContent();
    }

    protected renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Any additional class that inherits (extends) <code>HomePageComponent</code> will still be able calling or redefining <code>renderContent</code> method.
But if you try accessing <code>renderContent</code> from outside the TypeScript should raise the following error:</p>
<pre><code class="language-ts">let homePage = new HomePageComponent();
homePage.renderContent();
// error TS2445: Property 'renderContent' is protected and only 
// accessible within class 'HomePageComponent' and its subclasses.
</code></pre>
<p>Abstract classes is a great way consolidating common functionality in a single place.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>TypeScript supports the concept of modules introduced in ES6.
Modules allow isolating code and data and help splitting functionality into logical groups.</p>
<p>One of the major features of ES6 (and TypeScript) modules is their file scope.
The code inside the module (classes, variables, functions, and other) does not pollute global scope
and is not accessible from the outside unless <code>exported</code> explicitly.</p>
<p>To share the code of the module with the outside world, you use <code>export</code> keyword:</p>
<pre><code class="language-ts">// module1.ts
export class TextBoxComponent {
    constructor(public text: string) {}
    render() {
        console.log(`Rendering '${this.text}' value.`);
    }
}
</code></pre>
<p>To use this code in your main application file or another module, you must import it first.
You import the <code>TextBoxComponent</code> class using <code>import</code> keyword:</p>
<pre><code class="language-ts">// app.ts
import { TextBoxComponent } from './module1'

let textBox = new TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h4 id="module-loaders"><a class="header" href="#module-loaders">Module Loaders</a></h4>
<p>ES6 and TypeScript rely on <code>module loaders</code> to locate files, resolve external dependencies and execute module files.</p>
<p>The most popular module loaders are:</p>
<ul>
<li>Server side
<ul>
<li>CommonJs (used by node.js)</li>
</ul>
</li>
<li>Client side
<ul>
<li>SystemJS</li>
<li>RequireJS</li>
<li>Webpack</li>
</ul>
</li>
</ul>
<p>TypeScript supports different formats of generated JavaScript output.
You can instruct compiler to generate code adopted for multiple module loading systems using formats such as</p>
<ul>
<li>CommonJS (used in node.js)</li>
<li>RequireJS</li>
<li>UMD (Universal Module Definition)</li>
<li>SystemJS</li>
<li>ES6 (or ECMAScript 2015)</li>
</ul>
<h4 id="running-at-server-side"><a class="header" href="#running-at-server-side">Running at server side</a></h4>
<p>You can test <code>TextBoxComponent</code> we have created earlier with node.js using <code>commonjs</code> module target:</p>
<pre><code class="language-sh">tsc app.ts --module commonjs
node app.js
</code></pre>
<p>When executed it produces the following output:</p>
<pre><code class="language-text">Rendering 'hello world' value.
</code></pre>
<p>TypeScript automatically compiles referenced modules.
It starts with <code>app.ts</code>, resolves and compiles <code>module1</code> as <code>module1.ts</code> file,
and produces two JavaScript files <code>app.js</code> and <code>module.js</code> that can be executed by node.js.</p>
<p>Here's an example of <code>app.js</code> file content:</p>
<pre><code class="language-js">&quot;use strict&quot;;
// app.ts
var module1_1 = require(&quot;./module1&quot;);
var textBox = new module1_1.TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h4 id="running-in-browser"><a class="header" href="#running-in-browser">Running in browser</a></h4>
<p>In order to run module-based application in browser you can take <code>SystemJS</code> loader:</p>
<pre><code class="language-html">&lt;script src=&quot;systemjs/dist/system.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  SystemJS.import('/app/app.js');
&lt;/script&gt;
</code></pre>
<p>Let's take a look at a simple TypeScript application that references an external module.</p>
<pre><code class="language-ts">// logger.ts
export class Logger {

    output: any;

    constructor(outputId: string) {
        this.output = document.getElementById(outputId);
    }

    info(message: string) {
       this.output.innerText = `INFO: ${message}`;
    }

}
</code></pre>
<p>Our simple <code>logger</code> is going to put a message as a content of the document element provided from the outside.</p>
<pre><code class="language-ts">// app.ts
import { Logger } from './logger';

let logger = new Logger('content');
logger.info('hello world');
</code></pre>
<p>The application needs to be compiled with SystemJS support to load correctly.
You can configure TypeScript to generate compatible JavaScript code by setting module code generation setting to <code>system</code>:</p>
<pre><code class="language-sh">tsc app.ts --module system
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find source code for the examples above in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/typescript/systemjs-example">typescript/systemjs-example</a>&quot; folder.</p>
</blockquote>
<p>To install dependencies, compile and run the demo use the following commands:</p>
<pre><code class="language-sh">npm install
npm start
</code></pre>
<p>Your default browser should run example page automatically.
Once the page gets loaded you should see an expected message:</p>
<pre><code class="language-text">INFO: hello world
</code></pre>
<h3 id="decorators"><a class="header" href="#decorators">Decorators</a></h3>
<p>TypeScript introduces <code>decorators</code> feature, metadata expressions similar to Java annotation tags or C# and Swift attributes.
ECMAScript does not yet have native support for annotating classes and class members (the feature is in the <code>proposal</code> state),
so <code>decorators</code> is an experimental TypeScript feature.</p>
<p>Decorators have a traditional notation of <code>@expression</code> where <code>expression</code> is the name of the function that should be invoked at runtime.</p>
<p>This function receives <code>decorated</code> target as a parameter and can be attached to:</p>
<ul>
<li>class declaration</li>
<li>method</li>
<li>accessor</li>
<li>property</li>
<li>parameter</li>
</ul>
<h4 id="class-decorators"><a class="header" href="#class-decorators">Class Decorators</a></h4>
<p>Class decorators are attached to class declarations.
At runtime, the function that backs the decorator gets applied to the class constructor.
That allows decorators inspecting, modifying or even replacing class instances if needed.</p>
<p>Here's a simple example of the <code>LogClass</code> decorator that outputs some log information every time being invoked:</p>
<pre><code class="language-ts">function LogClass(constructor: Function) {
    console.log('LogClass decorator executed for the constructor:');
    console.log(constructor);
}
</code></pre>
<p>Now you can use newly created decorator with different classes:</p>
<pre><code class="language-ts">@LogClass
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}
</code></pre>
<p>When a new instance of <code>TextWidget</code> class is created, the <code>@LogClass</code> attribute will be automatically invoked:</p>
<pre><code class="language-ts">let widget = new TextWidget();
widget.render();
</code></pre>
<p>The class decorator should produce the following output:</p>
<pre><code class="language-text">LogClass decorator executed for the constructor:
[Function: TextWidget]
Rendering text: default text
</code></pre>
<h5 id="decorators-with-parameters"><a class="header" href="#decorators-with-parameters">Decorators with parameters</a></h5>
<p>It is also possible passing values to decorators. You can achieve this with a feature known as <code>decorator factories</code>.
A <em>decorator factory</em> is a function returning an expression that is called at runtime:</p>
<p>Let's create another simple decorator with log output that accepts additional <code>prefix</code> and <code>suffix</code> settings:</p>
<pre><code class="language-ts">function LogClassWithParams(prefix: string, suffix: string) {
    return (constructor: Function) =&gt; {
        console.log(`
            ${prefix} 
            LogClassWithParams decorator called for: 
            ${constructor} 
            ${suffix}
        `);
    };
}
</code></pre>
<p>It can now be tested with the <code>TextWidget</code> class created earlier:</p>
<pre><code class="language-ts">@LogClassWithParams('BEGIN:', ':END')
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>You have marked <code>TextWidget</code> class with the <code>LogClassWithParams</code> decorator having a <code>prefix</code> and <code>suffix</code> properties
set to <code>BEGIN:</code> and <code>:END</code> values. The console output, in this case, should be:</p>
<pre><code class="language-text">BEGIN:
LogClassWithParams decorator called for: 
function TextWidget(text) {
    if (text === void 0) { text = 'default text'; }
        this.text = text;
    }
}
:END
</code></pre>
<h5 id="multiple-decorators"><a class="header" href="#multiple-decorators">Multiple decorators</a></h5>
<p>You are not limited to a single decorator per class.
TypeScript allows declaring as much class and member decorators as needed:</p>
<pre><code class="language-ts">@LogClass
@LogClassWithParams('BEGIN:', ':END')
@LogClassWithParams('[', ']')
class TextWidget {
    // ...
}
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
It means that first decorator that gets executed is:</p>
<pre><code class="language-ts">@LogClassWithParams('[', ']')
</code></pre>
<p>and the last decorator is going to be</p>
<pre><code class="language-ts">@LogClass
</code></pre>
<h4 id="method-decorators"><a class="header" href="#method-decorators">Method Decorators</a></h4>
<p>Method decorators are attached to class methods and can be used to inspect, modify or completely replace method definition of the class.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Let's create a decorator to inspect those parameters:</p>
<pre><code class="language-ts">function LogMethod(target: any, 
                   propertyKey: string, 
                   descriptor: PropertyDescriptor) {
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Below is an example of this decorator applied to a <code>render</code> method of <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethod
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>The console output in this case will be as following:</p>
<pre><code class="language-text">TextWidget { render: [Function] }
render
{ value: [Function],
  writable: true,
  enumerable: true,
  configurable: true }
Rendering text: default text
</code></pre>
<p>You can use <code>decorator factories</code> also with method decorators to support additional parameters.</p>
<pre><code class="language-ts">function LogMethodWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`${propertyKey}: ${message}`);
    };
}
</code></pre>
<p>This decorator can now be applied to methods. You can attach multiple decorators to a single method:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethodWithParams('hello')
    @LogMethodWithParams('world')
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
If you run the code the output should be as follows:</p>
<pre><code class="language-text">render: world
render: hello
Rendering text: default text
</code></pre>
<h4 id="accessor-decorators"><a class="header" href="#accessor-decorators">Accessor Decorators</a></h4>
<p>Accessor decorators are attached to property <code>getters</code> or <code>setters</code> and can be used to inspect, modify or completely replace accessor definition of the property.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Note that you can attach accessor decorator to either <code>getter</code> or <code>setter</code> but not both.
This restriction exists because on the low level decorators deal with
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Property Descriptors</a>
that contain both <code>get</code> and <code>set</code> accessors.</p>
<p>Let's create a decorator to inspect parameters:</p>
<pre><code class="language-ts">function LogAccessor(target: any, 
                     propertyKey: string, 
                     descriptor: PropertyDescriptor) {
    console.log('LogAccessor decorator called');
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Now the decorator can be applied to the following <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessor
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>Once invoked the decorator should produce the following output:</p>
<pre><code class="language-text">LogAccessor decorator called
TextWidget { text: [Getter/Setter] }
text
{ get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true }
</code></pre>
<p>Same as with class and method decorators you can use decorator factories feature to pass parameters to your accessor decorator.</p>
<pre><code class="language-ts">function LogAccessorWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`Message from decorator: ${message}`);
    }
}
</code></pre>
<p>TypeScript allows using more than one decorator given you attach it to the same property accessor:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    @LogAccessorWithParams('world')
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>The console output should be as shown below, note the right-to-left execution order:</p>
<pre><code class="language-text">Message from decorator: world
Message from decorator: hello
</code></pre>
<p>In case you declare decorator for both accessors TypeScript generates an error at compile time:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    get text(): string {
        return this._text;
    }
    
    @LogAccessorWithParams('world')
    set text(value: string) {
        this._text = value;
    }
}
</code></pre>
<pre><code class="language-text">error TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.
</code></pre>
<h4 id="property-decorators"><a class="header" href="#property-decorators">Property Decorators</a></h4>
<p>Property decorators are attached to class properties.
At runtime, property decorator receives the following arguments:</p>
<ul>
<li>target object</li>
<li>property name</li>
</ul>
<p>Due to technical limitations, it is not currently possible observing or modifying property initializers.
That is why property decorators do not get Property Descriptor value at runtime
and can be used mainly to observe a property with a particular name has been defined for a class.</p>
<p>Here's a simple property decorator to display parameters it gets at runtime:</p>
<pre><code class="language-ts">function LogProperty(target: any, propertyKey: string) {
    console.log('LogProperty decorator called');
    console.log(target);
    console.log(propertyKey);
}
</code></pre>
<pre><code class="language-ts">class TextWidget {

    @LogProperty
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        // ...
    }
}

let widget = new TextWidget('text1');
</code></pre>
<p>The output in this case should be as following:</p>
<pre><code class="language-text">LogProperty decorator called
TextWidget { render: [Function] }
id
</code></pre>
<h4 id="parameter-decorators"><a class="header" href="#parameter-decorators">Parameter Decorators</a></h4>
<p>Parameter decorators are attached to function parameters.
At runtime, every parameter decorator function is called with the following arguments:</p>
<ul>
<li>target</li>
<li>parameter name</li>
<li>parameter position index</li>
</ul>
<p>Due to technical limitations, it is possible only detecting that a particular parameter has been declared on a function.</p>
<p>Let's inspect runtime arguments with this simple parameter decorator:</p>
<pre><code class="language-ts">function LogParameter(target: any, 
                      parameterName: string, 
                      parameterIndex: number) {
    console.log('LogParameter decorator called');
    console.log(target);
    console.log(parameterName);
    console.log(parameterIndex);
}
</code></pre>
<p>You can now use this decorator with a class constructor and method parameters:</p>
<pre><code class="language-ts">class TextWidget {

    render(@LogParameter positionX: number, 
           @LogParameter positionY: number) {
        // ...
    }

}
</code></pre>
<p>Parameter decorators are also executed in right-to-left order.
So you should see console outputs for <code>positionY</code> and then <code>positionX</code>:</p>
<pre><code class="language-text">LogParameter decorator called
TextWidget { render: [Function] }
render
1
LogParameter decorator called
TextWidget { render: [Function] }
render
0
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch03-01-getting-started.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch03-01-getting-started.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-23X2CQXZ48', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
