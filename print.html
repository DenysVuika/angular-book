<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Angular Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Angular Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="ch01-02-vscode.html"><strong aria-hidden="true">1.2.</strong> Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-es6.html"><strong aria-hidden="true">2.</strong> ES6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-classes.html"><strong aria-hidden="true">2.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch02-02-inheritance.html"><strong aria-hidden="true">2.2.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="ch02-03-arrow-functions.html"><strong aria-hidden="true">2.3.</strong> Arrow Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-template-literals.html"><strong aria-hidden="true">2.4.</strong> Template Literals</a></li><li class="chapter-item expanded "><a href="ch02-05-extended-parameters.html"><strong aria-hidden="true">2.5.</strong> Extended Parameter Handling</a></li><li class="chapter-item expanded "><a href="ch02-06-destructuring.html"><strong aria-hidden="true">2.6.</strong> Destructuring Assignment</a></li><li class="chapter-item expanded "><a href="ch02-07-modules.html"><strong aria-hidden="true">2.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch02-08-see-also.html"><strong aria-hidden="true">2.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-typescript.html"><strong aria-hidden="true">3.</strong> TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch03-02-features.html"><strong aria-hidden="true">3.2.</strong> TypeScript Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-03-types.html"><strong aria-hidden="true">3.2.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="ch03-04-classes.html"><strong aria-hidden="true">3.2.2.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch03-05-interfaces.html"><strong aria-hidden="true">3.2.3.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch03-06-abstract-classes.html"><strong aria-hidden="true">3.2.4.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="ch03-07-modules.html"><strong aria-hidden="true">3.2.5.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch03-08-decorators.html"><strong aria-hidden="true">3.2.6.</strong> Decorators</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Angular CLI</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.1.</strong> Installing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.2.</strong> Your first application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.3.</strong> Running application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.4.</strong> Code Linting</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.5.</strong> Unit tests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.6.</strong> Code coverage</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.7.</strong> Development and Production builds</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.8.</strong> Using blueprints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.9.</strong> Creating modules</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.10.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.11.</strong> Generating standalone scripts</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Components</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Creating a simple component</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Generating components with Angular CLI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Component metadata</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Templates</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Styles</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Output events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> Providers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.10.</strong> Host</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.</strong> Queries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.12.</strong> Content Projection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.</strong> Dependency Injection</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.1.</strong> Preparing a project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.2.</strong> Services</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.3.</strong> Providers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.4.</strong> Injecting multiple instances</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.5.</strong> Optional dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.6.</strong> Manual injection with ReflectiveInjector</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.7.</strong> Summary</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.1.</strong> Component events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.2.</strong> DOM events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.3.</strong> Service events</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.</strong> Directives</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.1.</strong> Introduction to Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.2.</strong> Attribute Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.3.</strong> Structural Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.15.4.</strong> Modifying host element layout</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.16.</strong> Walkthrough: Upload Directive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.</strong> Pipes</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.1.</strong> Introduction to Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.2.</strong> Pipes with Parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.3.</strong> Chaining Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.4.</strong> Built-in Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.5.</strong> Custom Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.17.6.</strong> Pure And Impure Pipes</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.</strong> Global Application Configuration</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.1.</strong> Preparing the configuration file</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.2.</strong> Creating the configuration service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.3.</strong> Loading server-side configuration file</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.4.</strong> Registering configuration service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.18.5.</strong> Using configuration settings</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.</strong> Internationalisation (i18n)</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.1.</strong> Creating Translate Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.2.</strong> Creating Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.3.</strong> Using Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.4.</strong> Switching languages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.19.5.</strong> Summary</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Reusable Component Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Creating new application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Creating component libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Building the packages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Publishing to NPM</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Dynamic Content in Angular</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Using with Docker</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Additional Resources</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Preparing new project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Creating Dockerfile</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Testing in a container</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Creating docker-compose.yml</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Consuming from Docker Hub</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.7.</strong> Automating with Travis</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.8.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Webpack</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Initial project structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Typescript configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Basic webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Advanced webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> Unit testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Building a Mobile App with Cordova and Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Installing command-line tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Generating a new Angular App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Summary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Angular Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/DenysVuika/angular-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-angular-book"><a class="header" href="#the-angular-book">The Angular Book</a></h1>
<p><em>by Denys Vuika, with contributions from the Angular Community</em></p>
<p>This is the second and online edition of the <a href="https://leanpub.com/developing-with-angular">Developing with Angular</a> book.</p>
<blockquote>
<p>Note: this book is still in progress.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In the first few chapters, we are going to dwell on the basics you may need to understand Angular development better later on.</p>
<p>We are going to start with the main ES6 (ECMAScript 2015) features you should come across frequently when using TypeScript.</p>
<p>Next, the most remarkable TypeScript features you should get familiar before starting the Angular development.</p>
<p>After that, we are covering the Angular framework and supplemental toolings, like Angular CLI (Command Line Interface) and Webpack.</p>
<p>Finally, you should expect many practical topics that are addressing specific application requirements and scenarios,
including those coming from the community requests.</p>
<h2 id="book-progress"><a class="header" href="#book-progress">Book progress</a></h2>
<p>You can see the progress of the writing on this <a href="https://github.com/DenysVuika/angular-book/projects/1">GitHub board</a>.
Be sure to check the board if you want to see what's coming next or what is in progress right now.</p>
<h2 id="code-examples"><a class="header" href="#code-examples">Code examples</a></h2>
<p>You can find all code examples in this GitHub repository: <a href="https://github.com/DenysVuika/angular-book">angular-book</a>.
The source code gets frequently revisited and updated.</p>
<h2 id="feedback-bug-reports-and-suggestions"><a class="header" href="#feedback-bug-reports-and-suggestions">Feedback, Bug Reports and Suggestions</a></h2>
<p>If you have noticed a typo in the text or a bug in the code examples,
please don't hesitate and contact me using the next email address:
<a href="mailto:denys.vuika@gmail.com?subject=angular-book%20feedback">denys.vuika@gmail.com</a></p>
<p>You are also invited to raise issues for the source code and examples using corresponding <a href="https://github.com/DenysVuika/angular-book/issues">issue tracker</a> at GitHub.</p>
<p>Feel free to raise feature requests and suggestions on what you would like to see next.</p>
<h2 id="other-publications"><a class="header" href="#other-publications">Other publications</a></h2>
<p>You can find many other interesting publications at my <a href="https://denys.dev/">Blog</a>.</p>
<h2 id="testimonials"><a class="header" href="#testimonials">Testimonials</a></h2>
<p>Your feedback on the book content is very appreciated.
I would love to publish your photo and testimonial on the web page of the book.
Email me at: <a href="mailto:denys.vuika@gmail.com?subject=angular-book%20testimonial">denys.vuika@gmail.com</a>.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>In this chapter, we are going to configure the following applications and libraries:</p>
<ul>
<li>Node.js</li>
<li>Visual Studio Code</li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<p>Node.js is a JavaScript runtime built on <a href="https://developers.google.com/v8/">Chrome's V8 JavaScript engine</a>.
Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
Node.js' package ecosystem, <a href="https://www.npmjs.com/">npm</a>, is the largest ecosystem of open source libraries in the world.</p>
<p>Navigate to the <a href="https://nodejs.org/en/">main page</a>, download installer for your platform and follow setup instructions.</p>
<p>You can use the following commands to test current versions of the Node and NPM on your machine:</p>
<pre><code class="language-sh">node -v
# v14.16.0

npm -v
# 6.14.11
</code></pre>
<p>Please note that the actual versions may differ.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS.
It includes support for debugging, embedded Git control, syntax highlighting,
intelligent code completion, snippets, and code refactoring.</p>
<p><img src="images/vscode-mac-lg-2x.png" alt="vs code" /></p>
<h3 id="recommended-extensions"><a class="header" href="#recommended-extensions">Recommended extensions</a></h3>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint">TSLint</a></strong></p>
<p>Integrates the tslint linter for the TypeScript language into VS Code.</p>
<p>Launch VS Code Quick Open (âŒ˜+P), paste the following command, and press enter.</p>
<pre><code class="language-sh">ext install tslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></strong></p>
<p>Integrates ESLint into VS Code. See <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">project page</a> for more details.</p>
<pre><code class="language-sh">ext install vscode-eslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig</a></strong></p>
<p>EditorConfig Support for Visual Studio Code</p>
<pre><code class="language-sh">ext install EditorConfig
</code></pre>
<h3 id="hiding-files"><a class="header" href="#hiding-files">Hiding files</a></h3>
<p>This step is optional.
In the code go to the <code>Preferences</code> -&gt; <code>Workspace Settings</code> and paste the following settings into the opened file:</p>
<pre><code class="language-json">{
    &quot;files.exclude&quot;: {
        &quot;**/.git&quot;: true,
        &quot;**/.DS_Store&quot;: true
    }
}
</code></pre>
<p>You can extend the list with the files, extensions or directories based on your preferences.</p>
<h1 id="es6"><a class="header" href="#es6">ES6</a></h1>
<p>ECMAScript 2015 (also known as ES6 and often referred to as <code>Harmony</code>) is the 6th major release of the ECMAScript language specification.</p>
<p>I am going to cover the most important features here to get you started with ES6 and then be able moving to TypeScript and Angular faster.</p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>The <code>class</code> syntax in JavaScript is not a new object-oriented inheritance model
but simply a syntactical sugar on top of the existing prototype-based inheritance.</p>
<p>Traditionally we have been using standard Objects and Prototypes like shown below:</p>
<pre><code class="language-js">var Widget = function(id, x, y) {
    this.id = id;
    this.setPosition(x, y);
}
Widget.prototype.setPosition = function(x, y) {
    this.x = x;
    this.y = y;
}
</code></pre>
<p>With class syntax developers get more natural and boilerplate-free result:</p>
<pre><code class="language-js">class Widget {
    constructor(id, x, y) {
        this.id = id;
        this.setPosition(x, y);
    }

    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
<p>The <code>constructor</code> function is automatically called when you create a new instance of <code>Widget</code>:</p>
<pre><code class="language-js">const myWidget = new Widget(1, 10, 20);
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>The <code>extends</code> keyword is used to define a class as a child of another class.
The following example demonstrates inheritance in practice:</p>
<pre><code class="language-js">class TextBox extends Widget {
    constructor (id, x, y, text) {
        super(id, x, y);
        this.text = text;
    }
}
</code></pre>
<p>We created a new <code>TextBox</code> class that is based on the <code>Widget</code> and adds additional <code>text</code> property.</p>
<p>Note that a base Widget constructor must also be called when a child class instantiated.
It must be the very first line of the child constructor implementation.</p>
<p>Here's another example:</p>
<pre><code class="language-js">class ImageBox extends Widget {
    constructor (id, x, y, width, height) {
        super(id, x, y);
        this.setSize(width, height);
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
    }

    reset() {
        this.setPosition(0, 0);
        this.setSize(0, 0);
    }
}
</code></pre>
<p><code>ImageBox</code> also inherits <code>Widget</code> class and adds size-related information alongside position.</p>
<p>Access to both classes is demonstrated with the <code>reset</code> function that calls <code>Widget.setPosition</code> and <code>ImageBox.setSize</code> functions.</p>
<h2 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h2>
<p>ES6 offers a shorter syntax for a <strong>function expression</strong> called <strong>arrow function</strong>, also known as <strong>fat arrow function</strong>.</p>
<p>Arrow functions provide more expressive closure syntax, simplify function scoping and change the way <code>this</code> is handled.</p>
<h3 id="expression-bodies"><a class="header" href="#expression-bodies">Expression Bodies</a></h3>
<p>When used as expressions bodies arrow functions work much like anonymous one-line <strong>lambdas</strong> that you can meet in many programming languages.</p>
<p>Let's filter a book collection to find something to read using both ES5 and ES6 to see the difference:</p>
<pre><code class="language-js">var books = [
    { name: 'Book 1', read: true },
    { name: 'Book 2' , read: false },
    { name: 'Book 3', read: true }
];

// ES5
var booksToRead = books.filter(function (b) { return !b.read });

// ES6
var booksToRead = books.filter(b =&gt; !b.read);
</code></pre>
<p>Curly brackets and <code>return</code> statement are not required if only one expression is present.</p>
<p>You could write the same example like following:</p>
<pre><code class="language-js">// ES6
let booksToRead = books.filter(b =&gt; { return !b.read; });
</code></pre>
<h3 id="statement-bodies"><a class="header" href="#statement-bodies">Statement Bodies</a></h3>
<p>Arrow functions provide more expressive closure syntax.</p>
<pre><code class="language-js">// ES6
// list the books I've read
books.forEach(b =&gt; {
    if (book.read) {
        console.log(b.name);
    }
});
</code></pre>
<p>And another example using DOM:</p>
<pre><code class="language-js">// ES6
let button = document.getElementById('submit-button');

button.addEventListener('click' () =&gt; {
    this.onButtonClicked();
});
</code></pre>
<p>Parameterless arrow functions are much easier to read</p>
<pre><code class="language-js">// ES6
setTimeout(_ =&gt; {
    console.log('First callback');
    setTimeout(_ =&gt; {
        console.log('Second callback');
    }, 1);
}, 1);
</code></pre>
<h3 id="lexical-this"><a class="header" href="#lexical-this">Lexical <em>this</em></a></h3>
<p>One of the best features of arrow functions in ES6 is the more intuitive handling of current object context.
These function expressions do not bind their variables:</p>
<ul>
<li>arguments</li>
<li>super</li>
<li>this</li>
<li>new.target</li>
</ul>
<pre><code class="language-js">// ES6
this.books.forEach(b =&gt; {
    if (!b.read) {
        this.booksToRead.push(b);
    }
});
</code></pre>
<p>There are multiple ways of doing the same with ECMAScript 5, and all of them involve manual context management</p>
<pre><code class="language-js">// ES5: using 'bind()'
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}).bind(this);

// ES5: referencing 'this' via variables
var self = this;

this.books.forEach(function(b) {
  if (!b.read) {
    self.booksToRead.push(b);
  }
});

// ES5: passing context if supported
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}, this);
</code></pre>
<p>As arrow functions do not create and bind their own <code>this</code> context the following code is concise and works as expected:</p>
<pre><code class="language-js">// ES6
function ProgressBar() {
  this.progress = 0;

  setInterval(() =&gt; {
    this.progress++;
  }, 1000);
}

const p = new ProgressBar();
</code></pre>
<p>In the example above <code>this</code> properly refers to the <code>ProgressBar</code> object.
Before ES6 you would most probably additional variables like <code>self</code>, <code>that</code>, and other.</p>
<pre><code class="language-js">// ES5
function ProgressBar() {
  var self = this;
  self.progress = 0;

  setInterval(function () {
    self.progress++;
  }, 1000);
}
</code></pre>
<h2 id="template-literals"><a class="header" href="#template-literals">Template Literals</a></h2>
<p>Template Literals (formerly called &quot;template strings&quot; in prior drafts of the ECMAScript 6 language specification) are string literals providing intuitive expression interpolation for single-line and multiline strings. </p>
<p>You use backticks to enclose a string literal and ${} to interpolate JavaScript variables or arbitrary expressions</p>
<pre><code class="language-js">// ES6
let point = { x: 10, y: 20 };

console.log(`Position is ${point.x}:${point.y}`);
// output: Position is 10:10
</code></pre>
<p>With ES5 you have to concatenate strings when dealing with multiple lines:</p>
<pre><code class="language-js">// ES5
var title = 'Title'
var component = {
  template: '' + 
    '&lt;h1&gt;' + title + '&lt;h1&gt;\n' +
    '&lt;div class=&quot;grid&quot;&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '&lt;/div&gt;'
}
</code></pre>
<p>Multi-line string creation with template literals becomes very clean and readable:</p>
<pre><code class="language-js">// ES6
let title = 'Title';
let component = {
  template: `
    &lt;h1&gt;${title}&lt;/h1&gt;
    &lt;div class=&quot;grid&quot;&gt;
      &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;col-6&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
}
</code></pre>
<h2 id="extended-parameter-handling"><a class="header" href="#extended-parameter-handling">Extended Parameter Handling</a></h2>
<p>ES6 brings improvements to parameter handling by introducing <code>default values</code>, <code>rest parameter</code> and <code>spread operator</code>.</p>
<h3 id="default-parameter-values"><a class="header" href="#default-parameter-values">Default Parameter Values</a></h3>
<p>Simple and intuitive default values for function parameters.</p>
<pre><code class="language-js">// ES6
function playSound(file, volume = 50) {
  console.log(`Playing '${file}' with volume ${volume}.`);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>With ES5 you have to check every parameter to be <code>undefined</code> and setting defaults manually if needed.</p>
<pre><code class="language-js">// ES5
function playSound(file, volume) {
    if (volume === undefined) {
        volume = 50;
    }
    console.log(&quot;Playing '&quot; + file + &quot;' with volume &quot; + volume);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>So support for <code>default parameter values</code> is a huge step forward and real time saver.</p>
<h3 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h3>
<p>In ES5, if you want your function to handle an indefinite or an arbitrary number of arguments,
you must use special <code>arguments</code> variable:</p>
<pre><code class="language-js">// ES5
function logMessages() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i]);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Which produces:</p>
<pre><code class="language-text">Hello,
world!
</code></pre>
<p>In ES6, you can aggregate all remaining arguments into a single function parameter</p>
<pre><code class="language-js">// ES6
function logMessages(...messages) {
  for (const message of messages) {
    console.log(message);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Also, that gives the same console output as before:</p>
<pre><code class="language-text">Hello, 
world!
</code></pre>
<p>Rest parameters become even more valuable when you need collecting arguments starting from a different position.</p>
<p>In the next example, the rest parameter is used to collect arguments from the second one to the end of the array.</p>
<pre><code class="language-js">// ES6
function greet(message, ...friends) {
  for (const friend of friends) {
    console.log(`${message}, ${friend}!`);
  }
}

greet('Hello', 'John', 'Joan', 'Bob')
</code></pre>
<p>The function above allows you to set the greeting message as the first parameter and array of friend names to generate messages.
The console output, in this case, should be:</p>
<pre><code class="language-text">Hello, John!
Hello, Joan!
Hello, Bob!
</code></pre>
<h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<p>Spread operator is used to expand an iterable collection into multiple arguments.</p>
<pre><code class="language-js">// ES6
let positive = [ 1, 2, 3 ];
let negative = [ -1, -2, -3 ]

let numbers = [...negative, 0, ...positive];

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<p>You can use spread operator even with strings:</p>
<pre><code class="language-js">// ES6
let message = 'Hello, world';
let chars = [...message];

console.log(chars);
// [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;,&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]
</code></pre>
<p>Spread operator easily becomes an alternative to the <code>Array.prototype.concat()</code> method.
With ES5 the example above will look like the following:</p>
<pre><code class="language-js">// ES5
var positive = [ 1, 2, 3 ];
var negative = [ -1, -2, -3 ];
var zero = [0];

var numbers = negative.concat(zero, positive);

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<h2 id="destructuring-assignment"><a class="header" href="#destructuring-assignment">Destructuring Assignment</a></h2>
<p>ES6 provides a way to extract values out of the objects or collections into the separate variables to access them easier in the code.
That is often called &quot;value unpacking&quot; or &quot;destructuring&quot;.</p>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic example</a></h3>
<p>As an example, you can extract a subset of values from the collection using the following format:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's create an array of words and extract the first couple of them into separate variables &quot;first&quot; and &quot;second&quot; like in the code below:</p>
<pre><code class="language-js">// ES6

let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second ] = words;

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<p>As you can see from the example above, you can extract a subset of an array and split it into multiple variables.</p>
<p>Without destructuring your code might look like the following:</p>
<pre><code class="language-js">// ES5

var words = [ 'this', 'is', 'hello', 'world', 'example' ];
var first = words[0];
var second = words[1];

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<h3 id="array-destructuring"><a class="header" href="#array-destructuring">Array destructuring</a></h3>
<p>You have already seen some of the array destructuring examples earlier in the section.
We enclose variables in square brackets using the following syntax:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Please note that you can also apply the same destructuring technique to the function call results:</p>
<pre><code class="language-js">// ES6

function getWords() {
    return [ 'this', 'is', 'hello', 'world', 'example' ];
}

let [ first, second ] = getWords();
console.log(`${first} ${second}`); // 'this is'
</code></pre>
<p>In addition to basic unpacking and variable assignment, several other things bring much value and reduce the code.</p>
<h4 id="value-assignment"><a class="header" href="#value-assignment">Value assignment</a></h4>
<p>The destructuring syntax can be used to assign values to variables instead of extracting them.
Take a look at the following example: </p>
<pre><code class="language-js">// ES6

let first, second;

[ first, second ] = [ 'hello', 'world' ];

console.log(first);  // 'hello'
console.log(second); // 'world'
</code></pre>
<h4 id="default-values"><a class="header" href="#default-values">Default values</a></h4>
<p>Another great feature of the array destructuring is default values.
There might be cases when the array has no values, and you want to provide some reasonable defaults.</p>
<p>The format of the syntax, in this case, is as follows:</p>
<pre><code class="language-text">let [ &lt;variable&gt; = &lt;value&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's see this feature in action:</p>
<pre><code class="language-js">// ES6

let words = [ 'hello' ];
let [ first = 'hey', second = 'there' ] = words;

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<p>The array we got initially does not contain two words.
We are trying to extract first two variables from it, and set 'hey' as the default value for the first word, and 'there' as a default for the second one.
At the runtime however only second variable stays with the default value.</p>
<p>Default value assignment is a compelling feature that helps you reduce the code for variable initialization and safety checks.
Below is how the same code could look like in ES5:</p>
<pre><code class="language-js">// ES5

var words = ['hello'];

var first = words[0];
if (!first) {
    first = 'hey';
}

var second = words[1];
if (!second) {
    second = 'there'
}

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<h4 id="swapping-values"><a class="header" href="#swapping-values">Swapping values</a></h4>
<p>Traditionally to swap two variables, developers need a third temporary one to hold the value of either first or second variable.</p>
<pre><code class="language-js">// ES5

var first = 'world';
var second = 'hello';

var temp = first;
first = second;
second = temp;

console.log(first + ' ' + second); // 'hello world'
</code></pre>
<p>With ES6 you can now reduce the code by using destructuring assignment syntax to swap variables in a single line like in the next example:</p>
<pre><code class="language-js">// ES6

let first = 'world';
let second = 'hello';

[ first, second ] = [ second, first ];

console.log(`${first} ${second}`); // 'hello world'
</code></pre>
<p>This feature may be a great time saver when it comes to sorting functions.</p>
<h4 id="skipping-values"><a class="header" href="#skipping-values">Skipping values</a></h4>
<p>We have been using examples that take the beginning of the array so far.<br />
The ES6 does not restrict you to that only scenario; it is also possible skipping values when unpacking or destructuring arrays.</p>
<pre><code class="language-text">let [ &lt;variable-1&gt;, , , , &lt;variable-X&gt; ] = &lt;array&gt;
</code></pre>
<p>You can just put the commas instead of variables like in the example below:</p>
<pre><code class="language-js">let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second, , , last ] = words;

console.log(`${first} ${second} ${last}`); // 'this is example'
</code></pre>
<h4 id="grouping-tail-values-into-a-single-variable"><a class="header" href="#grouping-tail-values-into-a-single-variable">Grouping tail values into a single variable</a></h4>
<p>As you see, the ES6 allows you to unpack the head of the array into separate variables.
Sometimes you may want to access the tail of the array as a single variable as well.</p>
<p>For this particular case, there's a special syntax that utilizes ES6 &quot;rest&quot; parameters.</p>
<pre><code class="language-text">let [ &lt;variable1&gt;, &lt;variable2&gt;, ...&lt;restVariable&gt; ] = &lt;array&gt;
</code></pre>
<p>We use &quot;rest parameter&quot; to define a variable to hold the tail of the array and below is an example of how to achieve this behavior:</p>
<pre><code class="language-js">let command = [ 'greet', 'user1', 'user2', 'user3' ];
let [ action, ...users ] = command;

console.log(action); // 'greet'
console.log(users);  // [ 'user1', 'user2', 'user3' ] 
</code></pre>
<h3 id="object-destructuring"><a class="header" href="#object-destructuring">Object destructuring</a></h3>
<p>Besides arrays and collections, you can use destructuring assignment syntax with the object instances as well.</p>
<p>We enclose variables in curly brackets using the following syntax:</p>
<pre><code class="language-text">let { &lt;var1&gt;, &lt;var2&gt; } = &lt;object&gt;
</code></pre>
<h4 id="unpacking-properties"><a class="header" href="#unpacking-properties">Unpacking properties</a></h4>
<p>ES6 allows you to extract properties by their names similar to how to unpack arrays.</p>
<p>Let's try to unpack a couple of properties from a user object:</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id, username } = obj;

console.log(id);        // '1'
console.log(username);  // 'jdoe'
</code></pre>
<h4 id="renaming-properties"><a class="header" href="#renaming-properties">Renaming properties</a></h4>
<p>You can also give destructured property an alias if you want to use it as a variable with a different name.</p>
<p>The syntax, in this case, is going to be as follows:</p>
<pre><code class="language-text">let { &lt;property&gt; : &lt;alias&gt; } = &lt;object&gt;;
</code></pre>
<p>Let's now rewrite our previous example to use custom property names.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id: uid, username: login } = obj;

console.log(uid);    // '1'
console.log(login);  // 'jdoe'
</code></pre>
<p>We are using &quot;uid&quot; and &quot;login&quot; instead of &quot;id&quot; and &quot;username&quot; properties this time.</p>
<h4 id="default-values-1"><a class="header" href="#default-values-1">Default values</a></h4>
<p>When applying property destructuring to the object properties, you can provide default values for missing properties.
That saves time for property checks and reduces coding efforts.</p>
<pre><code class="language-text">let { &lt;variable&gt; : &lt;value&gt; } = &lt;object&gt;
</code></pre>
<p>For example, let's provide a default value for the &quot;id&quot; property and also unpack the property &quot;role&quot;
that does not exist for the given object, and set it to be &quot;guest&quot; by default.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id = 0, role = 'guest' } = obj;

console.log(id);    // '1'
console.log(role);  // 'guest'
</code></pre>
<h4 id="unpacking-methods"><a class="header" href="#unpacking-methods">Unpacking methods</a></h4>
<p>You can extract object methods into separate variables and use them as shortcuts:</p>
<pre><code class="language-js">let { log } = console;
log('hello world');
</code></pre>
<p>The example above demonstrates a &quot;console.log&quot; method being extracted into the &quot;log&quot; variable and used separately.</p>
<p>We utilise the following syntax:</p>
<pre><code class="language-text">let { &lt;method&gt; } = &lt;object&gt;
</code></pre>
<p>Next, let's create a custom class and export multiple methods:</p>
<pre><code class="language-js">// ES6

class MyClass {

  sayHello(message) {
    console.log(`Hello, ${message}`);
  }

  sayBye(message) {
    console.log(`Bye, ${message}`);
  }

}

let myClass = new MyClass();
let { sayHello, sayBye } = myClass;

sayHello('how are you?');  // 'Hello, how are you?'
sayBye('see you soon.');   // 'Bye, see you soon'
</code></pre>
<h4 id="renaming-methods"><a class="header" href="#renaming-methods">Renaming methods</a></h4>
<p>You can also rename destructured methods if needed. The following syntax should be used to give the unpacked method a custom name:</p>
<pre><code class="language-text">let { &lt;method&gt; : &lt;alias&gt; } = &lt;object&gt;
</code></pre>
<p>Let's update the &quot;MyClass&quot; we used earlier and rename &quot;sayHello&quot; and &quot;sayBye&quot; methods to just &quot;hello&quot; and &quot;bye&quot;:</p>
<pre><code class="language-js">let myClass = new MyClass();
let { sayHello: hello, sayBye: bye } = myClass;

hello('how are you?');  // Hello, how are you?
bye('see you soon');    // Bye, see you soon
</code></pre>
<h3 id="using-with-function-parameters"><a class="header" href="#using-with-function-parameters">Using with function parameters</a></h3>
<p>The best scenario for using destructuring with objects and functions is default parameter values and options.</p>
<p>First, let's reproduce the most common use case for the &quot;options&quot; parameter passed to a function or object member:</p>
<pre><code class="language-js">// ES5

function showDialog(options) {
  options = options || {};
  var message = options.message || 'Unknown message';
  var size = options.size || { width: 400, height: 400 };
  var position = options.position || { x: 200, y: 300 };

  console.log('message: ' + message);
  console.log('size: ' + size.width + ':' + size.height);
  console.log('position: ' + position.x + ':' + position.y);
}
</code></pre>
<p>Above is the simplified version of the custom options management that has been very popular for years.
We provide a JavaScript object as an &quot;options&quot; parameter, and function does parsing and detecting missing properties to initialize default values if needed.</p>
<p>Depending on the size of the options object there might be many checks just to set the default values for them.
Especially if there are nested objects with own properties, like &quot;size&quot; and &quot;position&quot; in our case.</p>
<p>Now, if you call the &quot;showDialog&quot; function with no parameters except the &quot;message&quot; value, the output should be similar to the following one:</p>
<pre><code class="language-js">showDialog({ 
    message: 'hello world' 
});

// message: hello world
// size: 400:400
// position: 200:300
</code></pre>
<p>Next, try to call the same function with a partial set of options, for instance, the &quot;size&quot; settings:</p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<p>Now you can rewrite the &quot;showDialog&quot; implementation to use destructuring with default values like in the next example:</p>
<pre><code class="language-js">// ES6

function showDialog({ 
  message = 'Message', 
  size = { width: 400, height: 400 },
  position = { x: 200, y: 300 } }) {

  console.log(`message: ${message}`);
  console.log(`size: ${size.width}:${size.height}`);
  console.log(`position: ${position.x}:${position.y}`);
}
</code></pre>
<p>Notice how we use the destructuring assignment syntax to declare a function parameter. </p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<h4 id="ide-support"><a class="header" href="#ide-support">IDE support</a></h4>
<p>Many modern IDEs already provide support for destructuring syntax within function or method parameters. <a href="https://code.visualstudio.com/">VS Code</a>, for instance, provides auto-completion both for function calls and for nested properties.</p>
<p><img src="images/es6-desctructuring-01.png" alt="" /></p>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Before ES6 developers traditionally were using <code>Revealing Module</code> pattern to emulate modules in JavaScript.</p>
<p>The basic concept of a Revealing Module is that you use <code>closures</code> (self-invoking functions)
with an <code>Object</code> which encapsulates its data and behavior.</p>
<pre><code class="language-js">// ES5
var Module = (function() {
    var privateMethod = function() {
        // do something 
        console.log('private method called');
    };

    return {
        x: 10,
        name: 'some name',
        publicMethod: function() {
            // do something
            console.log('public method called');
            privateMethod();
        }
    };
})();

Module.publicMethod()
</code></pre>
<p>You should get the following output to browser console:</p>
<pre><code class="language-text">public method called
private method called
</code></pre>
<p>I recommend also reading an excellent article &quot;<a href="https://toddmotto.com/mastering-the-module-pattern/">Mastering the Module Pattern</a>&quot; by Todd Motto to get deep coverage of <strong>Revealing Module</strong> pattern in JavaScript.</p>
<p>The rise of module systems based on either AMD or CommonJS syntax has mostly replaced revealing modules and other hand-written solutions in ES5.</p>
<h3 id="exporting-and-importing-values"><a class="header" href="#exporting-and-importing-values">Exporting and Importing Values</a></h3>
<p>ECMAScript 6 provides a long-needed support for exporting and importing values from/to modules without global namespace pollution.</p>
<pre><code class="language-js">// ES6

// module lib/logger.js
export function log (message) { console.log(message); };
export var defaultErrorMessage = 'Aw, Snap!';

//  myApp.js
import * as logger from &quot;lib/logger&quot;;
logger.log(logger.defaultErrorMessage);

//  anotherApp.js
import { log, defaultErrorMessage } from &quot;lib/logger&quot;;
log(defaultErrorMessage);
</code></pre>
<p>Here's how the same approach would look like if written with ECMAScript 5:</p>
<pre><code class="language-js">// ES5

// lib/logger.js
LoggerLib = {};
LoggerLib.log = function(message) { console.log(message); };
LoggerLib.defaultErrorMessage = 'Aw, Snap!';

// myApp.js
var logger = LoggerLib;
logger.log(logger.defaultErrorMessage);

// anotherApp.js
var log = LoggerLib.log;
var defaultErrorMessage = LoggerLib.defaultErrorMessage;
log(defaultErrorMessage);
</code></pre>
<h3 id="default-values-2"><a class="header" href="#default-values-2">Default Values</a></h3>
<p>You can make your ES6 module exporting some value as <code>default</code> one.</p>
<pre><code class="language-js">// ES6

// lib/logger.js
export default (message) =&gt; console.log(message);

// app.js
import output from 'lib/logger';
output('hello world');
</code></pre>
<h3 id="wildcard-export"><a class="header" href="#wildcard-export">Wildcard Export</a></h3>
<p>Another great feature of ES6 modules is support for wildcard-based export of values.
That becomes handy if you are creating a composite module that re-exports values from other modules.</p>
<pre><code class="language-js">// ES6

// lib/complex-module.js
export * from 'lib/logger';
export * from 'lib/http';
export * from 'lib/utils';

// app.js
import { logger, httpClient, stringUtils } from 'lib/complex-module';
logger.log('hello from logger');
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="http://es6-features.org/">ECMAScript 6 â€” New Features: Overview &amp; Comparison</a></li>
</ul>
<h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h2 id="getting-started-with-typescript"><a class="header" href="#getting-started-with-typescript">Getting Started with TypeScript</a></h2>
<h3 id="installing-typescript"><a class="header" href="#installing-typescript">Installing TypeScript</a></h3>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h3 id="using-tsc"><a class="header" href="#using-tsc">Using tsc</a></h3>
<p>In your code editor create a file <code>logger.ts</code> with the following content:</p>
<pre><code class="language-js">function log(message) {
    console.log(message);
}

log('Hello, world!');
</code></pre>
<p>Now you can use a command line to compile your source code to ES5 with <code>tsc</code> tool and run it with <code>node.js</code>:</p>
<pre><code class="language-sh">tsc logger.ts
node logger.js
</code></pre>
<p>TypeScript compiler takes <code>logger.ts</code> file, processes it and produces a JavaScript output to <code>logger.js</code>.
At this point, the <code>.js</code> file is ready to be used with an HTML page or executed by node.js.</p>
<p>You should see the following output in the command line:</p>
<pre><code class="language-text">Hello, world!
</code></pre>
<p>Now let's see how type validation works.
Add <code>string</code> type annotation for the <code>log</code> function and call it with a <code>number</code>.</p>
<pre><code class="language-ts">function log(message: string) {
    console.log(message);
}

log(0);
</code></pre>
<p>If you compile <code>logger.ts</code> once again <code>tsc</code> should produce an error:</p>
<pre><code class="language-sh">tsc logger.ts
&gt; logger.ts(5,5): error TS2345: Argument of type '0' is not assignable to parameter
of type 'string'.
</code></pre>
<h3 id="typings"><a class="header" href="#typings">Typings</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h3 id="linting"><a class="header" href="#linting">Linting</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h4 id="tslint"><a class="header" href="#tslint">TSLint</a></h4>
<blockquote>
<p>TSLint checks your TypeScript code for readability, maintainability, and functionality errors.</p>
</blockquote>
<pre><code class="language-sh">npm install -g tslint
</code></pre>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h2 id="typescript-features"><a class="header" href="#typescript-features">TypeScript Features</a></h2>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/4">todo: Needs introduction</a></em></p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>TypeScript supports all the types used in JavaScript:</p>
<ul>
<li><strong>boolean</strong></li>
<li><strong>number</strong></li>
<li><strong>string</strong></li>
<li><strong>arrays</strong></li>
</ul>
<p>TypeScript also adds the following types:</p>
<ul>
<li><strong>enum</strong></li>
<li><strong>any</strong></li>
<li><strong>void</strong></li>
</ul>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<h4 id="boolean"><a class="header" href="#boolean">Boolean</a></h4>
<p>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a boolean value.</p>
<pre><code class="language-ts">let isEnabled: boolean = true;
</code></pre>
<p>Assigning non-Boolean value to the variable will produce an error.</p>
<pre><code class="language-ts">isEnabled = 'YES';
// logger.ts(2,1): error TS2322: Type '&quot;YES&quot;' is not assignable to type 'boolean'.
</code></pre>
<p>It is also possible annotating function or method return types.</p>
<pre><code class="language-ts">function isEmpty(str: string): boolean {
    return !str;
}
</code></pre>
<h4 id="number"><a class="header" href="#number">Number</a></h4>
<p>TypeScript maps all JavaScript numbers to the <code>number</code> type:</p>
<ul>
<li>floating point numbers (default JavaScript type for all numbers)</li>
<li>decimal numbers</li>
<li>hexadecimal numbers</li>
<li>binary literals (ES6)</li>
<li>octal literals (ES6)</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-ts">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>Typescript supports ES6 <strong>template literals</strong> (formerly known as <strong>template strings</strong>).</p>
<p>As in ECMAScript 6, you use backticks (`) to enclose a string literal and <strong>${}</strong> to interpolate JavaScript variables or arbitrary expressions.</p>
<p>Either double quotes (&quot;) or single quotes (') can be used to surround string data.</p>
<pre><code class="language-ts">let firstName: string = &quot;Joan&quot;;
let lastName: string = 'Doe';
let fullName: string = `${firstName} ${lastName}`;
let template: string = `
    &lt;h1&gt;Title&lt;h1&gt;
    &lt;p&gt;Hello, ${fullName}&lt;/p&gt;
`;
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>There are two main ways you can provide type definition for arrays of values in TypeScript:</p>
<pre><code class="language-ts">let arr1: string[] = [];
let arr2: Array&lt;string&gt; = new Array();
</code></pre>
<p>You can also initialize arrays upon declaring them:</p>
<pre><code class="language-ts">let arr1: string[] = ['hello', 'world'];
let arr2: Array&lt;string&gt; = ['hello', 'world'];

let flags1: boolean[] = [true, false, true, false];
let flags2: boolean[] = new Array(false, true);
</code></pre>
<p>As in JavaScript arrays, you can <strong>push</strong> elements and access them by <strong>index</strong></p>
<pre><code class="language-ts">let users: string[] = [];

users.push('user1');

console.log(`First user: ${users[0]}`);
</code></pre>
<p>The sample above demonstrates array element access together with string interpolation.
When executed it should produce:</p>
<pre><code class="language-text">First user: user1
</code></pre>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<p>TypeScript provides support for an <strong>enumerated type</strong> known in many languages (Swift, C#, Java, C, and others).
This data type consists of a set of named values mapped to numbers.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

let s: Suit = Suit.Spade;
</code></pre>
<p>By default numbering of enum members starts with 0 and increments by one.
You have full control of the values if needed.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };
enum Suit { Club = 1, Diamond = 2, Heart = 4, Spade = 8 }
</code></pre>
<p>Another valuable feature is accessing by a numeric value.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

console.log(Suit[0]); // Club
</code></pre>
<p>It must be noted however that you access names by the numeric values, not by an array index as it may seem.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };

console.log(Suit[0]); // undefined
console.log(Suit[1]); // Club
</code></pre>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p>A special <strong>any</strong> type is used to opt-out of the TypeScript type-checking process and addresses the following cases:</p>
<ul>
<li>dynamic content (objects created on the fly)</li>
<li>3rd party libraries (having no TypeScript support via definition files)</li>
</ul>
<pre><code class="language-ts">let obj: any = {
    log(message) {
        console.log(message);
    }
};
obj.log('hello world');
</code></pre>
<p>Please note that by opting-out of the type-checking process you take full responsibility for safety checks,
as now TypeScript compiler is not able to verify the code at compile time.</p>
<p>The following example shows valid TypeScript code:</p>
<pre><code class="language-ts">obj.log('hello world'); 
obj.helloWorld('log');
</code></pre>
<p>However, at runtime the second line causes a TypeError exception:</p>
<pre><code class="language-text">hello world
TypeError: obj.helloWorld is not a function
</code></pre>
<p>So it is recommended using <strong>any</strong> type only where necessary.</p>
<h3 id="void"><a class="header" href="#void">Void</a></h3>
<p>The <strong>void</strong> type is used to declare a function does not return any value explicitly.</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
        return true;
    }

}
</code></pre>
<p>If you try compiling the code above you should get an error:</p>
<pre><code class="language-text">error TS2322: Type 'true' is not assignable to type 'void'.
</code></pre>
<p>You can fix the type-check error by removing <strong>return</strong> statement from the <strong>log</strong> method:</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
    }

}
</code></pre>
<p>You might also be using <strong>void</strong> types as function parameters or with <strong>Interfaces</strong>:</p>
<pre><code class="language-ts">function fn(x: () =&gt; void) {
  x();
}

interface Logger {

  log(message: string): void;
  warn(message: string): void;
  error(message: string): void;

}
</code></pre>
<p><em>You will get more information on <strong>Interfaces</strong> later in this book.</em></p>
<h2 id="classes-1"><a class="header" href="#classes-1">Classes</a></h2>
<p>TypeScript provides support for classes introduced with ES6 (ECMAScript 2015) and adds a set of features to improve object-oriented development.</p>
<pre><code class="language-ts">class Widget {

    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        console.log(`Rendering widget &quot;${this.id}&quot;`);
    }

}

let widget = new Widget('text1');
widget.render();
</code></pre>
<p>You should get the following output when executed:</p>
<pre><code class="language-text">Rendering widget &quot;text1&quot;
</code></pre>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>With ES6 you define class properties from with the class constructor:</p>
<pre><code class="language-js">// ES6
class Widget {

    constructor(id) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }

}
</code></pre>
<p>If you try compiling example above with <code>tsc</code> utility (TypeScript compiler) you should get the following errors:</p>
<pre><code class="language-text">error TS2339: Property 'id' does not exist on type 'Widget'.
error TS2339: Property 'x' does not exist on type 'Widget'.
error TS2339: Property 'y' does not exist on type 'Widget'.
</code></pre>
<p>The errors are raised because TypeScript requires you to define properties separately.
It is needed to enable many other features TypeScript provides.</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number;
    x: number;

    constructor(id: string) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }
}
</code></pre>
<p>Properties in TypeScript can have default values:</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number = 0;
    x: number = 0;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<h3 id="setters-and-getters"><a class="header" href="#setters-and-getters">Setters and Getters</a></h3>
<p>TypeScript supports <em>computed properties</em>, which do not store a value.
Instead, they provide <em>getters</em> and <em>setters</em> to retrieve and assign values in a controlled way.</p>
<p><strong>TBD</strong>: describe get/set format</p>
<p>One of the common cases for a <em>getter</em> is computing a return value based on other property values:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}

let user = new User('Joan', 'Doe');
console.log(`User full name is: ${user.fullName}`);
</code></pre>
<p>If you save this example to file <code>script.ts</code>, compile it and run like shown below:</p>
<pre><code class="language-sh">tsc --target ES6 script.ts
node script.js
</code></pre>
<p>You should see the output with the full username as expected:</p>
<pre><code class="language-text">User full name is: Joan Doe
</code></pre>
<p>Now let's introduce a simple <em>setter</em> for the <code>firstName</code> property.</p>
<p>Every time a new property value is set we are going to remove leading and trailing white space.
Such values as &quot; Joan&quot; and &quot;Joan  &quot; are automatically converted to &quot;Joan&quot;.</p>
<pre><code class="language-ts">class User {

    private _firstName: string;

    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        if (value) {
            this._firstName = value.trim();
        }
    }
}

let user = new User();
user.firstName = '  Joan   ';
console.log(`The first name is &quot;${user.firstName}&quot;.`);
</code></pre>
<p>The console output, in this case, should be:</p>
<pre><code class="language-text">The first name is &quot;Joan&quot;.
</code></pre>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>Methods are functions that operate on a class object and are bound to an instance of that object.
You can use <code>this</code> keyword to access properties and call other methods like in the example below:</p>
<pre><code class="language-ts">class Sprite {

    x: number;
    y: number;

    render() {
        console.log(`rendering widget at ${this.x}:${this.y}`);
    }
    
    moveTo(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.render();
    }

}

let sprite = new Sprite();
sprite.moveTo(5, 10);
// rendering widget at 5:10
</code></pre>
<h4 id="return-values"><a class="header" href="#return-values">Return values</a></h4>
<pre><code class="language-ts">class NumberWidget {

    getId(): string {
        return 'number1';
    }

    getValue(): number {
        return 10;
    }

}
</code></pre>
<p>You can use a <code>void</code> type if the method does not return any value.</p>
<pre><code class="language-ts">class TextWidget {

    text: string;

    reset(): void {
        this.text = '';
    }

}
</code></pre>
<h4 id="method-parameters"><a class="header" href="#method-parameters">Method parameters</a></h4>
<p>You can add types to each parameter of the method.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level: number) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>TypeScript will automatically perform type checking at compile time.
Let's try providing a string value for the <code>level</code> parameter:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 'not a number');
</code></pre>
<p>You should get a compile error with the following message:</p>
<pre><code class="language-text">error TS2345: Argument of type '&quot;string&quot;' is not assignable to parameter of type 'number'.
</code></pre>
<p>Now let's change <code>level</code> parameter to a number to fix compilation</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 2);
</code></pre>
<p>Now we should get the expected output:</p>
<pre><code class="language-text">(2): test
</code></pre>
<h4 id="optional-parameters"><a class="header" href="#optional-parameters">Optional parameters</a></h4>
<p>By default, all method/function parameters in TypeScript are <code>required</code>.
However, it is possible making parameters optional by appending <strong>?</strong> (question mark) symbol to the parameter name.</p>
<p>Let's update our <code>Logger</code> class and make <code>level</code> parameter optional.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level?: number) {
        if (level === undefined) {
            level = 1;
        }
        console.log(`(${level}): ${message}`);
    }

}

let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The <code>log</code> method provides default value automatically if <code>level</code> is omitted.</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<p>Please note that optional parameters must always follow required ones.</p>
<h4 id="default-parameters"><a class="header" href="#default-parameters">Default parameters</a></h4>
<p>TypeScript also supports default values for parameters.
Instead of checking every parameter for <code>undefined</code> value you can provide defaults directly within the method declaration:</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string = 'Unknown error', level: number = 1) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>Let's try calling <code>log</code> without any parameters:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The output, in this case, should be:</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<h4 id="rest-parameters-and-spread-operator"><a class="header" href="#rest-parameters-and-spread-operator">Rest Parameters and Spread Operator</a></h4>
<p>In TypeScript, you can gather multiple arguments into a single variable known as <em>rest parameter</em>.
Rest parameters were introduced as part of ES6, and TypesScripts extends them with type checking support.</p>
<pre><code class="language-ts">class Logger {

    showErrors(...errors: string[]) {
        for (let err of errors) {
            console.error(err);
        }
    }

}
</code></pre>
<p>Now you can provide an arbitrary number of arguments for <code>showErrors</code> method:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.showErrors('Something', 'went', 'wrong');
</code></pre>
<p>That should produce three errors as an output:</p>
<pre><code class="language-text">Something
went
wrong
</code></pre>
<p><em>Rest parameters</em> in TypeScript work great with <em>Spread Operator</em> allowing you to expand a collection into multiple arguments.
It is also possible mixing regular parameters with <em>spread</em> ones:</p>
<pre><code class="language-ts">let logger = new Logger();
let messages = ['something', 'went', 'wrong'];

logger.showErrors('Error', ...messages, '!');
</code></pre>
<p>In the example above we compose a collection of arguments from arbitrary parameters and content of the <code>messages</code> array in the middle.</p>
<p>The <code>showErrors</code> method should handle all entries correctly and produce the following output:</p>
<pre><code class="language-text">Error
something
went
wrong
!
</code></pre>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Constructors in TypeScript got same features as methods.
You can have default and optional parameters, use rest parameters and spread operators with class constructor functions.</p>
<p>Besides, TypeScript provides support for automatic property creation based on constructor parameters.
Let's create a typical <code>User</code> class implementation:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}
</code></pre>
<p>Instead of assigning parameter values to the corresponding properties we can instruct TypeScript to perform an automatic assignment instead.
You can do that by putting one of the access modifiers <strong>public</strong>, <strong>private</strong> or <strong>protected</strong> before the parameter name.</p>
<p>You are going to get more details on <em>access modifiers</em> later in this book.
For now, let's see the updated <code>User</code> class using automatic property assignment:</p>
<pre><code class="language-ts">class User {

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(public firstName: string, public lastName: string) {
    }

}

let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<p>TypeScript creates <code>firstName</code> and <code>lastName</code> properties when generating JavaScript output.
You need targeting at least ES5 to use this feature.</p>
<p>Save example above to file <code>script.ts</code> then compile and run with <code>node</code>:</p>
<pre><code class="language-sh">tsc script.ts --target ES5
node script.js
</code></pre>
<p>The output should be as following:</p>
<pre><code class="language-text">Full name is: Joan Doe
</code></pre>
<p>You have not defined properties explicitly, but <code>fullName</code> getter was still able accessing them via <code>this</code>.
If you take a look at the emitted JavaScript you should see the properties are defined there as expected:</p>
<pre><code class="language-js">// ES5
var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    Object.defineProperty(User.prototype, &quot;fullName&quot;, {
        get: function () {
            return (this.firstName + &quot; &quot; + this.lastName).trim();
        },
        enumerable: true,
        configurable: true
    });
    return User;
}());
var user = new User('Joan', 'Doe');
console.log(&quot;Full name is: &quot; + user.fullName);
</code></pre>
<p>Now you can also switch to ES6 target to see how TypeScript assigns properties:</p>
<pre><code class="language-sh">tsc script.ts --target ES6
</code></pre>
<p>The generated JavaScript, in this case, is even smaller and cleaner:</p>
<pre><code class="language-js">// ES6
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName() {
        return `${this.firstName} ${this.lastName}`.trim();
    }
}
let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<h3 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h3>
<p>One of the important TypeScript features is the class inheritance that enables OOP patterns for developers.
Under the hood TypeScript is using the same <code>extends</code> syntactic sugar when targeting ES6 JavaScript,
and prototypical inheritance wrappers when generating output in ES5.</p>
<p>We can refer to animals as a classic example of class-based programming and inheritance.</p>
<pre><code class="language-ts">class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    makeSound() {
        console.log('Unknown sound');
    }
}
</code></pre>
<p>You have created a basic <code>Animal</code> class that contains a <code>name</code> property and <code>makeSound</code> method.
That translates to ES5 as following:</p>
<pre><code class="language-js">// ES5
var Animal = (function () {
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.makeSound = function () {
        console.log('Unknown sound');
    };
    return Animal;
}());
</code></pre>
<p>Now you can create a <code>Dog</code> implementation that provides a right sound:</p>
<pre><code class="language-ts">class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Woof-woof');
    }
}
</code></pre>
<p>Please note that if you have a constructor in the base class, then you must call it from all derived classes.
Otherwise, TypeScript should raise a compile-time error:</p>
<pre><code class="language-text">error TS2377: Constructors for derived classes must contain a 'super' call.
</code></pre>
<p>Here's how a <code>Dog</code> gets converted to ES5:</p>
<pre><code class="language-ts">var Dog = (function (_super) {
    __extends(Dog, _super);
    function Dog(name) {
        return _super.call(this, name) || this;
    }
    Dog.prototype.makeSound = function () {
        console.log('Woof-woof');
    };
    return Dog;
}(Animal));
</code></pre>
<p>Now let's add a <code>Cat</code> implementation with its sound and test both classes:</p>
<pre><code class="language-ts">class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Meow');
    }
}

let dog = new Dog('Spot');
let cat = new Cat('Tom');

dog.makeSound();
cat.makeSound();
</code></pre>
<p>Once the code compiles and executes you should get the following output:</p>
<pre><code class="language-text">Woof-woof
Meow
</code></pre>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>TypeScript supports <code>public</code>, <code>private</code> and <code>protected</code> modifiers for defining accessibility of the class members.</p>
<h4 id="public"><a class="header" href="#public">Public</a></h4>
<p>By default, each member of the class is <code>public</code> so that you can omit it.
However, nothing stops you from declaring <code>public</code> modifier explicitly if needed:</p>
<pre><code class="language-ts">class User {
    public firstName: string;
    public lastName: string;

    public speak() {
        console.log('Hello');
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre>
<p>Now if you compile example above to JavaScript you should see the following:</p>
<pre><code class="language-js">var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    User.prototype.speak = function () {
        console.log('Hello');
    };
    return User;
}());
</code></pre>
<h4 id="private"><a class="header" href="#private">Private</a></h4>
<p>You mark a member as <code>private</code> when it should never be accessed from outside of its containing class.
One of the most common scenarios is creating private fields to hold values for properties.
For example:</p>
<pre><code class="language-ts">class User {
    private _firstName: string;
    private _lastName: string;

    get firstName() {
        return this._firstName;
    }

    get lastName() {
        return this._lastName;
    }

    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
}
</code></pre>
<p>The class we have created above allows setting user's first and last name only from within the constructor.</p>
<p>If you try changing name properties from outside the class, TypeScript will raise an error at compile time:</p>
<pre><code class="language-ts">let user = new User('John', 'Doe');
user.firstName = 'Rob';
// error TS2540: Cannot assign to 'firstName' because it is a constant or a read-only property.
</code></pre>
<h4 id="protected"><a class="header" href="#protected">Protected</a></h4>
<p>The <code>protected</code> modifier restricts member visibility from outside of the containing class but provides access from the derived classes.</p>
<p>Let's start with base <code>Page</code> class implementation:</p>
<pre><code class="language-ts">class Page {

    protected renderHeader()    { /* ... */ }
    protected renderContent()   { /* ... */ }
    protected renderFooter()    { /* ... */ }

    render() {
        this.renderHeader();
        this.renderContent();        
        this.renderFooter();
    }
}
</code></pre>
<p>We created a <code>Page</code> class that has public method <code>render</code>.
Internally <code>render</code> calls three separate methods to render header, content and footer of the page.
These methods are not available from the outside the the class.</p>
<p>Now we are going to create a simple derived <code>AboutPage</code> class:</p>
<pre><code class="language-ts">class AboutPage extends Page {

    private renderAboutContent() { /* ... */ }

    render() {
        this.renderHeader();
        this.renderAboutContent();
        this.renderFooter();
    }

}
</code></pre>
<p>As you can see the <code>AboutPage</code> defines its <code>render</code> method that calls
<code>renderHeader</code> and <code>renderFooter</code> in parent class but puts custom content in the middle.</p>
<p>You can also use <code>protected</code> modifier with class constructors.
In this case, the class can be instantiated only by the derived classes that extend it.
That becomes handy when you want to have properties and methods available for multiple classes as a base implementation,
but don't want a base class to be instantiated outside its containing class.</p>
<p>For example</p>
<pre><code class="language-ts">class Page {
    protected constructor(id: string) {
        // ...
    }

    render() { /* base render */ }
}

class MainPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render main page */ }
}

class AboutPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render about page */ }
}

let main = new MainPage('main');
let about = new AboutPage('about');
</code></pre>
<p>You can create instances of <code>MainPage</code> and <code>AboutPage</code> both having access to protected members of the <code>Page</code> class.
However, you are not able creating an instance of the <code>Page</code> class directly.</p>
<pre><code class="language-ts">let page = new Page(); 
// error TS2674: Constructor of class 'Page' is protected and only accessible within the class declaration.
</code></pre>
<h3 id="readonly-modifier"><a class="header" href="#readonly-modifier">Readonly modifier</a></h3>
<p>One of the common ways to create a read-only property in many object-oriented programming languages
is by having a private local variable with a <code>getter</code> only.</p>
<pre><code class="language-ts">class Widget {

    private _id: string;

    get id(): string {
        return this._id;
    }

    constructor(id: string) {
        this._id = id;
    }
}

let widget = new Widget('textBox');
console.log(`Widget id: ${widget.id}`);
// Widget id: textBox
</code></pre>
<p>You can also make properties read-only by using the <code>readonly</code> keyword.
That reduces repetitive typing when dealing with many read-only properties, and greatly improves overall code readability.</p>
<p>Let's update the previous example to use <code>readonly</code>:</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<p>If you try changing the value of the property outside of the constructor TypeScript will raise an error:</p>
<pre><code class="language-ts">let widget = new Widget('text');
widget.id = 'newId';
// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p>You can provide default values for read-only properties only in two places: property declaration and constructor.</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;
    readonly minWidth: number = 200;
    readonly minHeight: number = 100;

    constructor(id: string) {
        this.id = id;
    }
}

let widget = new Widget('text');
widget.minWidth = 1000;
// error TS2540: Cannot assign to 'minWidth' because it is a constant or a read-only property.
</code></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>An <em>interface</em> is a description of the actions that an object can do.</p>
<p>You might already be familiar with <em>interfaces</em> in other programming languages like C# and Java,
or <em>contracts</em> in Swift.</p>
<p>Interfaces are not part of the ECMAScript.
It is a level of abstraction supported by TypeScript to improve the type-checking process, and not converted to JavaScript code.</p>
<p>Here's an example of an interface describing generic <strong>Text</strong> component:</p>
<pre><code class="language-ts">interface TextComponent {

    text: string;
    render(): void;

}
</code></pre>
<p>Now you can use the interface above to describe the requirement of having the <strong>text</strong> property that is a string and a <strong>render</strong> method:</p>
<pre><code class="language-ts">class PlainTextComponent implements TextComponent {

    text: string;

    render() {
        console.log('rendering plain text component');
    }

}
</code></pre>
<p>We are using <code>implements</code> keyword to wire class with a particular interface.
It is not important in what order class members are defined as long as all properties and methods the interface requires
are present and have required types.</p>
<p>Let's create another class that implements <code>TextComponent</code> interface partially:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent {
    text: string;
}
</code></pre>
<p>Upon compilation TypeScript will produce the following error:</p>
<pre><code class="language-text">error TS2420: Class 'RichTextComponent' incorrectly implements interface 'TextComponent'.
Property 'render' is missing in type 'RichTextComponent'.
</code></pre>
<p>You can use multiple interfaces delimited by a comma:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent, OnInit, OnDestroy {
    // ...
}
</code></pre>
<p>The example above shows a class that must implement three different interfaces to compile.</p>
<h2 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h2>
<p>Interfaces describe only requirements for classes; you cannot create an instance of the interface.
You need <code>abstract</code> classes un order to provide implementation details.</p>
<pre><code class="language-ts">abstract class PageComponent {

    abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Same as with interfaces you cannot create instances of abstract classes directly, only other classes derived from an abstract one.
Also, it is possible marking class methods as <code>abstract</code>.
Abstract methods do not contain implementation, and similar to <code>interface</code> methods provide requirements for derived classes.</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Note how <code>HomePageComponent</code> implements abstract <code>renderContent</code> that has access to <code>renderHeader</code> and <code>renderFooter</code> methods carried out in the parent class.</p>
<p>You can also use access modifiers with abstract methods.
The most frequent scenario is when methods need to be accessible only from within the child classes, and invisible from the outside:</p>
<p>For example:</p>
<pre><code class="language-ts">abstract class PageComponent {

    protected abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Now <code>HomePageComponent</code> can make <code>renderContent</code> protected like shown below:</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    constructor() {
        super();
        this.renderContent();
    }

    protected renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Any additional class that inherits (extends) <code>HomePageComponent</code> will still be able calling or redefining <code>renderContent</code> method.
But if you try accessing <code>renderContent</code> from outside the TypeScript should raise the following error:</p>
<pre><code class="language-ts">let homePage = new HomePageComponent();
homePage.renderContent();
// error TS2445: Property 'renderContent' is protected and only 
// accessible within class 'HomePageComponent' and its subclasses.
</code></pre>
<p>Abstract classes is a great way consolidating common functionality in a single place.</p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<p>TypeScript supports the concept of modules introduced in ES6.
Modules allow isolating code and data and help splitting functionality into logical groups.</p>
<p>One of the major features of ES6 (and TypeScript) modules is their file scope.
The code inside the module (classes, variables, functions, and other) does not pollute global scope
and is not accessible from the outside unless <code>exported</code> explicitly.</p>
<p>To share the code of the module with the outside world, you use <code>export</code> keyword:</p>
<pre><code class="language-ts">// module1.ts
export class TextBoxComponent {
  constructor(public text: string) {}
    
  render() {
    console.log(`Rendering '${this.text}' value.`);
  }
}
</code></pre>
<p>To use this code in your main application file or another module, you must import it first.
You import the <code>TextBoxComponent</code> class using <code>import</code> keyword:</p>
<pre><code class="language-ts">// app.ts
import { TextBoxComponent } from './module1'

let textBox = new TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="module-loaders"><a class="header" href="#module-loaders">Module Loaders</a></h3>
<p>ES6 and TypeScript rely on <code>module loaders</code> to locate files, resolve external dependencies and execute module files.</p>
<p>The most popular module loaders are:</p>
<ul>
<li>Server side
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used by Node.js)</li>
</ul>
</li>
<li>Client side
<ul>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li><a href="https://webpack.js.org/">Webpack</a></li>
</ul>
</li>
</ul>
<p>TypeScript supports different formats of generated JavaScript output.
You can instruct compiler to generate code adopted for multiple module loading systems using formats such as</p>
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used in Node.js)</li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li>UMD (Universal Module Definition)</li>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li>ES6 (or ECMAScript 2015)</li>
</ul>
<h3 id="running-at-server-side"><a class="header" href="#running-at-server-side">Running at server side</a></h3>
<p>You can test <code>TextBoxComponent</code> we have created earlier with node.js using <code>commonjs</code> module target:</p>
<pre><code class="language-sh">tsc app.ts --module commonjs
node app.js
</code></pre>
<p>When executed it produces the following output:</p>
<pre><code class="language-text">Rendering 'hello world' value.
</code></pre>
<p>TypeScript automatically compiles referenced modules.
It starts with <code>app.ts</code>, resolves and compiles <code>module1</code> as <code>module1.ts</code> file,
and produces two JavaScript files <code>app.js</code> and <code>module.js</code> that can be executed by node.js.</p>
<p>Here's an example of <code>app.js</code> file content:</p>
<pre><code class="language-js">&quot;use strict&quot;;
// app.ts
var module1_1 = require(&quot;./module1&quot;);
var textBox = new module1_1.TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="running-in-browser"><a class="header" href="#running-in-browser">Running in browser</a></h3>
<p>In order to run module-based application in browser you can take <code>SystemJS</code> loader:</p>
<pre><code class="language-html">&lt;script src=&quot;systemjs/dist/system.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  SystemJS.import('/app/app.js');
&lt;/script&gt;
</code></pre>
<p>Let's take a look at a simple TypeScript application that references an external module.</p>
<pre><code class="language-ts">// logger.ts
export class Logger {

  output: any;

  constructor(outputId: string) {
    this.output = document.getElementById(outputId);
  }

  info(message: string) {
    this.output.innerText = `INFO: ${message}`;
  }

}
</code></pre>
<p>Our simple <code>logger</code> is going to put a message as a content of the document element provided from the outside.</p>
<pre><code class="language-ts">// app.ts
import { Logger } from './logger';

let logger = new Logger('content');
logger.info('hello world');
</code></pre>
<p>The application needs to be compiled with SystemJS support to load correctly.
You can configure TypeScript to generate compatible JavaScript code by setting module code generation setting to <code>system</code>:</p>
<pre><code class="language-sh">tsc app.ts --module system
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find source code for the examples above in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/typescript/systemjs-example">typescript/systemjs-example</a>&quot; folder.</p>
</blockquote>
<p>To install dependencies, compile and run the demo use the following commands:</p>
<pre><code class="language-sh">npm install
npm start
</code></pre>
<p>Your default browser should run example page automatically.
Once the page gets loaded you should see an expected message:</p>
<pre><code class="language-text">INFO: hello world
</code></pre>
<h2 id="decorators"><a class="header" href="#decorators">Decorators</a></h2>
<p>TypeScript introduces <code>decorators</code> feature, metadata expressions similar to Java annotation tags or C# and Swift attributes.
ECMAScript does not yet have native support for annotating classes and class members (the feature is in the <code>proposal</code> state),
so <code>decorators</code> is an experimental TypeScript feature.</p>
<p>Decorators have a traditional notation of <code>@expression</code> where <code>expression</code> is the name of the function that should be invoked at runtime.</p>
<p>This function receives <code>decorated</code> target as a parameter and can be attached to:</p>
<ul>
<li>class declaration</li>
<li>method</li>
<li>accessor</li>
<li>property</li>
<li>parameter</li>
</ul>
<h3 id="class-decorators"><a class="header" href="#class-decorators">Class Decorators</a></h3>
<p>Class decorators are attached to class declarations.
At runtime, the function that backs the decorator gets applied to the class constructor.
That allows decorators inspecting, modifying or even replacing class instances if needed.</p>
<p>Here's a simple example of the <code>LogClass</code> decorator that outputs some log information every time being invoked:</p>
<pre><code class="language-ts">function LogClass(constructor: Function) {
    console.log('LogClass decorator executed for the constructor:');
    console.log(constructor);
}
</code></pre>
<p>Now you can use newly created decorator with different classes:</p>
<pre><code class="language-ts">@LogClass
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}
</code></pre>
<p>When a new instance of <code>TextWidget</code> class is created, the <code>@LogClass</code> attribute will be automatically invoked:</p>
<pre><code class="language-ts">let widget = new TextWidget();
widget.render();
</code></pre>
<p>The class decorator should produce the following output:</p>
<pre><code class="language-text">LogClass decorator executed for the constructor:
[Function: TextWidget]
Rendering text: default text
</code></pre>
<h4 id="decorators-with-parameters"><a class="header" href="#decorators-with-parameters">Decorators with parameters</a></h4>
<p>It is also possible passing values to decorators. You can achieve this with a feature known as <code>decorator factories</code>.
A <em>decorator factory</em> is a function returning an expression that is called at runtime:</p>
<p>Let's create another simple decorator with log output that accepts additional <code>prefix</code> and <code>suffix</code> settings:</p>
<pre><code class="language-ts">function LogClassWithParams(prefix: string, suffix: string) {
    return (constructor: Function) =&gt; {
        console.log(`
            ${prefix} 
            LogClassWithParams decorator called for: 
            ${constructor} 
            ${suffix}
        `);
    };
}
</code></pre>
<p>It can now be tested with the <code>TextWidget</code> class created earlier:</p>
<pre><code class="language-ts">@LogClassWithParams('BEGIN:', ':END')
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>You have marked <code>TextWidget</code> class with the <code>LogClassWithParams</code> decorator having a <code>prefix</code> and <code>suffix</code> properties
set to <code>BEGIN:</code> and <code>:END</code> values. The console output, in this case, should be:</p>
<pre><code class="language-text">BEGIN:
LogClassWithParams decorator called for: 
function TextWidget(text) {
    if (text === void 0) { text = 'default text'; }
        this.text = text;
    }
}
:END
</code></pre>
<h4 id="multiple-decorators"><a class="header" href="#multiple-decorators">Multiple decorators</a></h4>
<p>You are not limited to a single decorator per class.
TypeScript allows declaring as much class and member decorators as needed:</p>
<pre><code class="language-ts">@LogClass
@LogClassWithParams('BEGIN:', ':END')
@LogClassWithParams('[', ']')
class TextWidget {
    // ...
}
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
It means that first decorator that gets executed is:</p>
<pre><code class="language-ts">@LogClassWithParams('[', ']')
</code></pre>
<p>and the last decorator is going to be</p>
<pre><code class="language-ts">@LogClass
</code></pre>
<h3 id="method-decorators"><a class="header" href="#method-decorators">Method Decorators</a></h3>
<p>Method decorators are attached to class methods and can be used to inspect, modify or completely replace method definition of the class.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Let's create a decorator to inspect those parameters:</p>
<pre><code class="language-ts">function LogMethod(target: any, 
                   propertyKey: string, 
                   descriptor: PropertyDescriptor) {
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Below is an example of this decorator applied to a <code>render</code> method of <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethod
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>The console output in this case will be as following:</p>
<pre><code class="language-text">TextWidget { render: [Function] }
render
{ value: [Function],
  writable: true,
  enumerable: true,
  configurable: true }
Rendering text: default text
</code></pre>
<p>You can use <code>decorator factories</code> also with method decorators to support additional parameters.</p>
<pre><code class="language-ts">function LogMethodWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`${propertyKey}: ${message}`);
    };
}
</code></pre>
<p>This decorator can now be applied to methods. You can attach multiple decorators to a single method:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethodWithParams('hello')
    @LogMethodWithParams('world')
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
If you run the code the output should be as follows:</p>
<pre><code class="language-text">render: world
render: hello
Rendering text: default text
</code></pre>
<h3 id="accessor-decorators"><a class="header" href="#accessor-decorators">Accessor Decorators</a></h3>
<p>Accessor decorators are attached to property <code>getters</code> or <code>setters</code> and can be used to inspect, modify or completely replace accessor definition of the property.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Note that you can attach accessor decorator to either <code>getter</code> or <code>setter</code> but not both.
This restriction exists because on the low level decorators deal with
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Property Descriptors</a>
that contain both <code>get</code> and <code>set</code> accessors.</p>
<p>Let's create a decorator to inspect parameters:</p>
<pre><code class="language-ts">function LogAccessor(target: any, 
                     propertyKey: string, 
                     descriptor: PropertyDescriptor) {
    console.log('LogAccessor decorator called');
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Now the decorator can be applied to the following <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessor
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>Once invoked the decorator should produce the following output:</p>
<pre><code class="language-text">LogAccessor decorator called
TextWidget { text: [Getter/Setter] }
text
{ get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true }
</code></pre>
<p>Same as with class and method decorators you can use decorator factories feature to pass parameters to your accessor decorator.</p>
<pre><code class="language-ts">function LogAccessorWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`Message from decorator: ${message}`);
    }
}
</code></pre>
<p>TypeScript allows using more than one decorator given you attach it to the same property accessor:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    @LogAccessorWithParams('world')
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>The console output should be as shown below, note the right-to-left execution order:</p>
<pre><code class="language-text">Message from decorator: world
Message from decorator: hello
</code></pre>
<p>In case you declare decorator for both accessors TypeScript generates an error at compile time:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    get text(): string {
        return this._text;
    }
    
    @LogAccessorWithParams('world')
    set text(value: string) {
        this._text = value;
    }
}
</code></pre>
<pre><code class="language-text">error TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.
</code></pre>
<h3 id="property-decorators"><a class="header" href="#property-decorators">Property Decorators</a></h3>
<p>Property decorators are attached to class properties.
At runtime, property decorator receives the following arguments:</p>
<ul>
<li>target object</li>
<li>property name</li>
</ul>
<p>Due to technical limitations, it is not currently possible observing or modifying property initializers.
That is why property decorators do not get Property Descriptor value at runtime
and can be used mainly to observe a property with a particular name has been defined for a class.</p>
<p>Here's a simple property decorator to display parameters it gets at runtime:</p>
<pre><code class="language-ts">function LogProperty(target: any, propertyKey: string) {
    console.log('LogProperty decorator called');
    console.log(target);
    console.log(propertyKey);
}
</code></pre>
<pre><code class="language-ts">class TextWidget {

    @LogProperty
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        // ...
    }
}

let widget = new TextWidget('text1');
</code></pre>
<p>The output in this case should be as following:</p>
<pre><code class="language-text">LogProperty decorator called
TextWidget { render: [Function] }
id
</code></pre>
<h3 id="parameter-decorators"><a class="header" href="#parameter-decorators">Parameter Decorators</a></h3>
<p>Parameter decorators are attached to function parameters.
At runtime, every parameter decorator function is called with the following arguments:</p>
<ul>
<li>target</li>
<li>parameter name</li>
<li>parameter position index</li>
</ul>
<p>Due to technical limitations, it is possible only detecting that a particular parameter has been declared on a function.</p>
<p>Let's inspect runtime arguments with this simple parameter decorator:</p>
<pre><code class="language-ts">function LogParameter(target: any, 
                      parameterName: string, 
                      parameterIndex: number) {
    console.log('LogParameter decorator called');
    console.log(target);
    console.log(parameterName);
    console.log(parameterIndex);
}
</code></pre>
<p>You can now use this decorator with a class constructor and method parameters:</p>
<pre><code class="language-ts">class TextWidget {

    render(@LogParameter positionX: number, 
           @LogParameter positionY: number) {
        // ...
    }

}
</code></pre>
<p>Parameter decorators are also executed in right-to-left order.
So you should see console outputs for <code>positionY</code> and then <code>positionX</code>:</p>
<pre><code class="language-text">LogParameter decorator called
TextWidget { render: [Function] }
render
1
LogParameter decorator called
TextWidget { render: [Function] }
render
0
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-23X2CQXZ48', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
