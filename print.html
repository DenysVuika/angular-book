<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Angular Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Angular Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="ch01-02-vscode.html"><strong aria-hidden="true">1.2.</strong> Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-es6.html"><strong aria-hidden="true">2.</strong> ES6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-classes.html"><strong aria-hidden="true">2.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch02-02-inheritance.html"><strong aria-hidden="true">2.2.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="ch02-03-arrow-functions.html"><strong aria-hidden="true">2.3.</strong> Arrow Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-template-literals.html"><strong aria-hidden="true">2.4.</strong> Template Literals</a></li><li class="chapter-item expanded "><a href="ch02-05-extended-parameters.html"><strong aria-hidden="true">2.5.</strong> Extended Parameter Handling</a></li><li class="chapter-item expanded "><a href="ch02-06-destructuring.html"><strong aria-hidden="true">2.6.</strong> Destructuring Assignment</a></li><li class="chapter-item expanded "><a href="ch02-07-modules.html"><strong aria-hidden="true">2.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch02-08-see-also.html"><strong aria-hidden="true">2.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-typescript.html"><strong aria-hidden="true">3.</strong> TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch03-02-features.html"><strong aria-hidden="true">3.2.</strong> TypeScript Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-03-types.html"><strong aria-hidden="true">3.2.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="ch03-04-classes.html"><strong aria-hidden="true">3.2.2.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch03-05-interfaces.html"><strong aria-hidden="true">3.2.3.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch03-06-abstract-classes.html"><strong aria-hidden="true">3.2.4.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="ch03-07-modules.html"><strong aria-hidden="true">3.2.5.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch03-08-decorators.html"><strong aria-hidden="true">3.2.6.</strong> Decorators</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-angular-cli.html"><strong aria-hidden="true">4.</strong> Angular CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-installing.html"><strong aria-hidden="true">4.1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="ch04-02-first-application.html"><strong aria-hidden="true">4.2.</strong> Your First Application</a></li><li class="chapter-item expanded "><a href="ch04-03-running-application.html"><strong aria-hidden="true">4.3.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="ch04-04-linting.html"><strong aria-hidden="true">4.4.</strong> Code Linting</a></li><li class="chapter-item expanded "><a href="ch04-05-testing.html"><strong aria-hidden="true">4.5.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="ch04-06-coverage.html"><strong aria-hidden="true">4.6.</strong> Code Coverage</a></li><li class="chapter-item expanded "><a href="ch04-07-development-and-production-builds.html"><strong aria-hidden="true">4.7.</strong> Development and Production Builds</a></li><li class="chapter-item expanded "><a href="ch04-08-using-blueprints.html"><strong aria-hidden="true">4.8.</strong> Using Blueprints</a></li><li class="chapter-item expanded "><a href="ch04-09-creating-modules.html"><strong aria-hidden="true">4.9.</strong> Creating Modules</a></li><li class="chapter-item expanded "><a href="ch04-10-routing-support.html"><strong aria-hidden="true">4.10.</strong> Routing Support</a></li><li class="chapter-item expanded "><a href="ch04-11-generating-standalone-scripts.html"><strong aria-hidden="true">4.11.</strong> Generating Standalone Scripts</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Components</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> Creating a simple component</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.2.</strong> Generating components with Angular CLI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.3.</strong> Component metadata</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.4.</strong> Templates</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.5.</strong> Styles</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.6.</strong> Output events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.7.</strong> Providers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.8.</strong> Host</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.9.</strong> Queries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.10.</strong> Content Projection</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Dependency Injection</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.1.</strong> Preparing a project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.2.</strong> Services</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.3.</strong> Providers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.4.</strong> Injecting multiple instances</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.5.</strong> Optional dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.6.</strong> Manual injection with ReflectiveInjector</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.7.</strong> Summary</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.1.</strong> Component events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.2.</strong> DOM events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.3.</strong> Service events</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Directives</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.1.</strong> Introduction to Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.2.</strong> Attribute Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.3.</strong> Structural Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.4.</strong> Modifying host element layout</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Walkthrough: Upload Directive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Pipes</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.</strong> Introduction to Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.2.</strong> Pipes with Parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.3.</strong> Chaining Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.4.</strong> Built-in Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.5.</strong> Custom Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.6.</strong> Pure And Impure Pipes</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Global Application Configuration</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.1.</strong> Preparing the configuration file</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.2.</strong> Creating the configuration service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.3.</strong> Loading server-side configuration file</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.4.</strong> Registering configuration service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.5.</strong> Using configuration settings</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Internationalisation (i18n)</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.1.</strong> Creating Translate Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.2.</strong> Creating Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.3.</strong> Using Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.4.</strong> Switching languages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.5.</strong> Summary</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Reusable Component Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Creating new application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Creating component libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Building the packages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Publishing to NPM</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Advanced Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Dynamic Content in Angular</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Using with Docker</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Additional Resources</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Preparing new project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Creating Dockerfile</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Testing in a container</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> Creating docker-compose.yml</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.6.</strong> Consuming from Docker Hub</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.7.</strong> Automating with Travis</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.8.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Webpack</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Initial project structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Typescript configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Basic webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Advanced webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Unit testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Building a Mobile App with Cordova and Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Installing command-line tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Generating a new Angular App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Summary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Angular Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/DenysVuika/angular-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-angular-book"><a class="header" href="#the-angular-book">The Angular Book</a></h1>
<p><em>by Denys Vuika, with contributions from the Angular Community</em></p>
<p>This is the second and online edition of the <a href="https://leanpub.com/developing-with-angular">Developing with Angular</a> book.</p>
<blockquote>
<p>Note: this book is still in progress.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In the first few chapters, we are going to dwell on the basics you may need to understand Angular development better later on.</p>
<p>We are going to start with the main ES6 (ECMAScript 2015) features you should come across frequently when using TypeScript.</p>
<p>Next, the most remarkable TypeScript features you should get familiar before starting the Angular development.</p>
<p>After that, we are covering the Angular framework and supplemental toolings, like Angular CLI (Command Line Interface) and Webpack.</p>
<p>Finally, you should expect many practical topics that are addressing specific application requirements and scenarios,
including those coming from the community requests.</p>
<h2 id="book-progress"><a class="header" href="#book-progress">Book progress</a></h2>
<p>You can see the progress of the writing on this <a href="https://github.com/DenysVuika/angular-book/projects/1">GitHub board</a>.
Be sure to check the board if you want to see what's coming next or what is in progress right now.</p>
<h2 id="code-examples"><a class="header" href="#code-examples">Code examples</a></h2>
<p>You can find all code examples in this GitHub repository: <a href="https://github.com/DenysVuika/angular-book">angular-book</a>.
The source code gets frequently revisited and updated.</p>
<h2 id="feedback-bug-reports-and-suggestions"><a class="header" href="#feedback-bug-reports-and-suggestions">Feedback, Bug Reports and Suggestions</a></h2>
<p>If you have noticed a typo in the text or a bug in the code examples,
please don't hesitate and contact me using the next email address:
<a href="mailto:denys.vuika@gmail.com?subject=angular-book%20feedback">denys.vuika@gmail.com</a></p>
<p>You are also invited to raise issues for the source code and examples using corresponding <a href="https://github.com/DenysVuika/angular-book/issues">issue tracker</a> at GitHub.</p>
<p>Feel free to raise feature requests and suggestions on what you would like to see next.</p>
<h2 id="other-publications"><a class="header" href="#other-publications">Other publications</a></h2>
<p>You can find many other interesting publications at my <a href="https://denys.dev/">Blog</a>.</p>
<h2 id="testimonials"><a class="header" href="#testimonials">Testimonials</a></h2>
<p>Your feedback on the book content is very appreciated.
I would love to publish your photo and testimonial on the web page of the book.
Email me at: <a href="mailto:denys.vuika@gmail.com?subject=angular-book%20testimonial">denys.vuika@gmail.com</a>.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>In this chapter, we are going to configure the following applications and libraries:</p>
<ul>
<li>Node.js</li>
<li>Visual Studio Code</li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<p>Node.js is a JavaScript runtime built on <a href="https://developers.google.com/v8/">Chrome's V8 JavaScript engine</a>.
Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
Node.js' package ecosystem, <a href="https://www.npmjs.com/">npm</a>, is the largest ecosystem of open source libraries in the world.</p>
<p>Navigate to the <a href="https://nodejs.org/en/">main page</a>, download installer for your platform and follow setup instructions.</p>
<p>You can use the following commands to test current versions of the Node and NPM on your machine:</p>
<pre><code class="language-sh">node -v
# v14.16.0

npm -v
# 6.14.11
</code></pre>
<p>Please note that the actual versions may differ.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS.
It includes support for debugging, embedded Git control, syntax highlighting,
intelligent code completion, snippets, and code refactoring.</p>
<p><img src="images/vscode-mac-lg-2x.png" alt="vs code" /></p>
<h3 id="recommended-extensions"><a class="header" href="#recommended-extensions">Recommended extensions</a></h3>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint">TSLint</a></strong></p>
<p>Integrates the tslint linter for the TypeScript language into VS Code.</p>
<p>Launch VS Code Quick Open (âŒ˜+P), paste the following command, and press enter.</p>
<pre><code class="language-sh">ext install tslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></strong></p>
<p>Integrates ESLint into VS Code. See <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">project page</a> for more details.</p>
<pre><code class="language-sh">ext install vscode-eslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig</a></strong></p>
<p>EditorConfig Support for Visual Studio Code</p>
<pre><code class="language-sh">ext install EditorConfig
</code></pre>
<h3 id="hiding-files"><a class="header" href="#hiding-files">Hiding files</a></h3>
<p>This step is optional.
In the code go to the <code>Preferences</code> -&gt; <code>Workspace Settings</code> and paste the following settings into the opened file:</p>
<pre><code class="language-json">{
    &quot;files.exclude&quot;: {
        &quot;**/.git&quot;: true,
        &quot;**/.DS_Store&quot;: true
    }
}
</code></pre>
<p>You can extend the list with the files, extensions or directories based on your preferences.</p>
<h1 id="es6"><a class="header" href="#es6">ES6</a></h1>
<p>ECMAScript 2015 (also known as ES6 and often referred to as <code>Harmony</code>) is the 6th major release of the ECMAScript language specification.</p>
<p>I am going to cover the most important features here to get you started with ES6 and then be able moving to TypeScript and Angular faster.</p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>The <code>class</code> syntax in JavaScript is not a new object-oriented inheritance model
but simply a syntactical sugar on top of the existing prototype-based inheritance.</p>
<p>Traditionally we have been using standard Objects and Prototypes like shown below:</p>
<pre><code class="language-js">var Widget = function(id, x, y) {
    this.id = id;
    this.setPosition(x, y);
}
Widget.prototype.setPosition = function(x, y) {
    this.x = x;
    this.y = y;
}
</code></pre>
<p>With class syntax developers get more natural and boilerplate-free result:</p>
<pre><code class="language-js">class Widget {
    constructor(id, x, y) {
        this.id = id;
        this.setPosition(x, y);
    }

    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
<p>The <code>constructor</code> function is automatically called when you create a new instance of <code>Widget</code>:</p>
<pre><code class="language-js">const myWidget = new Widget(1, 10, 20);
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>The <code>extends</code> keyword is used to define a class as a child of another class.
The following example demonstrates inheritance in practice:</p>
<pre><code class="language-js">class TextBox extends Widget {
    constructor (id, x, y, text) {
        super(id, x, y);
        this.text = text;
    }
}
</code></pre>
<p>We created a new <code>TextBox</code> class that is based on the <code>Widget</code> and adds additional <code>text</code> property.</p>
<p>Note that a base Widget constructor must also be called when a child class instantiated.
It must be the very first line of the child constructor implementation.</p>
<p>Here's another example:</p>
<pre><code class="language-js">class ImageBox extends Widget {
    constructor (id, x, y, width, height) {
        super(id, x, y);
        this.setSize(width, height);
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
    }

    reset() {
        this.setPosition(0, 0);
        this.setSize(0, 0);
    }
}
</code></pre>
<p><code>ImageBox</code> also inherits <code>Widget</code> class and adds size-related information alongside position.</p>
<p>Access to both classes is demonstrated with the <code>reset</code> function that calls <code>Widget.setPosition</code> and <code>ImageBox.setSize</code> functions.</p>
<h2 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h2>
<p>ES6 offers a shorter syntax for a <strong>function expression</strong> called <strong>arrow function</strong>, also known as <strong>fat arrow function</strong>.</p>
<p>Arrow functions provide more expressive closure syntax, simplify function scoping and change the way <code>this</code> is handled.</p>
<h3 id="expression-bodies"><a class="header" href="#expression-bodies">Expression Bodies</a></h3>
<p>When used as expressions bodies arrow functions work much like anonymous one-line <strong>lambdas</strong> that you can meet in many programming languages.</p>
<p>Let's filter a book collection to find something to read using both ES5 and ES6 to see the difference:</p>
<pre><code class="language-js">var books = [
    { name: 'Book 1', read: true },
    { name: 'Book 2' , read: false },
    { name: 'Book 3', read: true }
];

// ES5
var booksToRead = books.filter(function (b) { return !b.read });

// ES6
var booksToRead = books.filter(b =&gt; !b.read);
</code></pre>
<p>Curly brackets and <code>return</code> statement are not required if only one expression is present.</p>
<p>You could write the same example like following:</p>
<pre><code class="language-js">// ES6
let booksToRead = books.filter(b =&gt; { return !b.read; });
</code></pre>
<h3 id="statement-bodies"><a class="header" href="#statement-bodies">Statement Bodies</a></h3>
<p>Arrow functions provide more expressive closure syntax.</p>
<pre><code class="language-js">// ES6
// list the books I've read
books.forEach(b =&gt; {
    if (book.read) {
        console.log(b.name);
    }
});
</code></pre>
<p>And another example using DOM:</p>
<pre><code class="language-js">// ES6
let button = document.getElementById('submit-button');

button.addEventListener('click' () =&gt; {
    this.onButtonClicked();
});
</code></pre>
<p>Parameterless arrow functions are much easier to read</p>
<pre><code class="language-js">// ES6
setTimeout(_ =&gt; {
    console.log('First callback');
    setTimeout(_ =&gt; {
        console.log('Second callback');
    }, 1);
}, 1);
</code></pre>
<h3 id="lexical-this"><a class="header" href="#lexical-this">Lexical <em>this</em></a></h3>
<p>One of the best features of arrow functions in ES6 is the more intuitive handling of current object context.
These function expressions do not bind their variables:</p>
<ul>
<li>arguments</li>
<li>super</li>
<li>this</li>
<li>new.target</li>
</ul>
<pre><code class="language-js">// ES6
this.books.forEach(b =&gt; {
    if (!b.read) {
        this.booksToRead.push(b);
    }
});
</code></pre>
<p>There are multiple ways of doing the same with ECMAScript 5, and all of them involve manual context management</p>
<pre><code class="language-js">// ES5: using 'bind()'
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}).bind(this);

// ES5: referencing 'this' via variables
var self = this;

this.books.forEach(function(b) {
  if (!b.read) {
    self.booksToRead.push(b);
  }
});

// ES5: passing context if supported
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}, this);
</code></pre>
<p>As arrow functions do not create and bind their own <code>this</code> context the following code is concise and works as expected:</p>
<pre><code class="language-js">// ES6
function ProgressBar() {
  this.progress = 0;

  setInterval(() =&gt; {
    this.progress++;
  }, 1000);
}

const p = new ProgressBar();
</code></pre>
<p>In the example above <code>this</code> properly refers to the <code>ProgressBar</code> object.
Before ES6 you would most probably additional variables like <code>self</code>, <code>that</code>, and other.</p>
<pre><code class="language-js">// ES5
function ProgressBar() {
  var self = this;
  self.progress = 0;

  setInterval(function () {
    self.progress++;
  }, 1000);
}
</code></pre>
<h2 id="template-literals"><a class="header" href="#template-literals">Template Literals</a></h2>
<p>Template Literals (formerly called &quot;template strings&quot; in prior drafts of the ECMAScript 6 language specification) are string literals providing intuitive expression interpolation for single-line and multiline strings. </p>
<p>You use backticks to enclose a string literal and ${} to interpolate JavaScript variables or arbitrary expressions</p>
<pre><code class="language-js">// ES6
let point = { x: 10, y: 20 };

console.log(`Position is ${point.x}:${point.y}`);
// output: Position is 10:10
</code></pre>
<p>With ES5 you have to concatenate strings when dealing with multiple lines:</p>
<pre><code class="language-js">// ES5
var title = 'Title'
var component = {
  template: '' + 
    '&lt;h1&gt;' + title + '&lt;h1&gt;\n' +
    '&lt;div class=&quot;grid&quot;&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '&lt;/div&gt;'
}
</code></pre>
<p>Multi-line string creation with template literals becomes very clean and readable:</p>
<pre><code class="language-js">// ES6
let title = 'Title';
let component = {
  template: `
    &lt;h1&gt;${title}&lt;/h1&gt;
    &lt;div class=&quot;grid&quot;&gt;
      &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;col-6&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
}
</code></pre>
<h2 id="extended-parameter-handling"><a class="header" href="#extended-parameter-handling">Extended Parameter Handling</a></h2>
<p>ES6 brings improvements to parameter handling by introducing <code>default values</code>, <code>rest parameter</code> and <code>spread operator</code>.</p>
<h3 id="default-parameter-values"><a class="header" href="#default-parameter-values">Default Parameter Values</a></h3>
<p>Simple and intuitive default values for function parameters.</p>
<pre><code class="language-js">// ES6
function playSound(file, volume = 50) {
  console.log(`Playing '${file}' with volume ${volume}.`);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>With ES5 you have to check every parameter to be <code>undefined</code> and setting defaults manually if needed.</p>
<pre><code class="language-js">// ES5
function playSound(file, volume) {
    if (volume === undefined) {
        volume = 50;
    }
    console.log(&quot;Playing '&quot; + file + &quot;' with volume &quot; + volume);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>So support for <code>default parameter values</code> is a huge step forward and real time saver.</p>
<h3 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h3>
<p>In ES5, if you want your function to handle an indefinite or an arbitrary number of arguments,
you must use special <code>arguments</code> variable:</p>
<pre><code class="language-js">// ES5
function logMessages() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i]);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Which produces:</p>
<pre><code class="language-text">Hello,
world!
</code></pre>
<p>In ES6, you can aggregate all remaining arguments into a single function parameter</p>
<pre><code class="language-js">// ES6
function logMessages(...messages) {
  for (const message of messages) {
    console.log(message);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Also, that gives the same console output as before:</p>
<pre><code class="language-text">Hello, 
world!
</code></pre>
<p>Rest parameters become even more valuable when you need collecting arguments starting from a different position.</p>
<p>In the next example, the rest parameter is used to collect arguments from the second one to the end of the array.</p>
<pre><code class="language-js">// ES6
function greet(message, ...friends) {
  for (const friend of friends) {
    console.log(`${message}, ${friend}!`);
  }
}

greet('Hello', 'John', 'Joan', 'Bob')
</code></pre>
<p>The function above allows you to set the greeting message as the first parameter and array of friend names to generate messages.
The console output, in this case, should be:</p>
<pre><code class="language-text">Hello, John!
Hello, Joan!
Hello, Bob!
</code></pre>
<h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<p>Spread operator is used to expand an iterable collection into multiple arguments.</p>
<pre><code class="language-js">// ES6
let positive = [ 1, 2, 3 ];
let negative = [ -1, -2, -3 ]

let numbers = [...negative, 0, ...positive];

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<p>You can use spread operator even with strings:</p>
<pre><code class="language-js">// ES6
let message = 'Hello, world';
let chars = [...message];

console.log(chars);
// [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;,&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]
</code></pre>
<p>Spread operator easily becomes an alternative to the <code>Array.prototype.concat()</code> method.
With ES5 the example above will look like the following:</p>
<pre><code class="language-js">// ES5
var positive = [ 1, 2, 3 ];
var negative = [ -1, -2, -3 ];
var zero = [0];

var numbers = negative.concat(zero, positive);

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<h2 id="destructuring-assignment"><a class="header" href="#destructuring-assignment">Destructuring Assignment</a></h2>
<p>ES6 provides a way to extract values out of the objects or collections into the separate variables to access them easier in the code.
That is often called &quot;value unpacking&quot; or &quot;destructuring&quot;.</p>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic example</a></h3>
<p>As an example, you can extract a subset of values from the collection using the following format:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's create an array of words and extract the first couple of them into separate variables &quot;first&quot; and &quot;second&quot; like in the code below:</p>
<pre><code class="language-js">// ES6

let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second ] = words;

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<p>As you can see from the example above, you can extract a subset of an array and split it into multiple variables.</p>
<p>Without destructuring your code might look like the following:</p>
<pre><code class="language-js">// ES5

var words = [ 'this', 'is', 'hello', 'world', 'example' ];
var first = words[0];
var second = words[1];

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<h3 id="array-destructuring"><a class="header" href="#array-destructuring">Array destructuring</a></h3>
<p>You have already seen some of the array destructuring examples earlier in the section.
We enclose variables in square brackets using the following syntax:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Please note that you can also apply the same destructuring technique to the function call results:</p>
<pre><code class="language-js">// ES6

function getWords() {
    return [ 'this', 'is', 'hello', 'world', 'example' ];
}

let [ first, second ] = getWords();
console.log(`${first} ${second}`); // 'this is'
</code></pre>
<p>In addition to basic unpacking and variable assignment, several other things bring much value and reduce the code.</p>
<h4 id="value-assignment"><a class="header" href="#value-assignment">Value assignment</a></h4>
<p>The destructuring syntax can be used to assign values to variables instead of extracting them.
Take a look at the following example: </p>
<pre><code class="language-js">// ES6

let first, second;

[ first, second ] = [ 'hello', 'world' ];

console.log(first);  // 'hello'
console.log(second); // 'world'
</code></pre>
<h4 id="default-values"><a class="header" href="#default-values">Default values</a></h4>
<p>Another great feature of the array destructuring is default values.
There might be cases when the array has no values, and you want to provide some reasonable defaults.</p>
<p>The format of the syntax, in this case, is as follows:</p>
<pre><code class="language-text">let [ &lt;variable&gt; = &lt;value&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's see this feature in action:</p>
<pre><code class="language-js">// ES6

let words = [ 'hello' ];
let [ first = 'hey', second = 'there' ] = words;

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<p>The array we got initially does not contain two words.
We are trying to extract first two variables from it, and set 'hey' as the default value for the first word, and 'there' as a default for the second one.
At the runtime however only second variable stays with the default value.</p>
<p>Default value assignment is a compelling feature that helps you reduce the code for variable initialization and safety checks.
Below is how the same code could look like in ES5:</p>
<pre><code class="language-js">// ES5

var words = ['hello'];

var first = words[0];
if (!first) {
    first = 'hey';
}

var second = words[1];
if (!second) {
    second = 'there'
}

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<h4 id="swapping-values"><a class="header" href="#swapping-values">Swapping values</a></h4>
<p>Traditionally to swap two variables, developers need a third temporary one to hold the value of either first or second variable.</p>
<pre><code class="language-js">// ES5

var first = 'world';
var second = 'hello';

var temp = first;
first = second;
second = temp;

console.log(first + ' ' + second); // 'hello world'
</code></pre>
<p>With ES6 you can now reduce the code by using destructuring assignment syntax to swap variables in a single line like in the next example:</p>
<pre><code class="language-js">// ES6

let first = 'world';
let second = 'hello';

[ first, second ] = [ second, first ];

console.log(`${first} ${second}`); // 'hello world'
</code></pre>
<p>This feature may be a great time saver when it comes to sorting functions.</p>
<h4 id="skipping-values"><a class="header" href="#skipping-values">Skipping values</a></h4>
<p>We have been using examples that take the beginning of the array so far.<br />
The ES6 does not restrict you to that only scenario; it is also possible skipping values when unpacking or destructuring arrays.</p>
<pre><code class="language-text">let [ &lt;variable-1&gt;, , , , &lt;variable-X&gt; ] = &lt;array&gt;
</code></pre>
<p>You can just put the commas instead of variables like in the example below:</p>
<pre><code class="language-js">let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second, , , last ] = words;

console.log(`${first} ${second} ${last}`); // 'this is example'
</code></pre>
<h4 id="grouping-tail-values-into-a-single-variable"><a class="header" href="#grouping-tail-values-into-a-single-variable">Grouping tail values into a single variable</a></h4>
<p>As you see, the ES6 allows you to unpack the head of the array into separate variables.
Sometimes you may want to access the tail of the array as a single variable as well.</p>
<p>For this particular case, there's a special syntax that utilizes ES6 &quot;rest&quot; parameters.</p>
<pre><code class="language-text">let [ &lt;variable1&gt;, &lt;variable2&gt;, ...&lt;restVariable&gt; ] = &lt;array&gt;
</code></pre>
<p>We use &quot;rest parameter&quot; to define a variable to hold the tail of the array and below is an example of how to achieve this behavior:</p>
<pre><code class="language-js">let command = [ 'greet', 'user1', 'user2', 'user3' ];
let [ action, ...users ] = command;

console.log(action); // 'greet'
console.log(users);  // [ 'user1', 'user2', 'user3' ] 
</code></pre>
<h3 id="object-destructuring"><a class="header" href="#object-destructuring">Object destructuring</a></h3>
<p>Besides arrays and collections, you can use destructuring assignment syntax with the object instances as well.</p>
<p>We enclose variables in curly brackets using the following syntax:</p>
<pre><code class="language-text">let { &lt;var1&gt;, &lt;var2&gt; } = &lt;object&gt;
</code></pre>
<h4 id="unpacking-properties"><a class="header" href="#unpacking-properties">Unpacking properties</a></h4>
<p>ES6 allows you to extract properties by their names similar to how to unpack arrays.</p>
<p>Let's try to unpack a couple of properties from a user object:</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id, username } = obj;

console.log(id);        // '1'
console.log(username);  // 'jdoe'
</code></pre>
<h4 id="renaming-properties"><a class="header" href="#renaming-properties">Renaming properties</a></h4>
<p>You can also give destructured property an alias if you want to use it as a variable with a different name.</p>
<p>The syntax, in this case, is going to be as follows:</p>
<pre><code class="language-text">let { &lt;property&gt; : &lt;alias&gt; } = &lt;object&gt;;
</code></pre>
<p>Let's now rewrite our previous example to use custom property names.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id: uid, username: login } = obj;

console.log(uid);    // '1'
console.log(login);  // 'jdoe'
</code></pre>
<p>We are using &quot;uid&quot; and &quot;login&quot; instead of &quot;id&quot; and &quot;username&quot; properties this time.</p>
<h4 id="default-values-1"><a class="header" href="#default-values-1">Default values</a></h4>
<p>When applying property destructuring to the object properties, you can provide default values for missing properties.
That saves time for property checks and reduces coding efforts.</p>
<pre><code class="language-text">let { &lt;variable&gt; : &lt;value&gt; } = &lt;object&gt;
</code></pre>
<p>For example, let's provide a default value for the &quot;id&quot; property and also unpack the property &quot;role&quot;
that does not exist for the given object, and set it to be &quot;guest&quot; by default.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id = 0, role = 'guest' } = obj;

console.log(id);    // '1'
console.log(role);  // 'guest'
</code></pre>
<h4 id="unpacking-methods"><a class="header" href="#unpacking-methods">Unpacking methods</a></h4>
<p>You can extract object methods into separate variables and use them as shortcuts:</p>
<pre><code class="language-js">let { log } = console;
log('hello world');
</code></pre>
<p>The example above demonstrates a &quot;console.log&quot; method being extracted into the &quot;log&quot; variable and used separately.</p>
<p>We utilise the following syntax:</p>
<pre><code class="language-text">let { &lt;method&gt; } = &lt;object&gt;
</code></pre>
<p>Next, let's create a custom class and export multiple methods:</p>
<pre><code class="language-js">// ES6

class MyClass {

  sayHello(message) {
    console.log(`Hello, ${message}`);
  }

  sayBye(message) {
    console.log(`Bye, ${message}`);
  }

}

let myClass = new MyClass();
let { sayHello, sayBye } = myClass;

sayHello('how are you?');  // 'Hello, how are you?'
sayBye('see you soon.');   // 'Bye, see you soon'
</code></pre>
<h4 id="renaming-methods"><a class="header" href="#renaming-methods">Renaming methods</a></h4>
<p>You can also rename destructured methods if needed. The following syntax should be used to give the unpacked method a custom name:</p>
<pre><code class="language-text">let { &lt;method&gt; : &lt;alias&gt; } = &lt;object&gt;
</code></pre>
<p>Let's update the &quot;MyClass&quot; we used earlier and rename &quot;sayHello&quot; and &quot;sayBye&quot; methods to just &quot;hello&quot; and &quot;bye&quot;:</p>
<pre><code class="language-js">let myClass = new MyClass();
let { sayHello: hello, sayBye: bye } = myClass;

hello('how are you?');  // Hello, how are you?
bye('see you soon');    // Bye, see you soon
</code></pre>
<h3 id="using-with-function-parameters"><a class="header" href="#using-with-function-parameters">Using with function parameters</a></h3>
<p>The best scenario for using destructuring with objects and functions is default parameter values and options.</p>
<p>First, let's reproduce the most common use case for the &quot;options&quot; parameter passed to a function or object member:</p>
<pre><code class="language-js">// ES5

function showDialog(options) {
  options = options || {};
  var message = options.message || 'Unknown message';
  var size = options.size || { width: 400, height: 400 };
  var position = options.position || { x: 200, y: 300 };

  console.log('message: ' + message);
  console.log('size: ' + size.width + ':' + size.height);
  console.log('position: ' + position.x + ':' + position.y);
}
</code></pre>
<p>Above is the simplified version of the custom options management that has been very popular for years.
We provide a JavaScript object as an &quot;options&quot; parameter, and function does parsing and detecting missing properties to initialize default values if needed.</p>
<p>Depending on the size of the options object there might be many checks just to set the default values for them.
Especially if there are nested objects with own properties, like &quot;size&quot; and &quot;position&quot; in our case.</p>
<p>Now, if you call the &quot;showDialog&quot; function with no parameters except the &quot;message&quot; value, the output should be similar to the following one:</p>
<pre><code class="language-js">showDialog({ 
    message: 'hello world' 
});

// message: hello world
// size: 400:400
// position: 200:300
</code></pre>
<p>Next, try to call the same function with a partial set of options, for instance, the &quot;size&quot; settings:</p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<p>Now you can rewrite the &quot;showDialog&quot; implementation to use destructuring with default values like in the next example:</p>
<pre><code class="language-js">// ES6

function showDialog({ 
  message = 'Message', 
  size = { width: 400, height: 400 },
  position = { x: 200, y: 300 } }) {

  console.log(`message: ${message}`);
  console.log(`size: ${size.width}:${size.height}`);
  console.log(`position: ${position.x}:${position.y}`);
}
</code></pre>
<p>Notice how we use the destructuring assignment syntax to declare a function parameter. </p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<h4 id="ide-support"><a class="header" href="#ide-support">IDE support</a></h4>
<p>Many modern IDEs already provide support for destructuring syntax within function or method parameters. <a href="https://code.visualstudio.com/">VS Code</a>, for instance, provides auto-completion both for function calls and for nested properties.</p>
<p><img src="images/es6-desctructuring-01.png" alt="" /></p>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Before ES6 developers traditionally were using <code>Revealing Module</code> pattern to emulate modules in JavaScript.</p>
<p>The basic concept of a Revealing Module is that you use <code>closures</code> (self-invoking functions)
with an <code>Object</code> which encapsulates its data and behavior.</p>
<pre><code class="language-js">// ES5
var Module = (function() {
    var privateMethod = function() {
        // do something 
        console.log('private method called');
    };

    return {
        x: 10,
        name: 'some name',
        publicMethod: function() {
            // do something
            console.log('public method called');
            privateMethod();
        }
    };
})();

Module.publicMethod()
</code></pre>
<p>You should get the following output to browser console:</p>
<pre><code class="language-text">public method called
private method called
</code></pre>
<p>I recommend also reading an excellent article &quot;<a href="https://toddmotto.com/mastering-the-module-pattern/">Mastering the Module Pattern</a>&quot; by Todd Motto to get deep coverage of <strong>Revealing Module</strong> pattern in JavaScript.</p>
<p>The rise of module systems based on either AMD or CommonJS syntax has mostly replaced revealing modules and other hand-written solutions in ES5.</p>
<h3 id="exporting-and-importing-values"><a class="header" href="#exporting-and-importing-values">Exporting and Importing Values</a></h3>
<p>ECMAScript 6 provides a long-needed support for exporting and importing values from/to modules without global namespace pollution.</p>
<pre><code class="language-js">// ES6

// module lib/logger.js
export function log (message) { console.log(message); };
export var defaultErrorMessage = 'Aw, Snap!';

//  myApp.js
import * as logger from &quot;lib/logger&quot;;
logger.log(logger.defaultErrorMessage);

//  anotherApp.js
import { log, defaultErrorMessage } from &quot;lib/logger&quot;;
log(defaultErrorMessage);
</code></pre>
<p>Here's how the same approach would look like if written with ECMAScript 5:</p>
<pre><code class="language-js">// ES5

// lib/logger.js
LoggerLib = {};
LoggerLib.log = function(message) { console.log(message); };
LoggerLib.defaultErrorMessage = 'Aw, Snap!';

// myApp.js
var logger = LoggerLib;
logger.log(logger.defaultErrorMessage);

// anotherApp.js
var log = LoggerLib.log;
var defaultErrorMessage = LoggerLib.defaultErrorMessage;
log(defaultErrorMessage);
</code></pre>
<h3 id="default-values-2"><a class="header" href="#default-values-2">Default Values</a></h3>
<p>You can make your ES6 module exporting some value as <code>default</code> one.</p>
<pre><code class="language-js">// ES6

// lib/logger.js
export default (message) =&gt; console.log(message);

// app.js
import output from 'lib/logger';
output('hello world');
</code></pre>
<h3 id="wildcard-export"><a class="header" href="#wildcard-export">Wildcard Export</a></h3>
<p>Another great feature of ES6 modules is support for wildcard-based export of values.
That becomes handy if you are creating a composite module that re-exports values from other modules.</p>
<pre><code class="language-js">// ES6

// lib/complex-module.js
export * from 'lib/logger';
export * from 'lib/http';
export * from 'lib/utils';

// app.js
import { logger, httpClient, stringUtils } from 'lib/complex-module';
logger.log('hello from logger');
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="http://es6-features.org/">ECMAScript 6 â€” New Features: Overview &amp; Comparison</a></li>
</ul>
<h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h2 id="getting-started-with-typescript"><a class="header" href="#getting-started-with-typescript">Getting Started with TypeScript</a></h2>
<h3 id="installing-typescript"><a class="header" href="#installing-typescript">Installing TypeScript</a></h3>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h3 id="using-tsc"><a class="header" href="#using-tsc">Using tsc</a></h3>
<p>In your code editor create a file <code>logger.ts</code> with the following content:</p>
<pre><code class="language-js">function log(message) {
    console.log(message);
}

log('Hello, world!');
</code></pre>
<p>Now you can use a command line to compile your source code to ES5 with <code>tsc</code> tool and run it with <code>node.js</code>:</p>
<pre><code class="language-sh">tsc logger.ts
node logger.js
</code></pre>
<p>TypeScript compiler takes <code>logger.ts</code> file, processes it and produces a JavaScript output to <code>logger.js</code>.
At this point, the <code>.js</code> file is ready to be used with an HTML page or executed by node.js.</p>
<p>You should see the following output in the command line:</p>
<pre><code class="language-text">Hello, world!
</code></pre>
<p>Now let's see how type validation works.
Add <code>string</code> type annotation for the <code>log</code> function and call it with a <code>number</code>.</p>
<pre><code class="language-ts">function log(message: string) {
    console.log(message);
}

log(0);
</code></pre>
<p>If you compile <code>logger.ts</code> once again <code>tsc</code> should produce an error:</p>
<pre><code class="language-sh">tsc logger.ts
&gt; logger.ts(5,5): error TS2345: Argument of type '0' is not assignable to parameter
of type 'string'.
</code></pre>
<h3 id="typings"><a class="header" href="#typings">Typings</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h3 id="linting"><a class="header" href="#linting">Linting</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h4 id="tslint"><a class="header" href="#tslint">TSLint</a></h4>
<blockquote>
<p>TSLint checks your TypeScript code for readability, maintainability, and functionality errors.</p>
</blockquote>
<pre><code class="language-sh">npm install -g tslint
</code></pre>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h2 id="typescript-features"><a class="header" href="#typescript-features">TypeScript Features</a></h2>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/4">todo: Needs introduction</a></em></p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>TypeScript supports all the types used in JavaScript:</p>
<ul>
<li><strong>boolean</strong></li>
<li><strong>number</strong></li>
<li><strong>string</strong></li>
<li><strong>arrays</strong></li>
</ul>
<p>TypeScript also adds the following types:</p>
<ul>
<li><strong>enum</strong></li>
<li><strong>any</strong></li>
<li><strong>void</strong></li>
</ul>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<h4 id="boolean"><a class="header" href="#boolean">Boolean</a></h4>
<p>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a boolean value.</p>
<pre><code class="language-ts">let isEnabled: boolean = true;
</code></pre>
<p>Assigning non-Boolean value to the variable will produce an error.</p>
<pre><code class="language-ts">isEnabled = 'YES';
// logger.ts(2,1): error TS2322: Type '&quot;YES&quot;' is not assignable to type 'boolean'.
</code></pre>
<p>It is also possible annotating function or method return types.</p>
<pre><code class="language-ts">function isEmpty(str: string): boolean {
    return !str;
}
</code></pre>
<h4 id="number"><a class="header" href="#number">Number</a></h4>
<p>TypeScript maps all JavaScript numbers to the <code>number</code> type:</p>
<ul>
<li>floating point numbers (default JavaScript type for all numbers)</li>
<li>decimal numbers</li>
<li>hexadecimal numbers</li>
<li>binary literals (ES6)</li>
<li>octal literals (ES6)</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-ts">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>Typescript supports ES6 <strong>template literals</strong> (formerly known as <strong>template strings</strong>).</p>
<p>As in ECMAScript 6, you use backticks (`) to enclose a string literal and <strong>${}</strong> to interpolate JavaScript variables or arbitrary expressions.</p>
<p>Either double quotes (&quot;) or single quotes (') can be used to surround string data.</p>
<pre><code class="language-ts">let firstName: string = &quot;Joan&quot;;
let lastName: string = 'Doe';
let fullName: string = `${firstName} ${lastName}`;
let template: string = `
    &lt;h1&gt;Title&lt;h1&gt;
    &lt;p&gt;Hello, ${fullName}&lt;/p&gt;
`;
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>There are two main ways you can provide type definition for arrays of values in TypeScript:</p>
<pre><code class="language-ts">let arr1: string[] = [];
let arr2: Array&lt;string&gt; = new Array();
</code></pre>
<p>You can also initialize arrays upon declaring them:</p>
<pre><code class="language-ts">let arr1: string[] = ['hello', 'world'];
let arr2: Array&lt;string&gt; = ['hello', 'world'];

let flags1: boolean[] = [true, false, true, false];
let flags2: boolean[] = new Array(false, true);
</code></pre>
<p>As in JavaScript arrays, you can <strong>push</strong> elements and access them by <strong>index</strong></p>
<pre><code class="language-ts">let users: string[] = [];

users.push('user1');

console.log(`First user: ${users[0]}`);
</code></pre>
<p>The sample above demonstrates array element access together with string interpolation.
When executed it should produce:</p>
<pre><code class="language-text">First user: user1
</code></pre>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<p>TypeScript provides support for an <strong>enumerated type</strong> known in many languages (Swift, C#, Java, C, and others).
This data type consists of a set of named values mapped to numbers.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

let s: Suit = Suit.Spade;
</code></pre>
<p>By default numbering of enum members starts with 0 and increments by one.
You have full control of the values if needed.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };
enum Suit { Club = 1, Diamond = 2, Heart = 4, Spade = 8 }
</code></pre>
<p>Another valuable feature is accessing by a numeric value.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

console.log(Suit[0]); // Club
</code></pre>
<p>It must be noted however that you access names by the numeric values, not by an array index as it may seem.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };

console.log(Suit[0]); // undefined
console.log(Suit[1]); // Club
</code></pre>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p>A special <strong>any</strong> type is used to opt-out of the TypeScript type-checking process and addresses the following cases:</p>
<ul>
<li>dynamic content (objects created on the fly)</li>
<li>3rd party libraries (having no TypeScript support via definition files)</li>
</ul>
<pre><code class="language-ts">let obj: any = {
    log(message) {
        console.log(message);
    }
};
obj.log('hello world');
</code></pre>
<p>Please note that by opting-out of the type-checking process you take full responsibility for safety checks,
as now TypeScript compiler is not able to verify the code at compile time.</p>
<p>The following example shows valid TypeScript code:</p>
<pre><code class="language-ts">obj.log('hello world'); 
obj.helloWorld('log');
</code></pre>
<p>However, at runtime the second line causes a TypeError exception:</p>
<pre><code class="language-text">hello world
TypeError: obj.helloWorld is not a function
</code></pre>
<p>So it is recommended using <strong>any</strong> type only where necessary.</p>
<h3 id="void"><a class="header" href="#void">Void</a></h3>
<p>The <strong>void</strong> type is used to declare a function does not return any value explicitly.</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
        return true;
    }

}
</code></pre>
<p>If you try compiling the code above you should get an error:</p>
<pre><code class="language-text">error TS2322: Type 'true' is not assignable to type 'void'.
</code></pre>
<p>You can fix the type-check error by removing <strong>return</strong> statement from the <strong>log</strong> method:</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
    }

}
</code></pre>
<p>You might also be using <strong>void</strong> types as function parameters or with <strong>Interfaces</strong>:</p>
<pre><code class="language-ts">function fn(x: () =&gt; void) {
  x();
}

interface Logger {

  log(message: string): void;
  warn(message: string): void;
  error(message: string): void;

}
</code></pre>
<p><em>You will get more information on <strong>Interfaces</strong> later in this book.</em></p>
<h2 id="classes-1"><a class="header" href="#classes-1">Classes</a></h2>
<p>TypeScript provides support for classes introduced with ES6 (ECMAScript 2015) and adds a set of features to improve object-oriented development.</p>
<pre><code class="language-ts">class Widget {

    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        console.log(`Rendering widget &quot;${this.id}&quot;`);
    }

}

let widget = new Widget('text1');
widget.render();
</code></pre>
<p>You should get the following output when executed:</p>
<pre><code class="language-text">Rendering widget &quot;text1&quot;
</code></pre>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>With ES6 you define class properties from with the class constructor:</p>
<pre><code class="language-js">// ES6
class Widget {

    constructor(id) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }

}
</code></pre>
<p>If you try compiling example above with <code>tsc</code> utility (TypeScript compiler) you should get the following errors:</p>
<pre><code class="language-text">error TS2339: Property 'id' does not exist on type 'Widget'.
error TS2339: Property 'x' does not exist on type 'Widget'.
error TS2339: Property 'y' does not exist on type 'Widget'.
</code></pre>
<p>The errors are raised because TypeScript requires you to define properties separately.
It is needed to enable many other features TypeScript provides.</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number;
    x: number;

    constructor(id: string) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }
}
</code></pre>
<p>Properties in TypeScript can have default values:</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number = 0;
    x: number = 0;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<h3 id="setters-and-getters"><a class="header" href="#setters-and-getters">Setters and Getters</a></h3>
<p>TypeScript supports <em>computed properties</em>, which do not store a value.
Instead, they provide <em>getters</em> and <em>setters</em> to retrieve and assign values in a controlled way.</p>
<p><strong>TBD</strong>: describe get/set format</p>
<p>One of the common cases for a <em>getter</em> is computing a return value based on other property values:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}

let user = new User('Joan', 'Doe');
console.log(`User full name is: ${user.fullName}`);
</code></pre>
<p>If you save this example to file <code>script.ts</code>, compile it and run like shown below:</p>
<pre><code class="language-sh">tsc --target ES6 script.ts
node script.js
</code></pre>
<p>You should see the output with the full username as expected:</p>
<pre><code class="language-text">User full name is: Joan Doe
</code></pre>
<p>Now let's introduce a simple <em>setter</em> for the <code>firstName</code> property.</p>
<p>Every time a new property value is set we are going to remove leading and trailing white space.
Such values as &quot; Joan&quot; and &quot;Joan  &quot; are automatically converted to &quot;Joan&quot;.</p>
<pre><code class="language-ts">class User {

    private _firstName: string;

    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        if (value) {
            this._firstName = value.trim();
        }
    }
}

let user = new User();
user.firstName = '  Joan   ';
console.log(`The first name is &quot;${user.firstName}&quot;.`);
</code></pre>
<p>The console output, in this case, should be:</p>
<pre><code class="language-text">The first name is &quot;Joan&quot;.
</code></pre>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>Methods are functions that operate on a class object and are bound to an instance of that object.
You can use <code>this</code> keyword to access properties and call other methods like in the example below:</p>
<pre><code class="language-ts">class Sprite {

    x: number;
    y: number;

    render() {
        console.log(`rendering widget at ${this.x}:${this.y}`);
    }
    
    moveTo(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.render();
    }

}

let sprite = new Sprite();
sprite.moveTo(5, 10);
// rendering widget at 5:10
</code></pre>
<h4 id="return-values"><a class="header" href="#return-values">Return values</a></h4>
<pre><code class="language-ts">class NumberWidget {

    getId(): string {
        return 'number1';
    }

    getValue(): number {
        return 10;
    }

}
</code></pre>
<p>You can use a <code>void</code> type if the method does not return any value.</p>
<pre><code class="language-ts">class TextWidget {

    text: string;

    reset(): void {
        this.text = '';
    }

}
</code></pre>
<h4 id="method-parameters"><a class="header" href="#method-parameters">Method parameters</a></h4>
<p>You can add types to each parameter of the method.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level: number) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>TypeScript will automatically perform type checking at compile time.
Let's try providing a string value for the <code>level</code> parameter:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 'not a number');
</code></pre>
<p>You should get a compile error with the following message:</p>
<pre><code class="language-text">error TS2345: Argument of type '&quot;string&quot;' is not assignable to parameter of type 'number'.
</code></pre>
<p>Now let's change <code>level</code> parameter to a number to fix compilation</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 2);
</code></pre>
<p>Now we should get the expected output:</p>
<pre><code class="language-text">(2): test
</code></pre>
<h4 id="optional-parameters"><a class="header" href="#optional-parameters">Optional parameters</a></h4>
<p>By default, all method/function parameters in TypeScript are <code>required</code>.
However, it is possible making parameters optional by appending <strong>?</strong> (question mark) symbol to the parameter name.</p>
<p>Let's update our <code>Logger</code> class and make <code>level</code> parameter optional.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level?: number) {
        if (level === undefined) {
            level = 1;
        }
        console.log(`(${level}): ${message}`);
    }

}

let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The <code>log</code> method provides default value automatically if <code>level</code> is omitted.</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<p>Please note that optional parameters must always follow required ones.</p>
<h4 id="default-parameters"><a class="header" href="#default-parameters">Default parameters</a></h4>
<p>TypeScript also supports default values for parameters.
Instead of checking every parameter for <code>undefined</code> value you can provide defaults directly within the method declaration:</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string = 'Unknown error', level: number = 1) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>Let's try calling <code>log</code> without any parameters:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The output, in this case, should be:</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<h4 id="rest-parameters-and-spread-operator"><a class="header" href="#rest-parameters-and-spread-operator">Rest Parameters and Spread Operator</a></h4>
<p>In TypeScript, you can gather multiple arguments into a single variable known as <em>rest parameter</em>.
Rest parameters were introduced as part of ES6, and TypesScripts extends them with type checking support.</p>
<pre><code class="language-ts">class Logger {

    showErrors(...errors: string[]) {
        for (let err of errors) {
            console.error(err);
        }
    }

}
</code></pre>
<p>Now you can provide an arbitrary number of arguments for <code>showErrors</code> method:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.showErrors('Something', 'went', 'wrong');
</code></pre>
<p>That should produce three errors as an output:</p>
<pre><code class="language-text">Something
went
wrong
</code></pre>
<p><em>Rest parameters</em> in TypeScript work great with <em>Spread Operator</em> allowing you to expand a collection into multiple arguments.
It is also possible mixing regular parameters with <em>spread</em> ones:</p>
<pre><code class="language-ts">let logger = new Logger();
let messages = ['something', 'went', 'wrong'];

logger.showErrors('Error', ...messages, '!');
</code></pre>
<p>In the example above we compose a collection of arguments from arbitrary parameters and content of the <code>messages</code> array in the middle.</p>
<p>The <code>showErrors</code> method should handle all entries correctly and produce the following output:</p>
<pre><code class="language-text">Error
something
went
wrong
!
</code></pre>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Constructors in TypeScript got same features as methods.
You can have default and optional parameters, use rest parameters and spread operators with class constructor functions.</p>
<p>Besides, TypeScript provides support for automatic property creation based on constructor parameters.
Let's create a typical <code>User</code> class implementation:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}
</code></pre>
<p>Instead of assigning parameter values to the corresponding properties we can instruct TypeScript to perform an automatic assignment instead.
You can do that by putting one of the access modifiers <strong>public</strong>, <strong>private</strong> or <strong>protected</strong> before the parameter name.</p>
<p>You are going to get more details on <em>access modifiers</em> later in this book.
For now, let's see the updated <code>User</code> class using automatic property assignment:</p>
<pre><code class="language-ts">class User {

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(public firstName: string, public lastName: string) {
    }

}

let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<p>TypeScript creates <code>firstName</code> and <code>lastName</code> properties when generating JavaScript output.
You need targeting at least ES5 to use this feature.</p>
<p>Save example above to file <code>script.ts</code> then compile and run with <code>node</code>:</p>
<pre><code class="language-sh">tsc script.ts --target ES5
node script.js
</code></pre>
<p>The output should be as following:</p>
<pre><code class="language-text">Full name is: Joan Doe
</code></pre>
<p>You have not defined properties explicitly, but <code>fullName</code> getter was still able accessing them via <code>this</code>.
If you take a look at the emitted JavaScript you should see the properties are defined there as expected:</p>
<pre><code class="language-js">// ES5
var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    Object.defineProperty(User.prototype, &quot;fullName&quot;, {
        get: function () {
            return (this.firstName + &quot; &quot; + this.lastName).trim();
        },
        enumerable: true,
        configurable: true
    });
    return User;
}());
var user = new User('Joan', 'Doe');
console.log(&quot;Full name is: &quot; + user.fullName);
</code></pre>
<p>Now you can also switch to ES6 target to see how TypeScript assigns properties:</p>
<pre><code class="language-sh">tsc script.ts --target ES6
</code></pre>
<p>The generated JavaScript, in this case, is even smaller and cleaner:</p>
<pre><code class="language-js">// ES6
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName() {
        return `${this.firstName} ${this.lastName}`.trim();
    }
}
let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<h3 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h3>
<p>One of the important TypeScript features is the class inheritance that enables OOP patterns for developers.
Under the hood TypeScript is using the same <code>extends</code> syntactic sugar when targeting ES6 JavaScript,
and prototypical inheritance wrappers when generating output in ES5.</p>
<p>We can refer to animals as a classic example of class-based programming and inheritance.</p>
<pre><code class="language-ts">class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    makeSound() {
        console.log('Unknown sound');
    }
}
</code></pre>
<p>You have created a basic <code>Animal</code> class that contains a <code>name</code> property and <code>makeSound</code> method.
That translates to ES5 as following:</p>
<pre><code class="language-js">// ES5
var Animal = (function () {
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.makeSound = function () {
        console.log('Unknown sound');
    };
    return Animal;
}());
</code></pre>
<p>Now you can create a <code>Dog</code> implementation that provides a right sound:</p>
<pre><code class="language-ts">class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Woof-woof');
    }
}
</code></pre>
<p>Please note that if you have a constructor in the base class, then you must call it from all derived classes.
Otherwise, TypeScript should raise a compile-time error:</p>
<pre><code class="language-text">error TS2377: Constructors for derived classes must contain a 'super' call.
</code></pre>
<p>Here's how a <code>Dog</code> gets converted to ES5:</p>
<pre><code class="language-ts">var Dog = (function (_super) {
    __extends(Dog, _super);
    function Dog(name) {
        return _super.call(this, name) || this;
    }
    Dog.prototype.makeSound = function () {
        console.log('Woof-woof');
    };
    return Dog;
}(Animal));
</code></pre>
<p>Now let's add a <code>Cat</code> implementation with its sound and test both classes:</p>
<pre><code class="language-ts">class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Meow');
    }
}

let dog = new Dog('Spot');
let cat = new Cat('Tom');

dog.makeSound();
cat.makeSound();
</code></pre>
<p>Once the code compiles and executes you should get the following output:</p>
<pre><code class="language-text">Woof-woof
Meow
</code></pre>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>TypeScript supports <code>public</code>, <code>private</code> and <code>protected</code> modifiers for defining accessibility of the class members.</p>
<h4 id="public"><a class="header" href="#public">Public</a></h4>
<p>By default, each member of the class is <code>public</code> so that you can omit it.
However, nothing stops you from declaring <code>public</code> modifier explicitly if needed:</p>
<pre><code class="language-ts">class User {
    public firstName: string;
    public lastName: string;

    public speak() {
        console.log('Hello');
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre>
<p>Now if you compile example above to JavaScript you should see the following:</p>
<pre><code class="language-js">var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    User.prototype.speak = function () {
        console.log('Hello');
    };
    return User;
}());
</code></pre>
<h4 id="private"><a class="header" href="#private">Private</a></h4>
<p>You mark a member as <code>private</code> when it should never be accessed from outside of its containing class.
One of the most common scenarios is creating private fields to hold values for properties.
For example:</p>
<pre><code class="language-ts">class User {
    private _firstName: string;
    private _lastName: string;

    get firstName() {
        return this._firstName;
    }

    get lastName() {
        return this._lastName;
    }

    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
}
</code></pre>
<p>The class we have created above allows setting user's first and last name only from within the constructor.</p>
<p>If you try changing name properties from outside the class, TypeScript will raise an error at compile time:</p>
<pre><code class="language-ts">let user = new User('John', 'Doe');
user.firstName = 'Rob';
// error TS2540: Cannot assign to 'firstName' because it is a constant or a read-only property.
</code></pre>
<h4 id="protected"><a class="header" href="#protected">Protected</a></h4>
<p>The <code>protected</code> modifier restricts member visibility from outside of the containing class but provides access from the derived classes.</p>
<p>Let's start with base <code>Page</code> class implementation:</p>
<pre><code class="language-ts">class Page {

    protected renderHeader()    { /* ... */ }
    protected renderContent()   { /* ... */ }
    protected renderFooter()    { /* ... */ }

    render() {
        this.renderHeader();
        this.renderContent();        
        this.renderFooter();
    }
}
</code></pre>
<p>We created a <code>Page</code> class that has public method <code>render</code>.
Internally <code>render</code> calls three separate methods to render header, content and footer of the page.
These methods are not available from the outside the the class.</p>
<p>Now we are going to create a simple derived <code>AboutPage</code> class:</p>
<pre><code class="language-ts">class AboutPage extends Page {

    private renderAboutContent() { /* ... */ }

    render() {
        this.renderHeader();
        this.renderAboutContent();
        this.renderFooter();
    }

}
</code></pre>
<p>As you can see the <code>AboutPage</code> defines its <code>render</code> method that calls
<code>renderHeader</code> and <code>renderFooter</code> in parent class but puts custom content in the middle.</p>
<p>You can also use <code>protected</code> modifier with class constructors.
In this case, the class can be instantiated only by the derived classes that extend it.
That becomes handy when you want to have properties and methods available for multiple classes as a base implementation,
but don't want a base class to be instantiated outside its containing class.</p>
<p>For example</p>
<pre><code class="language-ts">class Page {
    protected constructor(id: string) {
        // ...
    }

    render() { /* base render */ }
}

class MainPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render main page */ }
}

class AboutPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render about page */ }
}

let main = new MainPage('main');
let about = new AboutPage('about');
</code></pre>
<p>You can create instances of <code>MainPage</code> and <code>AboutPage</code> both having access to protected members of the <code>Page</code> class.
However, you are not able creating an instance of the <code>Page</code> class directly.</p>
<pre><code class="language-ts">let page = new Page(); 
// error TS2674: Constructor of class 'Page' is protected and only accessible within the class declaration.
</code></pre>
<h3 id="readonly-modifier"><a class="header" href="#readonly-modifier">Readonly modifier</a></h3>
<p>One of the common ways to create a read-only property in many object-oriented programming languages
is by having a private local variable with a <code>getter</code> only.</p>
<pre><code class="language-ts">class Widget {

    private _id: string;

    get id(): string {
        return this._id;
    }

    constructor(id: string) {
        this._id = id;
    }
}

let widget = new Widget('textBox');
console.log(`Widget id: ${widget.id}`);
// Widget id: textBox
</code></pre>
<p>You can also make properties read-only by using the <code>readonly</code> keyword.
That reduces repetitive typing when dealing with many read-only properties, and greatly improves overall code readability.</p>
<p>Let's update the previous example to use <code>readonly</code>:</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<p>If you try changing the value of the property outside of the constructor TypeScript will raise an error:</p>
<pre><code class="language-ts">let widget = new Widget('text');
widget.id = 'newId';
// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p>You can provide default values for read-only properties only in two places: property declaration and constructor.</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;
    readonly minWidth: number = 200;
    readonly minHeight: number = 100;

    constructor(id: string) {
        this.id = id;
    }
}

let widget = new Widget('text');
widget.minWidth = 1000;
// error TS2540: Cannot assign to 'minWidth' because it is a constant or a read-only property.
</code></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>An <em>interface</em> is a description of the actions that an object can do.</p>
<p>You might already be familiar with <em>interfaces</em> in other programming languages like C# and Java,
or <em>contracts</em> in Swift.</p>
<p>Interfaces are not part of the ECMAScript.
It is a level of abstraction supported by TypeScript to improve the type-checking process, and not converted to JavaScript code.</p>
<p>Here's an example of an interface describing generic <strong>Text</strong> component:</p>
<pre><code class="language-ts">interface TextComponent {

    text: string;
    render(): void;

}
</code></pre>
<p>Now you can use the interface above to describe the requirement of having the <strong>text</strong> property that is a string and a <strong>render</strong> method:</p>
<pre><code class="language-ts">class PlainTextComponent implements TextComponent {

    text: string;

    render() {
        console.log('rendering plain text component');
    }

}
</code></pre>
<p>We are using <code>implements</code> keyword to wire class with a particular interface.
It is not important in what order class members are defined as long as all properties and methods the interface requires
are present and have required types.</p>
<p>Let's create another class that implements <code>TextComponent</code> interface partially:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent {
    text: string;
}
</code></pre>
<p>Upon compilation TypeScript will produce the following error:</p>
<pre><code class="language-text">error TS2420: Class 'RichTextComponent' incorrectly implements interface 'TextComponent'.
Property 'render' is missing in type 'RichTextComponent'.
</code></pre>
<p>You can use multiple interfaces delimited by a comma:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent, OnInit, OnDestroy {
    // ...
}
</code></pre>
<p>The example above shows a class that must implement three different interfaces to compile.</p>
<h2 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h2>
<p>Interfaces describe only requirements for classes; you cannot create an instance of the interface.
You need <code>abstract</code> classes un order to provide implementation details.</p>
<pre><code class="language-ts">abstract class PageComponent {

    abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Same as with interfaces you cannot create instances of abstract classes directly, only other classes derived from an abstract one.
Also, it is possible marking class methods as <code>abstract</code>.
Abstract methods do not contain implementation, and similar to <code>interface</code> methods provide requirements for derived classes.</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Note how <code>HomePageComponent</code> implements abstract <code>renderContent</code> that has access to <code>renderHeader</code> and <code>renderFooter</code> methods carried out in the parent class.</p>
<p>You can also use access modifiers with abstract methods.
The most frequent scenario is when methods need to be accessible only from within the child classes, and invisible from the outside:</p>
<p>For example:</p>
<pre><code class="language-ts">abstract class PageComponent {

    protected abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Now <code>HomePageComponent</code> can make <code>renderContent</code> protected like shown below:</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    constructor() {
        super();
        this.renderContent();
    }

    protected renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Any additional class that inherits (extends) <code>HomePageComponent</code> will still be able calling or redefining <code>renderContent</code> method.
But if you try accessing <code>renderContent</code> from outside the TypeScript should raise the following error:</p>
<pre><code class="language-ts">let homePage = new HomePageComponent();
homePage.renderContent();
// error TS2445: Property 'renderContent' is protected and only 
// accessible within class 'HomePageComponent' and its subclasses.
</code></pre>
<p>Abstract classes is a great way consolidating common functionality in a single place.</p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<p>TypeScript supports the concept of modules introduced in ES6.
Modules allow isolating code and data and help splitting functionality into logical groups.</p>
<p>One of the major features of ES6 (and TypeScript) modules is their file scope.
The code inside the module (classes, variables, functions, and other) does not pollute global scope
and is not accessible from the outside unless <code>exported</code> explicitly.</p>
<p>To share the code of the module with the outside world, you use <code>export</code> keyword:</p>
<pre><code class="language-ts">// module1.ts
export class TextBoxComponent {
  constructor(public text: string) {}
    
  render() {
    console.log(`Rendering '${this.text}' value.`);
  }
}
</code></pre>
<p>To use this code in your main application file or another module, you must import it first.
You import the <code>TextBoxComponent</code> class using <code>import</code> keyword:</p>
<pre><code class="language-ts">// app.ts
import { TextBoxComponent } from './module1'

let textBox = new TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="module-loaders"><a class="header" href="#module-loaders">Module Loaders</a></h3>
<p>ES6 and TypeScript rely on <code>module loaders</code> to locate files, resolve external dependencies and execute module files.</p>
<p>The most popular module loaders are:</p>
<ul>
<li>Server side
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used by Node.js)</li>
</ul>
</li>
<li>Client side
<ul>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li><a href="https://webpack.js.org/">Webpack</a></li>
</ul>
</li>
</ul>
<p>TypeScript supports different formats of generated JavaScript output.
You can instruct compiler to generate code adopted for multiple module loading systems using formats such as</p>
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used in Node.js)</li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li>UMD (Universal Module Definition)</li>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li>ES6 (or ECMAScript 2015)</li>
</ul>
<h3 id="running-at-server-side"><a class="header" href="#running-at-server-side">Running at server side</a></h3>
<p>You can test <code>TextBoxComponent</code> we have created earlier with node.js using <code>commonjs</code> module target:</p>
<pre><code class="language-sh">tsc app.ts --module commonjs
node app.js
</code></pre>
<p>When executed it produces the following output:</p>
<pre><code class="language-text">Rendering 'hello world' value.
</code></pre>
<p>TypeScript automatically compiles referenced modules.
It starts with <code>app.ts</code>, resolves and compiles <code>module1</code> as <code>module1.ts</code> file,
and produces two JavaScript files <code>app.js</code> and <code>module.js</code> that can be executed by node.js.</p>
<p>Here's an example of <code>app.js</code> file content:</p>
<pre><code class="language-js">&quot;use strict&quot;;
// app.ts
var module1_1 = require(&quot;./module1&quot;);
var textBox = new module1_1.TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="running-in-browser"><a class="header" href="#running-in-browser">Running in browser</a></h3>
<p>In order to run module-based application in browser you can take <code>SystemJS</code> loader:</p>
<pre><code class="language-html">&lt;script src=&quot;systemjs/dist/system.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  SystemJS.import('/app/app.js');
&lt;/script&gt;
</code></pre>
<p>Let's take a look at a simple TypeScript application that references an external module.</p>
<pre><code class="language-ts">// logger.ts
export class Logger {

  output: any;

  constructor(outputId: string) {
    this.output = document.getElementById(outputId);
  }

  info(message: string) {
    this.output.innerText = `INFO: ${message}`;
  }

}
</code></pre>
<p>Our simple <code>logger</code> is going to put a message as a content of the document element provided from the outside.</p>
<pre><code class="language-ts">// app.ts
import { Logger } from './logger';

let logger = new Logger('content');
logger.info('hello world');
</code></pre>
<p>The application needs to be compiled with SystemJS support to load correctly.
You can configure TypeScript to generate compatible JavaScript code by setting module code generation setting to <code>system</code>:</p>
<pre><code class="language-sh">tsc app.ts --module system
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find source code for the examples above in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/typescript/systemjs-example">typescript/systemjs-example</a>&quot; folder.</p>
</blockquote>
<p>To install dependencies, compile and run the demo use the following commands:</p>
<pre><code class="language-sh">npm install
npm start
</code></pre>
<p>Your default browser should run example page automatically.
Once the page gets loaded you should see an expected message:</p>
<pre><code class="language-text">INFO: hello world
</code></pre>
<h2 id="decorators"><a class="header" href="#decorators">Decorators</a></h2>
<p>TypeScript introduces <code>decorators</code> feature, metadata expressions similar to Java annotation tags or C# and Swift attributes.
ECMAScript does not yet have native support for annotating classes and class members (the feature is in the <code>proposal</code> state),
so <code>decorators</code> is an experimental TypeScript feature.</p>
<p>Decorators have a traditional notation of <code>@expression</code> where <code>expression</code> is the name of the function that should be invoked at runtime.</p>
<p>This function receives <code>decorated</code> target as a parameter and can be attached to:</p>
<ul>
<li>class declaration</li>
<li>method</li>
<li>accessor</li>
<li>property</li>
<li>parameter</li>
</ul>
<h3 id="class-decorators"><a class="header" href="#class-decorators">Class Decorators</a></h3>
<p>Class decorators are attached to class declarations.
At runtime, the function that backs the decorator gets applied to the class constructor.
That allows decorators inspecting, modifying or even replacing class instances if needed.</p>
<p>Here's a simple example of the <code>LogClass</code> decorator that outputs some log information every time being invoked:</p>
<pre><code class="language-ts">function LogClass(constructor: Function) {
    console.log('LogClass decorator executed for the constructor:');
    console.log(constructor);
}
</code></pre>
<p>Now you can use newly created decorator with different classes:</p>
<pre><code class="language-ts">@LogClass
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}
</code></pre>
<p>When a new instance of <code>TextWidget</code> class is created, the <code>@LogClass</code> attribute will be automatically invoked:</p>
<pre><code class="language-ts">let widget = new TextWidget();
widget.render();
</code></pre>
<p>The class decorator should produce the following output:</p>
<pre><code class="language-text">LogClass decorator executed for the constructor:
[Function: TextWidget]
Rendering text: default text
</code></pre>
<h4 id="decorators-with-parameters"><a class="header" href="#decorators-with-parameters">Decorators with parameters</a></h4>
<p>It is also possible passing values to decorators. You can achieve this with a feature known as <code>decorator factories</code>.
A <em>decorator factory</em> is a function returning an expression that is called at runtime:</p>
<p>Let's create another simple decorator with log output that accepts additional <code>prefix</code> and <code>suffix</code> settings:</p>
<pre><code class="language-ts">function LogClassWithParams(prefix: string, suffix: string) {
    return (constructor: Function) =&gt; {
        console.log(`
            ${prefix} 
            LogClassWithParams decorator called for: 
            ${constructor} 
            ${suffix}
        `);
    };
}
</code></pre>
<p>It can now be tested with the <code>TextWidget</code> class created earlier:</p>
<pre><code class="language-ts">@LogClassWithParams('BEGIN:', ':END')
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>You have marked <code>TextWidget</code> class with the <code>LogClassWithParams</code> decorator having a <code>prefix</code> and <code>suffix</code> properties
set to <code>BEGIN:</code> and <code>:END</code> values. The console output, in this case, should be:</p>
<pre><code class="language-text">BEGIN:
LogClassWithParams decorator called for: 
function TextWidget(text) {
    if (text === void 0) { text = 'default text'; }
        this.text = text;
    }
}
:END
</code></pre>
<h4 id="multiple-decorators"><a class="header" href="#multiple-decorators">Multiple decorators</a></h4>
<p>You are not limited to a single decorator per class.
TypeScript allows declaring as much class and member decorators as needed:</p>
<pre><code class="language-ts">@LogClass
@LogClassWithParams('BEGIN:', ':END')
@LogClassWithParams('[', ']')
class TextWidget {
    // ...
}
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
It means that first decorator that gets executed is:</p>
<pre><code class="language-ts">@LogClassWithParams('[', ']')
</code></pre>
<p>and the last decorator is going to be</p>
<pre><code class="language-ts">@LogClass
</code></pre>
<h3 id="method-decorators"><a class="header" href="#method-decorators">Method Decorators</a></h3>
<p>Method decorators are attached to class methods and can be used to inspect, modify or completely replace method definition of the class.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Let's create a decorator to inspect those parameters:</p>
<pre><code class="language-ts">function LogMethod(target: any, 
                   propertyKey: string, 
                   descriptor: PropertyDescriptor) {
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Below is an example of this decorator applied to a <code>render</code> method of <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethod
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>The console output in this case will be as following:</p>
<pre><code class="language-text">TextWidget { render: [Function] }
render
{ value: [Function],
  writable: true,
  enumerable: true,
  configurable: true }
Rendering text: default text
</code></pre>
<p>You can use <code>decorator factories</code> also with method decorators to support additional parameters.</p>
<pre><code class="language-ts">function LogMethodWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`${propertyKey}: ${message}`);
    };
}
</code></pre>
<p>This decorator can now be applied to methods. You can attach multiple decorators to a single method:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethodWithParams('hello')
    @LogMethodWithParams('world')
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
If you run the code the output should be as follows:</p>
<pre><code class="language-text">render: world
render: hello
Rendering text: default text
</code></pre>
<h3 id="accessor-decorators"><a class="header" href="#accessor-decorators">Accessor Decorators</a></h3>
<p>Accessor decorators are attached to property <code>getters</code> or <code>setters</code> and can be used to inspect, modify or completely replace accessor definition of the property.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Note that you can attach accessor decorator to either <code>getter</code> or <code>setter</code> but not both.
This restriction exists because on the low level decorators deal with
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Property Descriptors</a>
that contain both <code>get</code> and <code>set</code> accessors.</p>
<p>Let's create a decorator to inspect parameters:</p>
<pre><code class="language-ts">function LogAccessor(target: any, 
                     propertyKey: string, 
                     descriptor: PropertyDescriptor) {
    console.log('LogAccessor decorator called');
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Now the decorator can be applied to the following <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessor
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>Once invoked the decorator should produce the following output:</p>
<pre><code class="language-text">LogAccessor decorator called
TextWidget { text: [Getter/Setter] }
text
{ get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true }
</code></pre>
<p>Same as with class and method decorators you can use decorator factories feature to pass parameters to your accessor decorator.</p>
<pre><code class="language-ts">function LogAccessorWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`Message from decorator: ${message}`);
    }
}
</code></pre>
<p>TypeScript allows using more than one decorator given you attach it to the same property accessor:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    @LogAccessorWithParams('world')
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>The console output should be as shown below, note the right-to-left execution order:</p>
<pre><code class="language-text">Message from decorator: world
Message from decorator: hello
</code></pre>
<p>In case you declare decorator for both accessors TypeScript generates an error at compile time:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    get text(): string {
        return this._text;
    }
    
    @LogAccessorWithParams('world')
    set text(value: string) {
        this._text = value;
    }
}
</code></pre>
<pre><code class="language-text">error TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.
</code></pre>
<h3 id="property-decorators"><a class="header" href="#property-decorators">Property Decorators</a></h3>
<p>Property decorators are attached to class properties.
At runtime, property decorator receives the following arguments:</p>
<ul>
<li>target object</li>
<li>property name</li>
</ul>
<p>Due to technical limitations, it is not currently possible observing or modifying property initializers.
That is why property decorators do not get Property Descriptor value at runtime
and can be used mainly to observe a property with a particular name has been defined for a class.</p>
<p>Here's a simple property decorator to display parameters it gets at runtime:</p>
<pre><code class="language-ts">function LogProperty(target: any, propertyKey: string) {
    console.log('LogProperty decorator called');
    console.log(target);
    console.log(propertyKey);
}
</code></pre>
<pre><code class="language-ts">class TextWidget {

    @LogProperty
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        // ...
    }
}

let widget = new TextWidget('text1');
</code></pre>
<p>The output in this case should be as following:</p>
<pre><code class="language-text">LogProperty decorator called
TextWidget { render: [Function] }
id
</code></pre>
<h3 id="parameter-decorators"><a class="header" href="#parameter-decorators">Parameter Decorators</a></h3>
<p>Parameter decorators are attached to function parameters.
At runtime, every parameter decorator function is called with the following arguments:</p>
<ul>
<li>target</li>
<li>parameter name</li>
<li>parameter position index</li>
</ul>
<p>Due to technical limitations, it is possible only detecting that a particular parameter has been declared on a function.</p>
<p>Let's inspect runtime arguments with this simple parameter decorator:</p>
<pre><code class="language-ts">function LogParameter(target: any, 
                      parameterName: string, 
                      parameterIndex: number) {
    console.log('LogParameter decorator called');
    console.log(target);
    console.log(parameterName);
    console.log(parameterIndex);
}
</code></pre>
<p>You can now use this decorator with a class constructor and method parameters:</p>
<pre><code class="language-ts">class TextWidget {

    render(@LogParameter positionX: number, 
           @LogParameter positionY: number) {
        // ...
    }

}
</code></pre>
<p>Parameter decorators are also executed in right-to-left order.
So you should see console outputs for <code>positionY</code> and then <code>positionX</code>:</p>
<pre><code class="language-text">LogParameter decorator called
TextWidget { render: [Function] }
render
1
LogParameter decorator called
TextWidget { render: [Function] }
render
0
</code></pre>
<h1 id="angular-cli"><a class="header" href="#angular-cli">Angular CLI</a></h1>
<p>The <a href="https://cli.angular.io">Angular CLI</a> is a command line interface for Angular.</p>
<p><img src="images/cli-logo.png" alt="Angular CLI" /></p>
<p>As you might have noticed from the previous chapters, creating a project structure for a new web app may be a non-trivial task.
Working with multiple projects or frequently creating new ones may become extremely time-consuming
as you need configuring project structure again and again.</p>
<blockquote>
<p>The Angular CLI makes it easy to create an application that already works, right out of the box.
It already follows our best practices!</p>
</blockquote>
<p>This command line tool automates and simplifies many common scenarios, including:</p>
<ul>
<li>create new project structure from scratch with most optimal configuration out of the box</li>
<li>scaffold common Angular building blocks using one of the various blueprints (components, directives, pipes, services and other)</li>
<li>serving, watching and live reload</li>
<li>code linting</li>
<li>unit testing, code coverage reports, and end-to-end testing</li>
<li>development and production builds</li>
</ul>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<pre><code class="language-sh">npm install -g @angular/cli
</code></pre>
<p>The tool installs globally and is available via <code>ng</code> command.
Angular CLI supports lots of features; you can view details on available commands with the <code>help</code> command:</p>
<pre><code class="language-sh">ng help
</code></pre>
<h2 id="your-first-application"><a class="header" href="#your-first-application">Your First Application</a></h2>
<p>To create a new application you should use <code>ng new &lt;project-name&gt;</code> command:</p>
<pre><code class="language-sh">ng new my-first-app
</code></pre>
<p>The <code>ng</code> tool should produce console output similar to the following one:</p>
<pre><code class="language-text">installing ng
  create .editorconfig
  create README.md
  create src/app/app.component.css
  create src/app/app.component.html
  create src/app/app.component.spec.ts
  create src/app/app.component.ts
  create src/app/app.module.ts
  create src/assets/.gitkeep
  create src/environments/environment.prod.ts
  create src/environments/environment.ts
  create src/favicon.ico
  create src/index.html
  create src/main.ts
  create src/polyfills.ts
  create src/styles.css
  create src/test.ts
  create src/tsconfig.app.json
  create src/tsconfig.spec.json
  create src/typings.d.ts
  create .angular-cli.json
  create e2e/app.e2e-spec.ts
  create e2e/app.po.ts
  create e2e/tsconfig.e2e.json
  create .gitignore
  create karma.conf.js
  create package.json
  create protractor.conf.js
  create tsconfig.json
  create tslint.json
Successfully initialized git.
Installing packages for tooling via npm.
Installed packages for tooling via npm.
You can `ng set --global packageManager=yarn`.
Project 'my-first-app' successfully created.
</code></pre>
<p>The <code>scripts</code> section of the <code>package.json</code> file should point to <code>ng</code> tool for all the actions:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;ng&quot;: &quot;ng&quot;,
        &quot;start&quot;: &quot;ng serve&quot;,
        &quot;build&quot;: &quot;ng build&quot;,
        &quot;test&quot;: &quot;ng test&quot;,
        &quot;lint&quot;: &quot;ng lint&quot;,
        &quot;e2e&quot;: &quot;ng e2e&quot;
    }
}
</code></pre>
<h2 id="running-application"><a class="header" href="#running-application">Running Application</a></h2>
<p>Now switch to the newly generated <code>my-first-app</code> folder and launch the app:</p>
<pre><code class="language-sh">cd my-first-app/
ng serve
</code></pre>
<p>The <code>ng serve</code> command compiles and serves entire project using <code>webpack</code> bundler with an output similar to following:</p>
<pre><code class="language-text">** NG Live Development Server is running on http://localhost:4200 **
Hash: 2c5e702e0dbbc24e055c
Time: 10564ms
chunk    {0} polyfills.bundle.js, polyfills.bundle.js.map (polyfills) 158 kB {4} [initial] [rendered]
chunk    {1} main.bundle.js, main.bundle.js.map (main) 3.62 kB {3} [initial] [rendered]
chunk    {2} styles.bundle.js, styles.bundle.js.map (styles) 9.77 kB {4} [initial] [rendered]
chunk    {3} vendor.bundle.js, vendor.bundle.js.map (vendor) 2.37 MB [initial] [rendered]
chunk    {4} inline.bundle.js, inline.bundle.js.map (inline) 0 bytes [entry] [rendered]
webpack: Compiled successfully.
</code></pre>
<p>It is important to note that with <code>ng serve</code> you are going to run your project with <code>live development server</code>.
The server is going to watch for code changes, rebuild all affected bundles and reload the browser.</p>
<p>Now if you navigate to <code>http://localhost:4200</code> you should see the following default text:</p>
<pre><code class="language-text">app works!
</code></pre>
<p>Alternatively, you can run <code>serve</code> command with the <code>--open</code> switch to automatically open system browser with the application once compilation is complete:</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>It is also possible configuring default <code>host</code> and <code>port</code> settings:</p>
<pre><code class="language-sh">ng serve --host 0.0.0.0 --port 3000
</code></pre>
<p>The command above allows accessing your application from the local machine and local network via port 3000.</p>
<p>There are plenty of options and switches that can be used with <code>ng serve</code> command; you can refer to full details by calling <code>ng help</code>.</p>
<h2 id="code-linting"><a class="header" href="#code-linting">Code Linting</a></h2>
<p>Checking code is one of the essential steps.
Angular CLI ships with the TSLint support and predefined set of rules in the <code>tsconfig.json</code> file.</p>
<pre><code class="language-sh">ng lint
</code></pre>
<p>Default auto-generated project should contain no errors. You should see the following result in the console:</p>
<pre><code class="language-text">All files pass linting.
</code></pre>
<p>Let's try to ensure TSLint works as expected by modifying the <code>/src/app/app.component.ts</code> file.
Just change single quotes with double quotes like below:</p>
<pre><code class="language-ts">export class AppComponent {
  title = &quot;app works!&quot;;
}
</code></pre>
<p>Now running <code>ng lint</code> should produce next output:</p>
<pre><code class="language-text">src/app/app.component.ts[9, 11]: &quot; should be '
Lint errors found in the listed files.
</code></pre>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>You get a predefined unit testing configuration with every generated project.
By default, you are going to use <code>Karma</code> runner with the <code>Jasmine</code> test framework.</p>
<pre><code class="language-sh">ng test
</code></pre>
<p><img src="images/unit-tests.png" alt="Unit tests" /></p>
<p>Tests run in <code>watch</code> mode, meaning they automatically re-run upon code changes.</p>
<p><em>Please note that out-of-box configuration requires Google Chrome browser to run tests,
via the <code>karma-chrome-launcher</code> plugin.</em></p>
<p>As per Angular code style guides, all the unit test files reside next to the components tested.
The Angular CLI generates three dummy tests in the <code>src/app/app.component.spec.ts</code>:</p>
<pre><code class="language-ts">it('should create the app', async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  const app = fixture.debugElement.componentInstance;
  
  expect(app).toBeTruthy();
}));

it(`should have as title 'app works!'`, async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  const app = fixture.debugElement.componentInstance;
  
  expect(app.title).toEqual('app works!');
}));

it('should render title in a h1 tag', async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  fixture.detectChanges();
  
  const compiled = fixture.debugElement.nativeElement;
  expect(compiled.querySelector('h1').textContent).toContain('app works!');
}));
</code></pre>
<p>Let's check what happens when a test fails.</p>
<p>Append the following code to the end of the &quot;app.component.spec.ts&quot;:</p>
<pre><code class="language-ts">it('should fail', () =&gt; {
  expect(true).toBe(false);
});
</code></pre>
<p>Now if you run <code>ng test</code> once again you should see the following report:</p>
<p><img src="images/failed-test-details.png" alt="Failed test" /></p>
<p>There are two tabs on the page: <strong>Spec List</strong> and <strong>Failures</strong>.
You should see <strong>Failures</strong> by default but if there's more than one unit test failed you can check them on the <strong>Spec List</strong> page:</p>
<p><img src="images/failed-test-spec-list.png" alt="Spec List" /></p>
<p>If you do not plan to debug tests and just want to see a quick result of the test run just add <code>--single-run</code> switch to the <code>test</code> command:</p>
<pre><code class="language-sh">ng test --single-run
</code></pre>
<p>Developers typically use single run configurations for continuous integration (CI) scenarios.</p>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code Coverage</a></h2>
<p>You can generate a coverage report for your unit tests by adding <code>--code-coverage</code> switch to the <code>test</code> command:</p>
<pre><code class="language-sh">ng test --single-run --code-coverage
</code></pre>
<p>Under the hood the <code>ng</code> tool performs the following actions:</p>
<ul>
<li>compile the project with webpack, including TypeScript transpilation with source maps</li>
<li>use Karma runner and Jasmine to execute unit tests</li>
<li>remap code coverage report for JavaScript back to TypeScript</li>
<li>generate HTML report within <code>coverage</code> folder</li>
</ul>
<p>After testing finishes you can either open <code>coverage/index.html</code> with your favorite browser.</p>
<p>For example:</p>
<pre><code class="language-sh">open ./coverage/index.html
</code></pre>
<p>The command above should serve your coverage report and automatically launches default browser with the main page.</p>
<p><img src="images/code-coverage-main.png" alt="Code Coverage" /></p>
<p>Click the <code>src/app</code> and then <code>app.component.ts</code> to see TypeScript coverage:</p>
<p><img src="images/code-coverage-single-file.png" alt="Code Coverage for single file" /></p>
<h2 id="development-and-production-builds"><a class="header" href="#development-and-production-builds">Development and Production builds</a></h2>
<p>The Angular CLI supports producing both <code>development</code> and <code>production</code> using the <code>build</code> command:</p>
<pre><code class="language-sh">ng build
</code></pre>
<p>The format of the command is:</p>
<pre><code class="language-sh">ng build &lt;options...&gt;
</code></pre>
<p>By default it is running in <code>development</code> mode (an equivalent of <code>ng build -dev</code>) and produces output to the <code>dist/</code> folder.
You will get bundles together with source maps for better debugging:</p>
<table><thead><tr><th>File</th><th>Size</th></tr></thead><tbody>
<tr><td>favicon.ico</td><td>5430</td></tr>
<tr><td>index.html</td><td>613</td></tr>
<tr><td>inline.bundle.js</td><td>5764</td></tr>
<tr><td>inline.bundle.js.map</td><td>5824</td></tr>
<tr><td>main.bundle.js</td><td>6539</td></tr>
<tr><td>main.bundle.js.map</td><td>3817</td></tr>
<tr><td>polyfills.bundle.js</td><td>169209</td></tr>
<tr><td>polyfills.bundle.js.map</td><td>204535</td></tr>
<tr><td>styles.bundle.js</td><td>10039</td></tr>
<tr><td>styles.bundle.js.map</td><td>13372</td></tr>
<tr><td>vendor.bundle.js</td><td>2884505</td></tr>
<tr><td>vendor.bundle.js.map</td><td>3081499</td></tr>
</tbody></table>
<p>For production purposes you will want using the following command:</p>
<pre><code class="language-sh">ng build -prod
</code></pre>
<p>Which is an equivalent of the:</p>
<pre><code class="language-sh">ng build --target=production
</code></pre>
<p>This will give you much smaller output:</p>
<table><thead><tr><th>File</th><th>Size</th></tr></thead><tbody>
<tr><td>favicon.ico</td><td>5430</td></tr>
<tr><td>inline.d72284a6a83444350a39.bundle.js</td><td>1460</td></tr>
<tr><td>main.e088c8ce83e51568eb21.bundle.js</td><td>12163</td></tr>
<tr><td>polyfills.f52c146b4f7d1751829e.bundle.js</td><td>58138</td></tr>
<tr><td>styles.d41d8cd98f00b204e980.bundle.css</td><td>0</td></tr>
<tr><td>vendor.a2da17b9c49cdce7678a.bundle.js</td><td>362975</td></tr>
</tbody></table>
<p>Please note that <code>styles</code> bundle will be empty because by default newly generated app has <code>src/styles.css</code> file empty.</p>
<p>The <code>ng</code> tool removes <code>dist</code> folder between the builds so you should not worry about files left from previous builds and modes.</p>
<p>The content of the <code>dist</code> folder is everything you need to deploy your application to the remote server.
You can also use any web server of your choice to run the application in production.</p>
<p>For example:</p>
<ul>
<li>Nginx server</li>
<li>Tomcat server</li>
<li>IIS server</li>
<li>and many others</li>
</ul>
<p>In addition, you can deploy your application to any static pages host, like:</p>
<ul>
<li><a href="https://pages.github.com/">GitHub pages</a></li>
<li><a href="https://www.netlify.com/">Netlify</a></li>
<li>and many others</li>
</ul>
<p>It is still possible to use Angular CLI and embedded development server to test production builds.
You can use the following command to build the app in production mode and then run and open default browser to check it:</p>
<pre><code class="language-sh">ng serve --prod --open
</code></pre>
<h2 id="using-blueprints"><a class="header" href="#using-blueprints">Using blueprints</a></h2>
<p>Besides generating new application project structure, the <code>ng</code> tool supports creating core Angular building blocks
be means of <code>generate</code> (or <code>g</code>) command and several <code>blueprints</code>.</p>
<pre><code class="language-sh">ng generate &lt;blueprint&gt; &lt;options...&gt;
</code></pre>
<p>For the time being Angular CLI supports the following set of blueprints out-of-box:</p>
<table><thead><tr><th>Blueprint name</th><th>Command line usage</th></tr></thead><tbody>
<tr><td>Component</td><td>ng g component my-new-component</td></tr>
<tr><td>Directive</td><td>ng g directive my-new-directive</td></tr>
<tr><td>Pipe</td><td>ng g pipe my-new-pipe</td></tr>
<tr><td>Service</td><td>ng g service my-new-service</td></tr>
<tr><td>Class</td><td>ng g class my-new-class</td></tr>
<tr><td>Guard</td><td>ng g guard my-new-guard</td></tr>
<tr><td>Interface</td><td>ng g interface my-new-interface</td></tr>
<tr><td>Enum</td><td>ng g enum my-new-enum</td></tr>
<tr><td>Module</td><td>ng g module my-module</td></tr>
</tbody></table>
<p>Let's assume you have generated a new <code>my-first-app</code> like suggested below:</p>
<pre><code class="language-sh">ng new my-first-app
cd my-first-app
</code></pre>
<p>Now to create a new component, you should be using  the following command:</p>
<pre><code class="language-sh">ng g component my-first-component
</code></pre>
<p>The <code>ng</code> tool takes your current directory and creates all component related files:</p>
<pre><code class="language-text">installing component
  create src/app/my-first-component/my-first-component.component.css
  create src/app/my-first-component/my-first-component.component.html
  create src/app/my-first-component/my-first-component.component.spec.ts
  create src/app/my-first-component/my-first-component.component.ts
  update src/app/app.module.ts
</code></pre>
<p>If you are running <code>ng generate</code> command (or <code>ng g</code> by alias) from the root of your project,
the CLI should automatically put content to <code>src/app/&lt;feature&gt;</code> folder like shown above.</p>
<p>You can also specify additional folder structure that should become relative to <code>src/app</code> during generation.
All missing directories get created automatically.</p>
<p>Run the following command from the root project folder:</p>
<pre><code class="language-sh">ng g service services/simple-service
</code></pre>
<p>The <code>ng</code> tool creates <code>src/app/services</code> path and puts <code>simple-service</code> implementation there:</p>
<pre><code class="language-text">installing service
  create src/app/services/simple-service.service.spec.ts
  create src/app/services/simple-service.service.ts
  WARNING Service is generated but not provided, it must be provided to be used
</code></pre>
<p>Finally, you can change current directory and generate Angular artifacts there:</p>
<pre><code class="language-sh">mkdir src/app/directives
cd src/app/directives/
ng g directive my-first-directive
</code></pre>
<p>In this case, you should see get following output:</p>
<pre><code class="language-text">installing directive
  create src/app/directives/my-first-directive.directive.spec.ts
  create src/app/directives/my-first-directive.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>All blueprints follow common Angular code style guides.
You get a separate folder and all files one should expect when starting with a new Angular component:</p>
<ul>
<li>code file (<code>&lt;component&gt;.ts</code>)</li>
<li>external template file (<code>&lt;component&gt;.html</code>)</li>
<li>external css file (<code>&lt;component&gt;.css</code>)</li>
<li>unit test file (<code>&lt;component&gt;.spec.ts</code>)</li>
</ul>
<p>One of the best features of Angular CLI is that you do not get just placeholder files but a valid ready to use artefact and unit tests.
Let's peek inside <code>MyFirstComponent</code> component we have created earlier, and try integrating into the application.</p>
<pre><code class="language-ts">import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-my-first-component',
  templateUrl: './my-first-component.component.html',
  styleUrls: ['./my-first-component.component.css']
})
export class MyFirstComponentComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
</code></pre>
<p>You get <code>app-my-first-component</code> selector, external template and style,
together with a constructor and <code>OnInit</code> placeholder to save your time.</p>
<p>The stylesheet file (<strong>my-first-component.component.css</strong>) is empty by default,
and template file (<strong>my-first-component.component.html</strong>) contains the following simple layout:</p>
<pre><code class="language-html">&lt;p&gt;
  my-first-component works!
&lt;/p&gt;
</code></pre>
<p>The CLI will even update <code>src/app/app.module.ts</code> to include your newly created component into the application module:</p>
<pre><code class="language-ts">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppComponent } from './app.component';
import { MyFirstComponentComponent } from './my-first-component/my-first-component.component';

@NgModule({
  declarations: [
    AppComponent,
    MyFirstComponentComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>To test the generated component you can use main application template:</p>
<pre><code class="language-html">&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;app-my-first-component&gt;
&lt;/app-my-first-component&gt;
</code></pre>
<p>Finally, you can run development server if it is not running already:</p>
<pre><code class="language-sh">ng serve
</code></pre>
<p><img src="images/ng-cli-component.png" alt="Angular CLI component" /></p>
<p>As a starting point you also get a simple ready-to-run unit test for your component:</p>
<pre><code class="language-ts">import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyFirstComponentComponent } from './my-first-component.component';

describe('MyFirstComponentComponent', () =&gt; {
  let component: MyFirstComponentComponent;
  let fixture: ComponentFixture&lt;MyFirstComponentComponent&gt;;

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ MyFirstComponentComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyFirstComponentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () =&gt; {
    expect(component).toBeTruthy();
  });
});
</code></pre>
<p>As mentioned earlier you can run unit tests in <code>watch</code> mode with the help of <code>ng test</code> command:</p>
<p><img src="images/ng-cli-component-test.png" alt="Component Test" /></p>
<p>If you have added your component to the <code>app.component.html</code> template, some unit tests may fail.
To fix them you should update test configuration in <code>app.component.spec.ts</code>
and include your component into the test module:</p>
<pre><code class="language-ts">import { TestBed, async } from '@angular/core/testing';

import { AppComponent } from './app.component';
import { MyFirstComponentComponent } from './my-first-component/my-first-component.component';

describe('AppComponent', () =&gt; {
  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
        MyFirstComponentComponent
      ],
    }).compileComponents();
  }));

  ...
});
</code></pre>
<h2 id="creating-modules"><a class="header" href="#creating-modules">Creating Modules</a></h2>
<p>The Angular CLI tool also provides support for multiple modules
and generating entities that belong to the particular module.</p>
<p>Let's start by generating a new module using the next command:</p>
<pre><code class="language-sh">ng g module my-components
</code></pre>
<p>The output in the console should look similar to the following:</p>
<pre><code class="language-text">create src/app/my-components/my-components.module.ts (196 bytes)
</code></pre>
<p>And the content of the module contains a basic implementation like in the example below:</p>
<pre><code class="language-ts">// src/app/my-components/my-components.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: []
})
export class MyComponentsModule { }
</code></pre>
<p>Note that by default Angular creates a folder for your module, similar to what it does for components.
This is handy once you create components, services, directives and pipes that need to belongÂ to this module.
But if you want to put the resulting module in a single file next to the &quot;app.module.ts&quot; use the &quot;--flat&quot; switch.</p>
<pre><code class="language-sh">ng g module my-components --flat
</code></pre>
<p>In that case, the output will be:</p>
<pre><code class="language-text">create src/app/my-components.module.ts (196 bytes)
</code></pre>
<p>You can check more details on the available switches by running the &quot;ng g module --help&quot; command.</p>
<h3 id="assigning-components-to-modules"><a class="header" href="#assigning-components-to-modules">Assigning components to modules</a></h3>
<p>By default, Angular CLI appends all generated content to the main application module inside &quot;app.module.ts&quot;.
Once you have two or more modules in the application, the CLI will require the module name for every new content.</p>
<p>Try running the following command to see what happens:</p>
<pre><code class="language-sh">ng g component my-button-1
</code></pre>
<p>The output should be similar to the following one:</p>
<pre><code class="language-text">Error: More than one module matches.
Use skip-import option to skip importing the component into the closest module.
</code></pre>
<p>To include your new component into a particular module use the &quot;--module&quot; switch.
If you are building a shared module, you might also use the &quot;--export&quot; switch,
so that module exports your component besides declaration.</p>
<pre><code class="language-sh">ng g component my-button-1 --module=my-components --export
</code></pre>
<p>This time, you will get the following result:</p>
<pre><code class="language-text">  create src/app/my-button-1/my-button-1.component.css (0 bytes)
  create src/app/my-button-1/my-button-1.component.html (30 bytes)
  create src/app/my-button-1/my-button-1.component.spec.ts (651 bytes)
  create src/app/my-button-1/my-button-1.component.ts (287 bytes)
  update src/app/my-components.module.ts (321 bytes)
</code></pre>
<p>And the module content now looks like in the code example below:</p>
<pre><code class="language-ts">// src/app/my-components.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MyButton1Component } from './my-button-1/my-button-1.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [MyButton1Component],
  exports: [MyButton1Component]
})
export class MyComponentsModule { }
</code></pre>
<p>Do not forget to check the &quot;ng g component --help&quot; to see all available options.</p>
<p>You can also include your new module into some other existing module from the command line.</p>
<pre><code class="language-sh">ng g module my-feature --module=my-components --flat
</code></pre>
<p>As a result, the &quot;MyComponentsModule&quot; module will include &quot;MyFeatureModule&quot;:</p>
<pre><code class="language-ts">// src/app/my-components.module.ts

@NgModule({
  imports: [
    CommonModule,
    MyFeatureModule
  ],
  declarations: [MyButton1Component],
  exports: [MyButton1Component]
})
export class MyComponentsModule { }
</code></pre>
<h2 id="routing-support"><a class="header" href="#routing-support">Routing Support</a></h2>
<p>If you plan working with Angular Router or want to experiment with routing capabilities,
the Angular CLI can generate an application for you with initial Router support.</p>
<p>Use the &quot;--routing&quot; switch if you want to generate a routing module scaffold with your application.</p>
<pre><code class="language-sh">ng new my-app --routing
</code></pre>
<p>The routing scaffold should look similar to the one below:</p>
<pre><code class="language-ts">// src/app/app-routing.module.ts

import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
</code></pre>
<p>In addition, the main application component is going to contain the router outlet component:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<h2 id="generating-standalone-scripts"><a class="header" href="#generating-standalone-scripts">Generating Standalone Scripts</a></h2>
<p>The Angular CLI provides a special feature that allows detaching command line tools from the project,
and generating a set of scripts needed for standalone project compilation and testing:</p>
<pre><code class="language-sh">ng eject
</code></pre>
<p>Which is an equivalent for <code>ng eject -dev</code> or <code>ng eject --target=development</code>,
and instructs <code>ng</code> tool to use <code>development</code> configuration.
Alternatively, you can use <code>-prod</code> or <code>--target=production</code> switches to enable <code>production</code> mode.</p>
<p>Upon running <code>eject</code> command, the CLI will:</p>
<ul>
<li>update <code>package.json</code> with all dependencies needed to compile project without extra tools</li>
<li>generate and output the proper webpack configuration (<code>webpack.config.js</code>) and scripts for testing</li>
</ul>
<p>The tool might provide additional notes in the console output like below:</p>
<pre><code class="language-text">==============================================================
Ejection was successful.

To run your builds, you now need to do the following commands:
   - &quot;npm run build&quot; to build.
   - &quot;npm run test&quot; to run unit tests.
   - &quot;npm start&quot; to serve the app using webpack-dev-server.
   - &quot;npm run e2e&quot; to run protractor.

Running the equivalent CLI commands results in error.

==============================================================
Some packages were added. Please run &quot;npm install&quot;.
</code></pre>
<p>Now <code>scripts</code> section in your <code>package.json</code> file should link to local content for a <code>start</code>, <code>build</code> and various <code>test</code> scripts:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;ng&quot;: &quot;ng&quot;,
        &quot;start&quot;: &quot;webpack-dev-server --port=4200&quot;,
        &quot;build&quot;: &quot;webpack&quot;,
        &quot;test&quot;: &quot;karma start ./karma.conf.js&quot;,
        &quot;lint&quot;: &quot;ng lint&quot;,
        &quot;e2e&quot;: &quot;protractor ./protractor.conf.js&quot;,
        &quot;prepree2e&quot;: &quot;npm start&quot;,
        &quot;pree2e&quot;: &quot;webdriver-manager update --standalone false --gecko false --quiet&quot;
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-23X2CQXZ48', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
