<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Angular Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Angular Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="ch01-02-vscode.html"><strong aria-hidden="true">1.2.</strong> Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-es6.html"><strong aria-hidden="true">2.</strong> ES6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-classes.html"><strong aria-hidden="true">2.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch02-02-inheritance.html"><strong aria-hidden="true">2.2.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="ch02-03-arrow-functions.html"><strong aria-hidden="true">2.3.</strong> Arrow Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-template-literals.html"><strong aria-hidden="true">2.4.</strong> Template Literals</a></li><li class="chapter-item expanded "><a href="ch02-05-extended-parameters.html"><strong aria-hidden="true">2.5.</strong> Extended Parameter Handling</a></li><li class="chapter-item expanded "><a href="ch02-06-destructuring.html"><strong aria-hidden="true">2.6.</strong> Destructuring Assignment</a></li><li class="chapter-item expanded "><a href="ch02-07-modules.html"><strong aria-hidden="true">2.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch02-08-see-also.html"><strong aria-hidden="true">2.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-typescript.html"><strong aria-hidden="true">3.</strong> TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch03-02-features.html"><strong aria-hidden="true">3.2.</strong> TypeScript Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-03-types.html"><strong aria-hidden="true">3.2.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="ch03-04-classes.html"><strong aria-hidden="true">3.2.2.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch03-05-interfaces.html"><strong aria-hidden="true">3.2.3.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch03-06-abstract-classes.html"><strong aria-hidden="true">3.2.4.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="ch03-07-modules.html"><strong aria-hidden="true">3.2.5.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch03-08-decorators.html"><strong aria-hidden="true">3.2.6.</strong> Decorators</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-angular-cli.html"><strong aria-hidden="true">4.</strong> Angular CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-installing.html"><strong aria-hidden="true">4.1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="ch04-02-first-application.html"><strong aria-hidden="true">4.2.</strong> Your First Application</a></li><li class="chapter-item expanded "><a href="ch04-03-running-application.html"><strong aria-hidden="true">4.3.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="ch04-04-linting.html"><strong aria-hidden="true">4.4.</strong> Code Linting</a></li><li class="chapter-item expanded "><a href="ch04-05-testing.html"><strong aria-hidden="true">4.5.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="ch04-06-coverage.html"><strong aria-hidden="true">4.6.</strong> Code Coverage</a></li><li class="chapter-item expanded "><a href="ch04-07-development-and-production-builds.html"><strong aria-hidden="true">4.7.</strong> Development and Production Builds</a></li><li class="chapter-item expanded "><a href="ch04-08-using-blueprints.html"><strong aria-hidden="true">4.8.</strong> Using Blueprints</a></li><li class="chapter-item expanded "><a href="ch04-09-creating-modules.html"><strong aria-hidden="true">4.9.</strong> Creating Modules</a></li><li class="chapter-item expanded "><a href="ch04-10-routing-support.html"><strong aria-hidden="true">4.10.</strong> Routing Support</a></li><li class="chapter-item expanded "><a href="ch04-11-generating-standalone-scripts.html"><strong aria-hidden="true">4.11.</strong> Generating Standalone Scripts</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-angular.html"><strong aria-hidden="true">5.</strong> Angular</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-components.html"><strong aria-hidden="true">5.1.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-02-creating-a-simple-component.html"><strong aria-hidden="true">5.1.1.</strong> Creating a Simple Component</a></li><li class="chapter-item expanded "><a href="ch05-03-generating-components-with-angular-cli.html"><strong aria-hidden="true">5.1.2.</strong> Generating Components with Angular CLI</a></li><li class="chapter-item expanded "><a href="ch05-04-component-metadata.html"><strong aria-hidden="true">5.1.3.</strong> Component Metadata</a></li><li class="chapter-item expanded "><a href="ch05-05-templates.html"><strong aria-hidden="true">5.1.4.</strong> Templates</a></li><li class="chapter-item expanded "><a href="ch05-06-styles.html"><strong aria-hidden="true">5.1.5.</strong> Styles</a></li><li class="chapter-item expanded "><a href="ch05-07-input-properties.html"><strong aria-hidden="true">5.1.6.</strong> Input Properties</a></li><li class="chapter-item expanded "><a href="ch05-08-output-events.html"><strong aria-hidden="true">5.1.7.</strong> Output Events</a></li><li class="chapter-item expanded "><a href="ch05-09-providers.html"><strong aria-hidden="true">5.1.8.</strong> Providers</a></li><li class="chapter-item expanded "><a href="ch05-10-host.html"><strong aria-hidden="true">5.1.9.</strong> Host</a></li><li class="chapter-item expanded "><a href="ch05-11-queries.html"><strong aria-hidden="true">5.1.10.</strong> Queries</a></li><li class="chapter-item expanded "><a href="ch05-12-component-lifecycle.html"><strong aria-hidden="true">5.1.11.</strong> Component Lifecycle</a></li><li class="chapter-item expanded "><a href="ch05-13-content-projection.html"><strong aria-hidden="true">5.1.12.</strong> Content Projection</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-dependency-injection.html"><strong aria-hidden="true">5.2.</strong> Dependency Injection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-preparing-a-project.html"><strong aria-hidden="true">5.2.1.</strong> Preparing a Project</a></li><li class="chapter-item expanded "><a href="ch06-02-services.html"><strong aria-hidden="true">5.2.2.</strong> Services</a></li><li class="chapter-item expanded "><a href="ch06-03-providers.html"><strong aria-hidden="true">5.2.3.</strong> Providers</a></li><li class="chapter-item expanded "><a href="ch06-04-injection-tokens.html"><strong aria-hidden="true">5.2.4.</strong> Injection Tokens</a></li><li class="chapter-item expanded "><a href="ch06-05-injecting-multiple-instances.html"><strong aria-hidden="true">5.2.5.</strong> Injecting Multiple Instances</a></li><li class="chapter-item expanded "><a href="ch06-06-optional-dependencies.html"><strong aria-hidden="true">5.2.6.</strong> Optional Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-07-manual-injection.html"><strong aria-hidden="true">5.2.7.</strong> Manual Injection</a></li><li class="chapter-item expanded "><a href="ch06-08-summary.html"><strong aria-hidden="true">5.2.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-events.html"><strong aria-hidden="true">5.3.</strong> Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-component-events.html"><strong aria-hidden="true">5.3.1.</strong> Component Events</a></li><li class="chapter-item expanded "><a href="ch07-02-dom-events.html"><strong aria-hidden="true">5.3.2.</strong> DOM Events</a></li><li class="chapter-item expanded "><a href="ch07-03-service-events.html"><strong aria-hidden="true">5.3.3.</strong> Service Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-directives.html"><strong aria-hidden="true">5.4.</strong> Directives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-introduction-to-directives.html"><strong aria-hidden="true">5.4.1.</strong> Introduction to Directives</a></li><li class="chapter-item expanded "><a href="ch08-02-attribute-directives.html"><strong aria-hidden="true">5.4.2.</strong> Attribute Directives</a></li><li class="chapter-item expanded "><a href="ch08-03-structural-directives.html"><strong aria-hidden="true">5.4.3.</strong> Structural Directives</a></li><li class="chapter-item expanded "><a href="ch08-04-modifying-host-layout.html"><strong aria-hidden="true">5.4.4.</strong> Modifying Host Element Layout</a></li><li class="chapter-item expanded "><a href="ch08-05-walkthrough-upload-directive.html"><strong aria-hidden="true">5.4.5.</strong> Walkthrough: Upload Directive</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Pipes</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.1.</strong> Introduction to Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.2.</strong> Pipes with Parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.3.</strong> Chaining Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.4.</strong> Built-in Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.5.</strong> Custom Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.6.</strong> Pure And Impure Pipes</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Global Application Configuration</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.</strong> Preparing the Configuration File</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.2.</strong> Creating the Configuration Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.3.</strong> Loading Server-Side Configuration File</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.4.</strong> Registering Configuration Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.5.</strong> Using Configuration Settings</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Internationalisation (i18n)</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.1.</strong> Creating Translate Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.2.</strong> Creating Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.3.</strong> Using Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.4.</strong> Switching Languages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.5.</strong> Summary</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Reusable Component Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Creating new application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Creating component libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Building the packages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Publishing to NPM</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Advanced Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Dynamic Content in Angular</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Using with Docker</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Additional Resources</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Preparing new project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Creating Dockerfile</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Testing in a container</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> Creating docker-compose.yml</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.6.</strong> Consuming from Docker Hub</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.7.</strong> Automating with Travis</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.8.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Webpack</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Initial project structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Typescript configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Basic webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Advanced webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Unit testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Building a Mobile App with Cordova and Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Installing command-line tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Generating a new Angular App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Summary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Angular Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/DenysVuika/angular-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-angular-book"><a class="header" href="#the-angular-book">The Angular Book</a></h1>
<p><em>by Denys Vuika, with contributions from the Angular Community</em></p>
<p>This is the second and online edition of the <a href="https://leanpub.com/developing-with-angular">Developing with Angular</a> book.</p>
<blockquote>
<p>Note: this book is still in progress.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In the first few chapters, we are going to dwell on the basics you may need to understand Angular development better later on.</p>
<p>We are going to start with the main ES6 (ECMAScript 2015) features you should come across frequently when using TypeScript.</p>
<p>Next, the most remarkable TypeScript features you should get familiar before starting the Angular development.</p>
<p>After that, we are covering the Angular framework and supplemental toolings, like Angular CLI (Command Line Interface) and Webpack.</p>
<p>Finally, you should expect many practical topics that are addressing specific application requirements and scenarios,
including those coming from the community requests.</p>
<h2 id="book-progress"><a class="header" href="#book-progress">Book progress</a></h2>
<p>You can see the progress of the writing on this <a href="https://github.com/DenysVuika/angular-book/projects/1">GitHub board</a>.
Be sure to check the board if you want to see what's coming next or what is in progress right now.</p>
<h2 id="code-examples"><a class="header" href="#code-examples">Code examples</a></h2>
<p>You can find all code examples in this GitHub repository: <a href="https://github.com/DenysVuika/angular-book">angular-book</a>.
The source code gets frequently revisited and updated.</p>
<h2 id="feedback-bug-reports-and-suggestions"><a class="header" href="#feedback-bug-reports-and-suggestions">Feedback, Bug Reports and Suggestions</a></h2>
<p>If you have noticed a typo in the text or a bug in the code examples,
please don't hesitate and contact me using the next email address:
<a href="mailto:denys.vuika@gmail.com?subject=angular-book%20feedback">denys.vuika@gmail.com</a></p>
<p>You are also invited to raise issues for the source code and examples using corresponding <a href="https://github.com/DenysVuika/angular-book/issues">issue tracker</a> at GitHub.</p>
<p>Feel free to raise feature requests and suggestions on what you would like to see next.</p>
<h2 id="other-publications"><a class="header" href="#other-publications">Other publications</a></h2>
<p>You can find many other interesting publications at my <a href="https://denys.dev/">Blog</a>.</p>
<h2 id="testimonials"><a class="header" href="#testimonials">Testimonials</a></h2>
<p>Your feedback on the book content is very appreciated.
I would love to publish your photo and testimonial on the web page of the book.
Email me at: <a href="mailto:denys.vuika@gmail.com?subject=angular-book%20testimonial">denys.vuika@gmail.com</a>.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>In this chapter, we are going to configure the following applications and libraries:</p>
<ul>
<li>Node.js</li>
<li>Visual Studio Code</li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<p>Node.js is a JavaScript runtime built on <a href="https://developers.google.com/v8/">Chrome's V8 JavaScript engine</a>.
Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
Node.js' package ecosystem, <a href="https://www.npmjs.com/">npm</a>, is the largest ecosystem of open source libraries in the world.</p>
<p>Navigate to the <a href="https://nodejs.org/en/">main page</a>, download installer for your platform and follow setup instructions.</p>
<p>You can use the following commands to test current versions of the Node and NPM on your machine:</p>
<pre><code class="language-sh">node -v
# v14.16.0

npm -v
# 6.14.11
</code></pre>
<p>Please note that the actual versions may differ.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS.
It includes support for debugging, embedded Git control, syntax highlighting,
intelligent code completion, snippets, and code refactoring.</p>
<p><img src="images/vscode-mac-lg-2x.png" alt="vs code" /></p>
<h3 id="recommended-extensions"><a class="header" href="#recommended-extensions">Recommended extensions</a></h3>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint">TSLint</a></strong></p>
<p>Integrates the tslint linter for the TypeScript language into VS Code.</p>
<p>Launch VS Code Quick Open (⌘+P), paste the following command, and press enter.</p>
<pre><code class="language-sh">ext install tslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></strong></p>
<p>Integrates ESLint into VS Code. See <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">project page</a> for more details.</p>
<pre><code class="language-sh">ext install vscode-eslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig</a></strong></p>
<p>EditorConfig Support for Visual Studio Code</p>
<pre><code class="language-sh">ext install EditorConfig
</code></pre>
<h3 id="hiding-files"><a class="header" href="#hiding-files">Hiding files</a></h3>
<p>This step is optional.
In the code go to the <code>Preferences</code> -&gt; <code>Workspace Settings</code> and paste the following settings into the opened file:</p>
<pre><code class="language-json">{
    &quot;files.exclude&quot;: {
        &quot;**/.git&quot;: true,
        &quot;**/.DS_Store&quot;: true
    }
}
</code></pre>
<p>You can extend the list with the files, extensions or directories based on your preferences.</p>
<h1 id="es6"><a class="header" href="#es6">ES6</a></h1>
<p>ECMAScript 2015 (also known as ES6 and often referred to as <code>Harmony</code>) is the 6th major release of the ECMAScript language specification.</p>
<p>I am going to cover the most important features here to get you started with ES6 and then be able moving to TypeScript and Angular faster.</p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>The <code>class</code> syntax in JavaScript is not a new object-oriented inheritance model
but simply a syntactical sugar on top of the existing prototype-based inheritance.</p>
<p>Traditionally we have been using standard Objects and Prototypes like shown below:</p>
<pre><code class="language-js">var Widget = function(id, x, y) {
    this.id = id;
    this.setPosition(x, y);
}
Widget.prototype.setPosition = function(x, y) {
    this.x = x;
    this.y = y;
}
</code></pre>
<p>With class syntax developers get more natural and boilerplate-free result:</p>
<pre><code class="language-js">class Widget {
    constructor(id, x, y) {
        this.id = id;
        this.setPosition(x, y);
    }

    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
<p>The <code>constructor</code> function is automatically called when you create a new instance of <code>Widget</code>:</p>
<pre><code class="language-js">const myWidget = new Widget(1, 10, 20);
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>The <code>extends</code> keyword is used to define a class as a child of another class.
The following example demonstrates inheritance in practice:</p>
<pre><code class="language-js">class TextBox extends Widget {
    constructor (id, x, y, text) {
        super(id, x, y);
        this.text = text;
    }
}
</code></pre>
<p>We created a new <code>TextBox</code> class that is based on the <code>Widget</code> and adds additional <code>text</code> property.</p>
<p>Note that a base Widget constructor must also be called when a child class instantiated.
It must be the very first line of the child constructor implementation.</p>
<p>Here's another example:</p>
<pre><code class="language-js">class ImageBox extends Widget {
    constructor (id, x, y, width, height) {
        super(id, x, y);
        this.setSize(width, height);
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
    }

    reset() {
        this.setPosition(0, 0);
        this.setSize(0, 0);
    }
}
</code></pre>
<p><code>ImageBox</code> also inherits <code>Widget</code> class and adds size-related information alongside position.</p>
<p>Access to both classes is demonstrated with the <code>reset</code> function that calls <code>Widget.setPosition</code> and <code>ImageBox.setSize</code> functions.</p>
<h2 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h2>
<p>ES6 offers a shorter syntax for a <strong>function expression</strong> called <strong>arrow function</strong>, also known as <strong>fat arrow function</strong>.</p>
<p>Arrow functions provide more expressive closure syntax, simplify function scoping and change the way <code>this</code> is handled.</p>
<h3 id="expression-bodies"><a class="header" href="#expression-bodies">Expression Bodies</a></h3>
<p>When used as expressions bodies arrow functions work much like anonymous one-line <strong>lambdas</strong> that you can meet in many programming languages.</p>
<p>Let's filter a book collection to find something to read using both ES5 and ES6 to see the difference:</p>
<pre><code class="language-js">var books = [
    { name: 'Book 1', read: true },
    { name: 'Book 2' , read: false },
    { name: 'Book 3', read: true }
];

// ES5
var booksToRead = books.filter(function (b) { return !b.read });

// ES6
var booksToRead = books.filter(b =&gt; !b.read);
</code></pre>
<p>Curly brackets and <code>return</code> statement are not required if only one expression is present.</p>
<p>You could write the same example like following:</p>
<pre><code class="language-js">// ES6
let booksToRead = books.filter(b =&gt; { return !b.read; });
</code></pre>
<h3 id="statement-bodies"><a class="header" href="#statement-bodies">Statement Bodies</a></h3>
<p>Arrow functions provide more expressive closure syntax.</p>
<pre><code class="language-js">// ES6
// list the books I've read
books.forEach(b =&gt; {
    if (book.read) {
        console.log(b.name);
    }
});
</code></pre>
<p>And another example using DOM:</p>
<pre><code class="language-js">// ES6
let button = document.getElementById('submit-button');

button.addEventListener('click' () =&gt; {
    this.onButtonClicked();
});
</code></pre>
<p>Parameterless arrow functions are much easier to read</p>
<pre><code class="language-js">// ES6
setTimeout(_ =&gt; {
    console.log('First callback');
    setTimeout(_ =&gt; {
        console.log('Second callback');
    }, 1);
}, 1);
</code></pre>
<h3 id="lexical-this"><a class="header" href="#lexical-this">Lexical <em>this</em></a></h3>
<p>One of the best features of arrow functions in ES6 is the more intuitive handling of current object context.
These function expressions do not bind their variables:</p>
<ul>
<li>arguments</li>
<li>super</li>
<li>this</li>
<li>new.target</li>
</ul>
<pre><code class="language-js">// ES6
this.books.forEach(b =&gt; {
    if (!b.read) {
        this.booksToRead.push(b);
    }
});
</code></pre>
<p>There are multiple ways of doing the same with ECMAScript 5, and all of them involve manual context management</p>
<pre><code class="language-js">// ES5: using 'bind()'
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}).bind(this);

// ES5: referencing 'this' via variables
var self = this;

this.books.forEach(function(b) {
  if (!b.read) {
    self.booksToRead.push(b);
  }
});

// ES5: passing context if supported
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}, this);
</code></pre>
<p>As arrow functions do not create and bind their own <code>this</code> context the following code is concise and works as expected:</p>
<pre><code class="language-js">// ES6
function ProgressBar() {
  this.progress = 0;

  setInterval(() =&gt; {
    this.progress++;
  }, 1000);
}

const p = new ProgressBar();
</code></pre>
<p>In the example above <code>this</code> properly refers to the <code>ProgressBar</code> object.
Before ES6 you would most probably additional variables like <code>self</code>, <code>that</code>, and other.</p>
<pre><code class="language-js">// ES5
function ProgressBar() {
  var self = this;
  self.progress = 0;

  setInterval(function () {
    self.progress++;
  }, 1000);
}
</code></pre>
<h2 id="template-literals"><a class="header" href="#template-literals">Template Literals</a></h2>
<p>Template Literals (formerly called &quot;template strings&quot; in prior drafts of the ECMAScript 6 language specification) are string literals providing intuitive expression interpolation for single-line and multiline strings. </p>
<p>You use backticks to enclose a string literal and ${} to interpolate JavaScript variables or arbitrary expressions</p>
<pre><code class="language-js">// ES6
let point = { x: 10, y: 20 };

console.log(`Position is ${point.x}:${point.y}`);
// output: Position is 10:10
</code></pre>
<p>With ES5 you have to concatenate strings when dealing with multiple lines:</p>
<pre><code class="language-js">// ES5
var title = 'Title'
var component = {
  template: '' + 
    '&lt;h1&gt;' + title + '&lt;h1&gt;\n' +
    '&lt;div class=&quot;grid&quot;&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '&lt;/div&gt;'
}
</code></pre>
<p>Multi-line string creation with template literals becomes very clean and readable:</p>
<pre><code class="language-js">// ES6
let title = 'Title';
let component = {
  template: `
    &lt;h1&gt;${title}&lt;/h1&gt;
    &lt;div class=&quot;grid&quot;&gt;
      &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;col-6&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
}
</code></pre>
<h2 id="extended-parameter-handling"><a class="header" href="#extended-parameter-handling">Extended Parameter Handling</a></h2>
<p>ES6 brings improvements to parameter handling by introducing <code>default values</code>, <code>rest parameter</code> and <code>spread operator</code>.</p>
<h3 id="default-parameter-values"><a class="header" href="#default-parameter-values">Default Parameter Values</a></h3>
<p>Simple and intuitive default values for function parameters.</p>
<pre><code class="language-js">// ES6
function playSound(file, volume = 50) {
  console.log(`Playing '${file}' with volume ${volume}.`);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>With ES5 you have to check every parameter to be <code>undefined</code> and setting defaults manually if needed.</p>
<pre><code class="language-js">// ES5
function playSound(file, volume) {
    if (volume === undefined) {
        volume = 50;
    }
    console.log(&quot;Playing '&quot; + file + &quot;' with volume &quot; + volume);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>So support for <code>default parameter values</code> is a huge step forward and real time saver.</p>
<h3 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h3>
<p>In ES5, if you want your function to handle an indefinite or an arbitrary number of arguments,
you must use special <code>arguments</code> variable:</p>
<pre><code class="language-js">// ES5
function logMessages() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i]);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Which produces:</p>
<pre><code class="language-text">Hello,
world!
</code></pre>
<p>In ES6, you can aggregate all remaining arguments into a single function parameter</p>
<pre><code class="language-js">// ES6
function logMessages(...messages) {
  for (const message of messages) {
    console.log(message);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Also, that gives the same console output as before:</p>
<pre><code class="language-text">Hello, 
world!
</code></pre>
<p>Rest parameters become even more valuable when you need collecting arguments starting from a different position.</p>
<p>In the next example, the rest parameter is used to collect arguments from the second one to the end of the array.</p>
<pre><code class="language-js">// ES6
function greet(message, ...friends) {
  for (const friend of friends) {
    console.log(`${message}, ${friend}!`);
  }
}

greet('Hello', 'John', 'Joan', 'Bob')
</code></pre>
<p>The function above allows you to set the greeting message as the first parameter and array of friend names to generate messages.
The console output, in this case, should be:</p>
<pre><code class="language-text">Hello, John!
Hello, Joan!
Hello, Bob!
</code></pre>
<h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<p>Spread operator is used to expand an iterable collection into multiple arguments.</p>
<pre><code class="language-js">// ES6
let positive = [ 1, 2, 3 ];
let negative = [ -1, -2, -3 ]

let numbers = [...negative, 0, ...positive];

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<p>You can use spread operator even with strings:</p>
<pre><code class="language-js">// ES6
let message = 'Hello, world';
let chars = [...message];

console.log(chars);
// [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;,&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]
</code></pre>
<p>Spread operator easily becomes an alternative to the <code>Array.prototype.concat()</code> method.
With ES5 the example above will look like the following:</p>
<pre><code class="language-js">// ES5
var positive = [ 1, 2, 3 ];
var negative = [ -1, -2, -3 ];
var zero = [0];

var numbers = negative.concat(zero, positive);

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<h2 id="destructuring-assignment"><a class="header" href="#destructuring-assignment">Destructuring Assignment</a></h2>
<p>ES6 provides a way to extract values out of the objects or collections into the separate variables to access them easier in the code.
That is often called &quot;value unpacking&quot; or &quot;destructuring&quot;.</p>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic example</a></h3>
<p>As an example, you can extract a subset of values from the collection using the following format:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's create an array of words and extract the first couple of them into separate variables &quot;first&quot; and &quot;second&quot; like in the code below:</p>
<pre><code class="language-js">// ES6

let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second ] = words;

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<p>As you can see from the example above, you can extract a subset of an array and split it into multiple variables.</p>
<p>Without destructuring your code might look like the following:</p>
<pre><code class="language-js">// ES5

var words = [ 'this', 'is', 'hello', 'world', 'example' ];
var first = words[0];
var second = words[1];

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<h3 id="array-destructuring"><a class="header" href="#array-destructuring">Array destructuring</a></h3>
<p>You have already seen some of the array destructuring examples earlier in the section.
We enclose variables in square brackets using the following syntax:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Please note that you can also apply the same destructuring technique to the function call results:</p>
<pre><code class="language-js">// ES6

function getWords() {
    return [ 'this', 'is', 'hello', 'world', 'example' ];
}

let [ first, second ] = getWords();
console.log(`${first} ${second}`); // 'this is'
</code></pre>
<p>In addition to basic unpacking and variable assignment, several other things bring much value and reduce the code.</p>
<h4 id="value-assignment"><a class="header" href="#value-assignment">Value assignment</a></h4>
<p>The destructuring syntax can be used to assign values to variables instead of extracting them.
Take a look at the following example: </p>
<pre><code class="language-js">// ES6

let first, second;

[ first, second ] = [ 'hello', 'world' ];

console.log(first);  // 'hello'
console.log(second); // 'world'
</code></pre>
<h4 id="default-values"><a class="header" href="#default-values">Default values</a></h4>
<p>Another great feature of the array destructuring is default values.
There might be cases when the array has no values, and you want to provide some reasonable defaults.</p>
<p>The format of the syntax, in this case, is as follows:</p>
<pre><code class="language-text">let [ &lt;variable&gt; = &lt;value&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's see this feature in action:</p>
<pre><code class="language-js">// ES6

let words = [ 'hello' ];
let [ first = 'hey', second = 'there' ] = words;

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<p>The array we got initially does not contain two words.
We are trying to extract first two variables from it, and set 'hey' as the default value for the first word, and 'there' as a default for the second one.
At the runtime however only second variable stays with the default value.</p>
<p>Default value assignment is a compelling feature that helps you reduce the code for variable initialization and safety checks.
Below is how the same code could look like in ES5:</p>
<pre><code class="language-js">// ES5

var words = ['hello'];

var first = words[0];
if (!first) {
    first = 'hey';
}

var second = words[1];
if (!second) {
    second = 'there'
}

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<h4 id="swapping-values"><a class="header" href="#swapping-values">Swapping values</a></h4>
<p>Traditionally to swap two variables, developers need a third temporary one to hold the value of either first or second variable.</p>
<pre><code class="language-js">// ES5

var first = 'world';
var second = 'hello';

var temp = first;
first = second;
second = temp;

console.log(first + ' ' + second); // 'hello world'
</code></pre>
<p>With ES6 you can now reduce the code by using destructuring assignment syntax to swap variables in a single line like in the next example:</p>
<pre><code class="language-js">// ES6

let first = 'world';
let second = 'hello';

[ first, second ] = [ second, first ];

console.log(`${first} ${second}`); // 'hello world'
</code></pre>
<p>This feature may be a great time saver when it comes to sorting functions.</p>
<h4 id="skipping-values"><a class="header" href="#skipping-values">Skipping values</a></h4>
<p>We have been using examples that take the beginning of the array so far.<br />
The ES6 does not restrict you to that only scenario; it is also possible skipping values when unpacking or destructuring arrays.</p>
<pre><code class="language-text">let [ &lt;variable-1&gt;, , , , &lt;variable-X&gt; ] = &lt;array&gt;
</code></pre>
<p>You can just put the commas instead of variables like in the example below:</p>
<pre><code class="language-js">let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second, , , last ] = words;

console.log(`${first} ${second} ${last}`); // 'this is example'
</code></pre>
<h4 id="grouping-tail-values-into-a-single-variable"><a class="header" href="#grouping-tail-values-into-a-single-variable">Grouping tail values into a single variable</a></h4>
<p>As you see, the ES6 allows you to unpack the head of the array into separate variables.
Sometimes you may want to access the tail of the array as a single variable as well.</p>
<p>For this particular case, there's a special syntax that utilizes ES6 &quot;rest&quot; parameters.</p>
<pre><code class="language-text">let [ &lt;variable1&gt;, &lt;variable2&gt;, ...&lt;restVariable&gt; ] = &lt;array&gt;
</code></pre>
<p>We use &quot;rest parameter&quot; to define a variable to hold the tail of the array and below is an example of how to achieve this behavior:</p>
<pre><code class="language-js">let command = [ 'greet', 'user1', 'user2', 'user3' ];
let [ action, ...users ] = command;

console.log(action); // 'greet'
console.log(users);  // [ 'user1', 'user2', 'user3' ] 
</code></pre>
<h3 id="object-destructuring"><a class="header" href="#object-destructuring">Object destructuring</a></h3>
<p>Besides arrays and collections, you can use destructuring assignment syntax with the object instances as well.</p>
<p>We enclose variables in curly brackets using the following syntax:</p>
<pre><code class="language-text">let { &lt;var1&gt;, &lt;var2&gt; } = &lt;object&gt;
</code></pre>
<h4 id="unpacking-properties"><a class="header" href="#unpacking-properties">Unpacking properties</a></h4>
<p>ES6 allows you to extract properties by their names similar to how to unpack arrays.</p>
<p>Let's try to unpack a couple of properties from a user object:</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id, username } = obj;

console.log(id);        // '1'
console.log(username);  // 'jdoe'
</code></pre>
<h4 id="renaming-properties"><a class="header" href="#renaming-properties">Renaming properties</a></h4>
<p>You can also give destructured property an alias if you want to use it as a variable with a different name.</p>
<p>The syntax, in this case, is going to be as follows:</p>
<pre><code class="language-text">let { &lt;property&gt; : &lt;alias&gt; } = &lt;object&gt;;
</code></pre>
<p>Let's now rewrite our previous example to use custom property names.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id: uid, username: login } = obj;

console.log(uid);    // '1'
console.log(login);  // 'jdoe'
</code></pre>
<p>We are using &quot;uid&quot; and &quot;login&quot; instead of &quot;id&quot; and &quot;username&quot; properties this time.</p>
<h4 id="default-values-1"><a class="header" href="#default-values-1">Default values</a></h4>
<p>When applying property destructuring to the object properties, you can provide default values for missing properties.
That saves time for property checks and reduces coding efforts.</p>
<pre><code class="language-text">let { &lt;variable&gt; : &lt;value&gt; } = &lt;object&gt;
</code></pre>
<p>For example, let's provide a default value for the &quot;id&quot; property and also unpack the property &quot;role&quot;
that does not exist for the given object, and set it to be &quot;guest&quot; by default.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id = 0, role = 'guest' } = obj;

console.log(id);    // '1'
console.log(role);  // 'guest'
</code></pre>
<h4 id="unpacking-methods"><a class="header" href="#unpacking-methods">Unpacking methods</a></h4>
<p>You can extract object methods into separate variables and use them as shortcuts:</p>
<pre><code class="language-js">let { log } = console;
log('hello world');
</code></pre>
<p>The example above demonstrates a &quot;console.log&quot; method being extracted into the &quot;log&quot; variable and used separately.</p>
<p>We utilise the following syntax:</p>
<pre><code class="language-text">let { &lt;method&gt; } = &lt;object&gt;
</code></pre>
<p>Next, let's create a custom class and export multiple methods:</p>
<pre><code class="language-js">// ES6

class MyClass {

  sayHello(message) {
    console.log(`Hello, ${message}`);
  }

  sayBye(message) {
    console.log(`Bye, ${message}`);
  }

}

let myClass = new MyClass();
let { sayHello, sayBye } = myClass;

sayHello('how are you?');  // 'Hello, how are you?'
sayBye('see you soon.');   // 'Bye, see you soon'
</code></pre>
<h4 id="renaming-methods"><a class="header" href="#renaming-methods">Renaming methods</a></h4>
<p>You can also rename destructured methods if needed. The following syntax should be used to give the unpacked method a custom name:</p>
<pre><code class="language-text">let { &lt;method&gt; : &lt;alias&gt; } = &lt;object&gt;
</code></pre>
<p>Let's update the &quot;MyClass&quot; we used earlier and rename &quot;sayHello&quot; and &quot;sayBye&quot; methods to just &quot;hello&quot; and &quot;bye&quot;:</p>
<pre><code class="language-js">let myClass = new MyClass();
let { sayHello: hello, sayBye: bye } = myClass;

hello('how are you?');  // Hello, how are you?
bye('see you soon');    // Bye, see you soon
</code></pre>
<h3 id="using-with-function-parameters"><a class="header" href="#using-with-function-parameters">Using with function parameters</a></h3>
<p>The best scenario for using destructuring with objects and functions is default parameter values and options.</p>
<p>First, let's reproduce the most common use case for the &quot;options&quot; parameter passed to a function or object member:</p>
<pre><code class="language-js">// ES5

function showDialog(options) {
  options = options || {};
  var message = options.message || 'Unknown message';
  var size = options.size || { width: 400, height: 400 };
  var position = options.position || { x: 200, y: 300 };

  console.log('message: ' + message);
  console.log('size: ' + size.width + ':' + size.height);
  console.log('position: ' + position.x + ':' + position.y);
}
</code></pre>
<p>Above is the simplified version of the custom options management that has been very popular for years.
We provide a JavaScript object as an &quot;options&quot; parameter, and function does parsing and detecting missing properties to initialize default values if needed.</p>
<p>Depending on the size of the options object there might be many checks just to set the default values for them.
Especially if there are nested objects with own properties, like &quot;size&quot; and &quot;position&quot; in our case.</p>
<p>Now, if you call the &quot;showDialog&quot; function with no parameters except the &quot;message&quot; value, the output should be similar to the following one:</p>
<pre><code class="language-js">showDialog({ 
    message: 'hello world' 
});

// message: hello world
// size: 400:400
// position: 200:300
</code></pre>
<p>Next, try to call the same function with a partial set of options, for instance, the &quot;size&quot; settings:</p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<p>Now you can rewrite the &quot;showDialog&quot; implementation to use destructuring with default values like in the next example:</p>
<pre><code class="language-js">// ES6

function showDialog({ 
  message = 'Message', 
  size = { width: 400, height: 400 },
  position = { x: 200, y: 300 } }) {

  console.log(`message: ${message}`);
  console.log(`size: ${size.width}:${size.height}`);
  console.log(`position: ${position.x}:${position.y}`);
}
</code></pre>
<p>Notice how we use the destructuring assignment syntax to declare a function parameter. </p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<h4 id="ide-support"><a class="header" href="#ide-support">IDE support</a></h4>
<p>Many modern IDEs already provide support for destructuring syntax within function or method parameters. <a href="https://code.visualstudio.com/">VS Code</a>, for instance, provides auto-completion both for function calls and for nested properties.</p>
<p><img src="images/es6-desctructuring-01.png" alt="" /></p>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Before ES6 developers traditionally were using <code>Revealing Module</code> pattern to emulate modules in JavaScript.</p>
<p>The basic concept of a Revealing Module is that you use <code>closures</code> (self-invoking functions)
with an <code>Object</code> which encapsulates its data and behavior.</p>
<pre><code class="language-js">// ES5
var Module = (function() {
    var privateMethod = function() {
        // do something 
        console.log('private method called');
    };

    return {
        x: 10,
        name: 'some name',
        publicMethod: function() {
            // do something
            console.log('public method called');
            privateMethod();
        }
    };
})();

Module.publicMethod()
</code></pre>
<p>You should get the following output to browser console:</p>
<pre><code class="language-text">public method called
private method called
</code></pre>
<p>I recommend also reading an excellent article &quot;<a href="https://toddmotto.com/mastering-the-module-pattern/">Mastering the Module Pattern</a>&quot; by Todd Motto to get deep coverage of <strong>Revealing Module</strong> pattern in JavaScript.</p>
<p>The rise of module systems based on either AMD or CommonJS syntax has mostly replaced revealing modules and other hand-written solutions in ES5.</p>
<h3 id="exporting-and-importing-values"><a class="header" href="#exporting-and-importing-values">Exporting and Importing Values</a></h3>
<p>ECMAScript 6 provides a long-needed support for exporting and importing values from/to modules without global namespace pollution.</p>
<pre><code class="language-js">// ES6

// module lib/logger.js
export function log (message) { console.log(message); };
export var defaultErrorMessage = 'Aw, Snap!';

//  myApp.js
import * as logger from &quot;lib/logger&quot;;
logger.log(logger.defaultErrorMessage);

//  anotherApp.js
import { log, defaultErrorMessage } from &quot;lib/logger&quot;;
log(defaultErrorMessage);
</code></pre>
<p>Here's how the same approach would look like if written with ECMAScript 5:</p>
<pre><code class="language-js">// ES5

// lib/logger.js
LoggerLib = {};
LoggerLib.log = function(message) { console.log(message); };
LoggerLib.defaultErrorMessage = 'Aw, Snap!';

// myApp.js
var logger = LoggerLib;
logger.log(logger.defaultErrorMessage);

// anotherApp.js
var log = LoggerLib.log;
var defaultErrorMessage = LoggerLib.defaultErrorMessage;
log(defaultErrorMessage);
</code></pre>
<h3 id="default-values-2"><a class="header" href="#default-values-2">Default Values</a></h3>
<p>You can make your ES6 module exporting some value as <code>default</code> one.</p>
<pre><code class="language-js">// ES6

// lib/logger.js
export default (message) =&gt; console.log(message);

// app.js
import output from 'lib/logger';
output('hello world');
</code></pre>
<h3 id="wildcard-export"><a class="header" href="#wildcard-export">Wildcard Export</a></h3>
<p>Another great feature of ES6 modules is support for wildcard-based export of values.
That becomes handy if you are creating a composite module that re-exports values from other modules.</p>
<pre><code class="language-js">// ES6

// lib/complex-module.js
export * from 'lib/logger';
export * from 'lib/http';
export * from 'lib/utils';

// app.js
import { logger, httpClient, stringUtils } from 'lib/complex-module';
logger.log('hello from logger');
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="http://es6-features.org/">ECMAScript 6 — New Features: Overview &amp; Comparison</a></li>
</ul>
<h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h2 id="getting-started-with-typescript"><a class="header" href="#getting-started-with-typescript">Getting Started with TypeScript</a></h2>
<h3 id="installing-typescript"><a class="header" href="#installing-typescript">Installing TypeScript</a></h3>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h3 id="using-tsc"><a class="header" href="#using-tsc">Using tsc</a></h3>
<p>In your code editor create a file <code>logger.ts</code> with the following content:</p>
<pre><code class="language-js">function log(message) {
    console.log(message);
}

log('Hello, world!');
</code></pre>
<p>Now you can use a command line to compile your source code to ES5 with <code>tsc</code> tool and run it with <code>node.js</code>:</p>
<pre><code class="language-sh">tsc logger.ts
node logger.js
</code></pre>
<p>TypeScript compiler takes <code>logger.ts</code> file, processes it and produces a JavaScript output to <code>logger.js</code>.
At this point, the <code>.js</code> file is ready to be used with an HTML page or executed by node.js.</p>
<p>You should see the following output in the command line:</p>
<pre><code class="language-text">Hello, world!
</code></pre>
<p>Now let's see how type validation works.
Add <code>string</code> type annotation for the <code>log</code> function and call it with a <code>number</code>.</p>
<pre><code class="language-ts">function log(message: string) {
    console.log(message);
}

log(0);
</code></pre>
<p>If you compile <code>logger.ts</code> once again <code>tsc</code> should produce an error:</p>
<pre><code class="language-sh">tsc logger.ts
&gt; logger.ts(5,5): error TS2345: Argument of type '0' is not assignable to parameter
of type 'string'.
</code></pre>
<h3 id="typings"><a class="header" href="#typings">Typings</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h3 id="linting"><a class="header" href="#linting">Linting</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h4 id="tslint"><a class="header" href="#tslint">TSLint</a></h4>
<blockquote>
<p>TSLint checks your TypeScript code for readability, maintainability, and functionality errors.</p>
</blockquote>
<pre><code class="language-sh">npm install -g tslint
</code></pre>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h2 id="typescript-features"><a class="header" href="#typescript-features">TypeScript Features</a></h2>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/4">todo: Needs introduction</a></em></p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>TypeScript supports all the types used in JavaScript:</p>
<ul>
<li><strong>boolean</strong></li>
<li><strong>number</strong></li>
<li><strong>string</strong></li>
<li><strong>arrays</strong></li>
</ul>
<p>TypeScript also adds the following types:</p>
<ul>
<li><strong>enum</strong></li>
<li><strong>any</strong></li>
<li><strong>void</strong></li>
</ul>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<h4 id="boolean"><a class="header" href="#boolean">Boolean</a></h4>
<p>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a boolean value.</p>
<pre><code class="language-ts">let isEnabled: boolean = true;
</code></pre>
<p>Assigning non-Boolean value to the variable will produce an error.</p>
<pre><code class="language-ts">isEnabled = 'YES';
// logger.ts(2,1): error TS2322: Type '&quot;YES&quot;' is not assignable to type 'boolean'.
</code></pre>
<p>It is also possible annotating function or method return types.</p>
<pre><code class="language-ts">function isEmpty(str: string): boolean {
    return !str;
}
</code></pre>
<h4 id="number"><a class="header" href="#number">Number</a></h4>
<p>TypeScript maps all JavaScript numbers to the <code>number</code> type:</p>
<ul>
<li>floating point numbers (default JavaScript type for all numbers)</li>
<li>decimal numbers</li>
<li>hexadecimal numbers</li>
<li>binary literals (ES6)</li>
<li>octal literals (ES6)</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-ts">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>Typescript supports ES6 <strong>template literals</strong> (formerly known as <strong>template strings</strong>).</p>
<p>As in ECMAScript 6, you use backticks (`) to enclose a string literal and <strong>${}</strong> to interpolate JavaScript variables or arbitrary expressions.</p>
<p>Either double quotes (&quot;) or single quotes (') can be used to surround string data.</p>
<pre><code class="language-ts">let firstName: string = &quot;Joan&quot;;
let lastName: string = 'Doe';
let fullName: string = `${firstName} ${lastName}`;
let template: string = `
    &lt;h1&gt;Title&lt;h1&gt;
    &lt;p&gt;Hello, ${fullName}&lt;/p&gt;
`;
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>There are two main ways you can provide type definition for arrays of values in TypeScript:</p>
<pre><code class="language-ts">let arr1: string[] = [];
let arr2: Array&lt;string&gt; = new Array();
</code></pre>
<p>You can also initialize arrays upon declaring them:</p>
<pre><code class="language-ts">let arr1: string[] = ['hello', 'world'];
let arr2: Array&lt;string&gt; = ['hello', 'world'];

let flags1: boolean[] = [true, false, true, false];
let flags2: boolean[] = new Array(false, true);
</code></pre>
<p>As in JavaScript arrays, you can <strong>push</strong> elements and access them by <strong>index</strong></p>
<pre><code class="language-ts">let users: string[] = [];

users.push('user1');

console.log(`First user: ${users[0]}`);
</code></pre>
<p>The sample above demonstrates array element access together with string interpolation.
When executed it should produce:</p>
<pre><code class="language-text">First user: user1
</code></pre>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<p>TypeScript provides support for an <strong>enumerated type</strong> known in many languages (Swift, C#, Java, C, and others).
This data type consists of a set of named values mapped to numbers.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

let s: Suit = Suit.Spade;
</code></pre>
<p>By default numbering of enum members starts with 0 and increments by one.
You have full control of the values if needed.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };
enum Suit { Club = 1, Diamond = 2, Heart = 4, Spade = 8 }
</code></pre>
<p>Another valuable feature is accessing by a numeric value.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

console.log(Suit[0]); // Club
</code></pre>
<p>It must be noted however that you access names by the numeric values, not by an array index as it may seem.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };

console.log(Suit[0]); // undefined
console.log(Suit[1]); // Club
</code></pre>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p>A special <strong>any</strong> type is used to opt-out of the TypeScript type-checking process and addresses the following cases:</p>
<ul>
<li>dynamic content (objects created on the fly)</li>
<li>3rd party libraries (having no TypeScript support via definition files)</li>
</ul>
<pre><code class="language-ts">let obj: any = {
    log(message) {
        console.log(message);
    }
};
obj.log('hello world');
</code></pre>
<p>Please note that by opting-out of the type-checking process you take full responsibility for safety checks,
as now TypeScript compiler is not able to verify the code at compile time.</p>
<p>The following example shows valid TypeScript code:</p>
<pre><code class="language-ts">obj.log('hello world'); 
obj.helloWorld('log');
</code></pre>
<p>However, at runtime the second line causes a TypeError exception:</p>
<pre><code class="language-text">hello world
TypeError: obj.helloWorld is not a function
</code></pre>
<p>So it is recommended using <strong>any</strong> type only where necessary.</p>
<h3 id="void"><a class="header" href="#void">Void</a></h3>
<p>The <strong>void</strong> type is used to declare a function does not return any value explicitly.</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
        return true;
    }

}
</code></pre>
<p>If you try compiling the code above you should get an error:</p>
<pre><code class="language-text">error TS2322: Type 'true' is not assignable to type 'void'.
</code></pre>
<p>You can fix the type-check error by removing <strong>return</strong> statement from the <strong>log</strong> method:</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
    }

}
</code></pre>
<p>You might also be using <strong>void</strong> types as function parameters or with <strong>Interfaces</strong>:</p>
<pre><code class="language-ts">function fn(x: () =&gt; void) {
  x();
}

interface Logger {

  log(message: string): void;
  warn(message: string): void;
  error(message: string): void;

}
</code></pre>
<p><em>You will get more information on <strong>Interfaces</strong> later in this book.</em></p>
<h2 id="classes-1"><a class="header" href="#classes-1">Classes</a></h2>
<p>TypeScript provides support for classes introduced with ES6 (ECMAScript 2015) and adds a set of features to improve object-oriented development.</p>
<pre><code class="language-ts">class Widget {

    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        console.log(`Rendering widget &quot;${this.id}&quot;`);
    }

}

let widget = new Widget('text1');
widget.render();
</code></pre>
<p>You should get the following output when executed:</p>
<pre><code class="language-text">Rendering widget &quot;text1&quot;
</code></pre>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>With ES6 you define class properties from with the class constructor:</p>
<pre><code class="language-js">// ES6
class Widget {

    constructor(id) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }

}
</code></pre>
<p>If you try compiling example above with <code>tsc</code> utility (TypeScript compiler) you should get the following errors:</p>
<pre><code class="language-text">error TS2339: Property 'id' does not exist on type 'Widget'.
error TS2339: Property 'x' does not exist on type 'Widget'.
error TS2339: Property 'y' does not exist on type 'Widget'.
</code></pre>
<p>The errors are raised because TypeScript requires you to define properties separately.
It is needed to enable many other features TypeScript provides.</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number;
    x: number;

    constructor(id: string) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }
}
</code></pre>
<p>Properties in TypeScript can have default values:</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number = 0;
    x: number = 0;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<h3 id="setters-and-getters"><a class="header" href="#setters-and-getters">Setters and Getters</a></h3>
<p>TypeScript supports <em>computed properties</em>, which do not store a value.
Instead, they provide <em>getters</em> and <em>setters</em> to retrieve and assign values in a controlled way.</p>
<p><strong>TBD</strong>: describe get/set format</p>
<p>One of the common cases for a <em>getter</em> is computing a return value based on other property values:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}

let user = new User('Joan', 'Doe');
console.log(`User full name is: ${user.fullName}`);
</code></pre>
<p>If you save this example to file <code>script.ts</code>, compile it and run like shown below:</p>
<pre><code class="language-sh">tsc --target ES6 script.ts
node script.js
</code></pre>
<p>You should see the output with the full username as expected:</p>
<pre><code class="language-text">User full name is: Joan Doe
</code></pre>
<p>Now let's introduce a simple <em>setter</em> for the <code>firstName</code> property.</p>
<p>Every time a new property value is set we are going to remove leading and trailing white space.
Such values as &quot; Joan&quot; and &quot;Joan  &quot; are automatically converted to &quot;Joan&quot;.</p>
<pre><code class="language-ts">class User {

    private _firstName: string;

    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        if (value) {
            this._firstName = value.trim();
        }
    }
}

let user = new User();
user.firstName = '  Joan   ';
console.log(`The first name is &quot;${user.firstName}&quot;.`);
</code></pre>
<p>The console output, in this case, should be:</p>
<pre><code class="language-text">The first name is &quot;Joan&quot;.
</code></pre>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>Methods are functions that operate on a class object and are bound to an instance of that object.
You can use <code>this</code> keyword to access properties and call other methods like in the example below:</p>
<pre><code class="language-ts">class Sprite {

    x: number;
    y: number;

    render() {
        console.log(`rendering widget at ${this.x}:${this.y}`);
    }
    
    moveTo(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.render();
    }

}

let sprite = new Sprite();
sprite.moveTo(5, 10);
// rendering widget at 5:10
</code></pre>
<h4 id="return-values"><a class="header" href="#return-values">Return values</a></h4>
<pre><code class="language-ts">class NumberWidget {

    getId(): string {
        return 'number1';
    }

    getValue(): number {
        return 10;
    }

}
</code></pre>
<p>You can use a <code>void</code> type if the method does not return any value.</p>
<pre><code class="language-ts">class TextWidget {

    text: string;

    reset(): void {
        this.text = '';
    }

}
</code></pre>
<h4 id="method-parameters"><a class="header" href="#method-parameters">Method parameters</a></h4>
<p>You can add types to each parameter of the method.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level: number) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>TypeScript will automatically perform type checking at compile time.
Let's try providing a string value for the <code>level</code> parameter:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 'not a number');
</code></pre>
<p>You should get a compile error with the following message:</p>
<pre><code class="language-text">error TS2345: Argument of type '&quot;string&quot;' is not assignable to parameter of type 'number'.
</code></pre>
<p>Now let's change <code>level</code> parameter to a number to fix compilation</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 2);
</code></pre>
<p>Now we should get the expected output:</p>
<pre><code class="language-text">(2): test
</code></pre>
<h4 id="optional-parameters"><a class="header" href="#optional-parameters">Optional parameters</a></h4>
<p>By default, all method/function parameters in TypeScript are <code>required</code>.
However, it is possible making parameters optional by appending <strong>?</strong> (question mark) symbol to the parameter name.</p>
<p>Let's update our <code>Logger</code> class and make <code>level</code> parameter optional.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level?: number) {
        if (level === undefined) {
            level = 1;
        }
        console.log(`(${level}): ${message}`);
    }

}

let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The <code>log</code> method provides default value automatically if <code>level</code> is omitted.</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<p>Please note that optional parameters must always follow required ones.</p>
<h4 id="default-parameters"><a class="header" href="#default-parameters">Default parameters</a></h4>
<p>TypeScript also supports default values for parameters.
Instead of checking every parameter for <code>undefined</code> value you can provide defaults directly within the method declaration:</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string = 'Unknown error', level: number = 1) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>Let's try calling <code>log</code> without any parameters:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The output, in this case, should be:</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<h4 id="rest-parameters-and-spread-operator"><a class="header" href="#rest-parameters-and-spread-operator">Rest Parameters and Spread Operator</a></h4>
<p>In TypeScript, you can gather multiple arguments into a single variable known as <em>rest parameter</em>.
Rest parameters were introduced as part of ES6, and TypesScripts extends them with type checking support.</p>
<pre><code class="language-ts">class Logger {

    showErrors(...errors: string[]) {
        for (let err of errors) {
            console.error(err);
        }
    }

}
</code></pre>
<p>Now you can provide an arbitrary number of arguments for <code>showErrors</code> method:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.showErrors('Something', 'went', 'wrong');
</code></pre>
<p>That should produce three errors as an output:</p>
<pre><code class="language-text">Something
went
wrong
</code></pre>
<p><em>Rest parameters</em> in TypeScript work great with <em>Spread Operator</em> allowing you to expand a collection into multiple arguments.
It is also possible mixing regular parameters with <em>spread</em> ones:</p>
<pre><code class="language-ts">let logger = new Logger();
let messages = ['something', 'went', 'wrong'];

logger.showErrors('Error', ...messages, '!');
</code></pre>
<p>In the example above we compose a collection of arguments from arbitrary parameters and content of the <code>messages</code> array in the middle.</p>
<p>The <code>showErrors</code> method should handle all entries correctly and produce the following output:</p>
<pre><code class="language-text">Error
something
went
wrong
!
</code></pre>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Constructors in TypeScript got same features as methods.
You can have default and optional parameters, use rest parameters and spread operators with class constructor functions.</p>
<p>Besides, TypeScript provides support for automatic property creation based on constructor parameters.
Let's create a typical <code>User</code> class implementation:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}
</code></pre>
<p>Instead of assigning parameter values to the corresponding properties we can instruct TypeScript to perform an automatic assignment instead.
You can do that by putting one of the access modifiers <strong>public</strong>, <strong>private</strong> or <strong>protected</strong> before the parameter name.</p>
<p>You are going to get more details on <em>access modifiers</em> later in this book.
For now, let's see the updated <code>User</code> class using automatic property assignment:</p>
<pre><code class="language-ts">class User {

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(public firstName: string, public lastName: string) {
    }

}

let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<p>TypeScript creates <code>firstName</code> and <code>lastName</code> properties when generating JavaScript output.
You need targeting at least ES5 to use this feature.</p>
<p>Save example above to file <code>script.ts</code> then compile and run with <code>node</code>:</p>
<pre><code class="language-sh">tsc script.ts --target ES5
node script.js
</code></pre>
<p>The output should be as following:</p>
<pre><code class="language-text">Full name is: Joan Doe
</code></pre>
<p>You have not defined properties explicitly, but <code>fullName</code> getter was still able accessing them via <code>this</code>.
If you take a look at the emitted JavaScript you should see the properties are defined there as expected:</p>
<pre><code class="language-js">// ES5
var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    Object.defineProperty(User.prototype, &quot;fullName&quot;, {
        get: function () {
            return (this.firstName + &quot; &quot; + this.lastName).trim();
        },
        enumerable: true,
        configurable: true
    });
    return User;
}());
var user = new User('Joan', 'Doe');
console.log(&quot;Full name is: &quot; + user.fullName);
</code></pre>
<p>Now you can also switch to ES6 target to see how TypeScript assigns properties:</p>
<pre><code class="language-sh">tsc script.ts --target ES6
</code></pre>
<p>The generated JavaScript, in this case, is even smaller and cleaner:</p>
<pre><code class="language-js">// ES6
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName() {
        return `${this.firstName} ${this.lastName}`.trim();
    }
}
let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<h3 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h3>
<p>One of the important TypeScript features is the class inheritance that enables OOP patterns for developers.
Under the hood TypeScript is using the same <code>extends</code> syntactic sugar when targeting ES6 JavaScript,
and prototypical inheritance wrappers when generating output in ES5.</p>
<p>We can refer to animals as a classic example of class-based programming and inheritance.</p>
<pre><code class="language-ts">class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    makeSound() {
        console.log('Unknown sound');
    }
}
</code></pre>
<p>You have created a basic <code>Animal</code> class that contains a <code>name</code> property and <code>makeSound</code> method.
That translates to ES5 as following:</p>
<pre><code class="language-js">// ES5
var Animal = (function () {
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.makeSound = function () {
        console.log('Unknown sound');
    };
    return Animal;
}());
</code></pre>
<p>Now you can create a <code>Dog</code> implementation that provides a right sound:</p>
<pre><code class="language-ts">class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Woof-woof');
    }
}
</code></pre>
<p>Please note that if you have a constructor in the base class, then you must call it from all derived classes.
Otherwise, TypeScript should raise a compile-time error:</p>
<pre><code class="language-text">error TS2377: Constructors for derived classes must contain a 'super' call.
</code></pre>
<p>Here's how a <code>Dog</code> gets converted to ES5:</p>
<pre><code class="language-ts">var Dog = (function (_super) {
    __extends(Dog, _super);
    function Dog(name) {
        return _super.call(this, name) || this;
    }
    Dog.prototype.makeSound = function () {
        console.log('Woof-woof');
    };
    return Dog;
}(Animal));
</code></pre>
<p>Now let's add a <code>Cat</code> implementation with its sound and test both classes:</p>
<pre><code class="language-ts">class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Meow');
    }
}

let dog = new Dog('Spot');
let cat = new Cat('Tom');

dog.makeSound();
cat.makeSound();
</code></pre>
<p>Once the code compiles and executes you should get the following output:</p>
<pre><code class="language-text">Woof-woof
Meow
</code></pre>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>TypeScript supports <code>public</code>, <code>private</code> and <code>protected</code> modifiers for defining accessibility of the class members.</p>
<h4 id="public"><a class="header" href="#public">Public</a></h4>
<p>By default, each member of the class is <code>public</code> so that you can omit it.
However, nothing stops you from declaring <code>public</code> modifier explicitly if needed:</p>
<pre><code class="language-ts">class User {
    public firstName: string;
    public lastName: string;

    public speak() {
        console.log('Hello');
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre>
<p>Now if you compile example above to JavaScript you should see the following:</p>
<pre><code class="language-js">var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    User.prototype.speak = function () {
        console.log('Hello');
    };
    return User;
}());
</code></pre>
<h4 id="private"><a class="header" href="#private">Private</a></h4>
<p>You mark a member as <code>private</code> when it should never be accessed from outside of its containing class.
One of the most common scenarios is creating private fields to hold values for properties.
For example:</p>
<pre><code class="language-ts">class User {
    private _firstName: string;
    private _lastName: string;

    get firstName() {
        return this._firstName;
    }

    get lastName() {
        return this._lastName;
    }

    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
}
</code></pre>
<p>The class we have created above allows setting user's first and last name only from within the constructor.</p>
<p>If you try changing name properties from outside the class, TypeScript will raise an error at compile time:</p>
<pre><code class="language-ts">let user = new User('John', 'Doe');
user.firstName = 'Rob';
// error TS2540: Cannot assign to 'firstName' because it is a constant or a read-only property.
</code></pre>
<h4 id="protected"><a class="header" href="#protected">Protected</a></h4>
<p>The <code>protected</code> modifier restricts member visibility from outside of the containing class but provides access from the derived classes.</p>
<p>Let's start with base <code>Page</code> class implementation:</p>
<pre><code class="language-ts">class Page {

    protected renderHeader()    { /* ... */ }
    protected renderContent()   { /* ... */ }
    protected renderFooter()    { /* ... */ }

    render() {
        this.renderHeader();
        this.renderContent();        
        this.renderFooter();
    }
}
</code></pre>
<p>We created a <code>Page</code> class that has public method <code>render</code>.
Internally <code>render</code> calls three separate methods to render header, content and footer of the page.
These methods are not available from the outside the the class.</p>
<p>Now we are going to create a simple derived <code>AboutPage</code> class:</p>
<pre><code class="language-ts">class AboutPage extends Page {

    private renderAboutContent() { /* ... */ }

    render() {
        this.renderHeader();
        this.renderAboutContent();
        this.renderFooter();
    }

}
</code></pre>
<p>As you can see the <code>AboutPage</code> defines its <code>render</code> method that calls
<code>renderHeader</code> and <code>renderFooter</code> in parent class but puts custom content in the middle.</p>
<p>You can also use <code>protected</code> modifier with class constructors.
In this case, the class can be instantiated only by the derived classes that extend it.
That becomes handy when you want to have properties and methods available for multiple classes as a base implementation,
but don't want a base class to be instantiated outside its containing class.</p>
<p>For example</p>
<pre><code class="language-ts">class Page {
    protected constructor(id: string) {
        // ...
    }

    render() { /* base render */ }
}

class MainPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render main page */ }
}

class AboutPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render about page */ }
}

let main = new MainPage('main');
let about = new AboutPage('about');
</code></pre>
<p>You can create instances of <code>MainPage</code> and <code>AboutPage</code> both having access to protected members of the <code>Page</code> class.
However, you are not able creating an instance of the <code>Page</code> class directly.</p>
<pre><code class="language-ts">let page = new Page(); 
// error TS2674: Constructor of class 'Page' is protected and only accessible within the class declaration.
</code></pre>
<h3 id="readonly-modifier"><a class="header" href="#readonly-modifier">Readonly modifier</a></h3>
<p>One of the common ways to create a read-only property in many object-oriented programming languages
is by having a private local variable with a <code>getter</code> only.</p>
<pre><code class="language-ts">class Widget {

    private _id: string;

    get id(): string {
        return this._id;
    }

    constructor(id: string) {
        this._id = id;
    }
}

let widget = new Widget('textBox');
console.log(`Widget id: ${widget.id}`);
// Widget id: textBox
</code></pre>
<p>You can also make properties read-only by using the <code>readonly</code> keyword.
That reduces repetitive typing when dealing with many read-only properties, and greatly improves overall code readability.</p>
<p>Let's update the previous example to use <code>readonly</code>:</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<p>If you try changing the value of the property outside of the constructor TypeScript will raise an error:</p>
<pre><code class="language-ts">let widget = new Widget('text');
widget.id = 'newId';
// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p>You can provide default values for read-only properties only in two places: property declaration and constructor.</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;
    readonly minWidth: number = 200;
    readonly minHeight: number = 100;

    constructor(id: string) {
        this.id = id;
    }
}

let widget = new Widget('text');
widget.minWidth = 1000;
// error TS2540: Cannot assign to 'minWidth' because it is a constant or a read-only property.
</code></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>An <em>interface</em> is a description of the actions that an object can do.</p>
<p>You might already be familiar with <em>interfaces</em> in other programming languages like C# and Java,
or <em>contracts</em> in Swift.</p>
<p>Interfaces are not part of the ECMAScript.
It is a level of abstraction supported by TypeScript to improve the type-checking process, and not converted to JavaScript code.</p>
<p>Here's an example of an interface describing generic <strong>Text</strong> component:</p>
<pre><code class="language-ts">interface TextComponent {

    text: string;
    render(): void;

}
</code></pre>
<p>Now you can use the interface above to describe the requirement of having the <strong>text</strong> property that is a string and a <strong>render</strong> method:</p>
<pre><code class="language-ts">class PlainTextComponent implements TextComponent {

    text: string;

    render() {
        console.log('rendering plain text component');
    }

}
</code></pre>
<p>We are using <code>implements</code> keyword to wire class with a particular interface.
It is not important in what order class members are defined as long as all properties and methods the interface requires
are present and have required types.</p>
<p>Let's create another class that implements <code>TextComponent</code> interface partially:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent {
    text: string;
}
</code></pre>
<p>Upon compilation TypeScript will produce the following error:</p>
<pre><code class="language-text">error TS2420: Class 'RichTextComponent' incorrectly implements interface 'TextComponent'.
Property 'render' is missing in type 'RichTextComponent'.
</code></pre>
<p>You can use multiple interfaces delimited by a comma:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent, OnInit, OnDestroy {
    // ...
}
</code></pre>
<p>The example above shows a class that must implement three different interfaces to compile.</p>
<h2 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h2>
<p>Interfaces describe only requirements for classes; you cannot create an instance of the interface.
You need <code>abstract</code> classes un order to provide implementation details.</p>
<pre><code class="language-ts">abstract class PageComponent {

    abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Same as with interfaces you cannot create instances of abstract classes directly, only other classes derived from an abstract one.
Also, it is possible marking class methods as <code>abstract</code>.
Abstract methods do not contain implementation, and similar to <code>interface</code> methods provide requirements for derived classes.</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Note how <code>HomePageComponent</code> implements abstract <code>renderContent</code> that has access to <code>renderHeader</code> and <code>renderFooter</code> methods carried out in the parent class.</p>
<p>You can also use access modifiers with abstract methods.
The most frequent scenario is when methods need to be accessible only from within the child classes, and invisible from the outside:</p>
<p>For example:</p>
<pre><code class="language-ts">abstract class PageComponent {

    protected abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Now <code>HomePageComponent</code> can make <code>renderContent</code> protected like shown below:</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    constructor() {
        super();
        this.renderContent();
    }

    protected renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Any additional class that inherits (extends) <code>HomePageComponent</code> will still be able calling or redefining <code>renderContent</code> method.
But if you try accessing <code>renderContent</code> from outside the TypeScript should raise the following error:</p>
<pre><code class="language-ts">let homePage = new HomePageComponent();
homePage.renderContent();
// error TS2445: Property 'renderContent' is protected and only 
// accessible within class 'HomePageComponent' and its subclasses.
</code></pre>
<p>Abstract classes is a great way consolidating common functionality in a single place.</p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<p>TypeScript supports the concept of modules introduced in ES6.
Modules allow isolating code and data and help splitting functionality into logical groups.</p>
<p>One of the major features of ES6 (and TypeScript) modules is their file scope.
The code inside the module (classes, variables, functions, and other) does not pollute global scope
and is not accessible from the outside unless <code>exported</code> explicitly.</p>
<p>To share the code of the module with the outside world, you use <code>export</code> keyword:</p>
<pre><code class="language-ts">// module1.ts
export class TextBoxComponent {
  constructor(public text: string) {}
    
  render() {
    console.log(`Rendering '${this.text}' value.`);
  }
}
</code></pre>
<p>To use this code in your main application file or another module, you must import it first.
You import the <code>TextBoxComponent</code> class using <code>import</code> keyword:</p>
<pre><code class="language-ts">// app.ts
import { TextBoxComponent } from './module1'

let textBox = new TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="module-loaders"><a class="header" href="#module-loaders">Module Loaders</a></h3>
<p>ES6 and TypeScript rely on <code>module loaders</code> to locate files, resolve external dependencies and execute module files.</p>
<p>The most popular module loaders are:</p>
<ul>
<li>Server side
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used by Node.js)</li>
</ul>
</li>
<li>Client side
<ul>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li><a href="https://webpack.js.org/">Webpack</a></li>
</ul>
</li>
</ul>
<p>TypeScript supports different formats of generated JavaScript output.
You can instruct compiler to generate code adopted for multiple module loading systems using formats such as</p>
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used in Node.js)</li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li>UMD (Universal Module Definition)</li>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li>ES6 (or ECMAScript 2015)</li>
</ul>
<h3 id="running-at-server-side"><a class="header" href="#running-at-server-side">Running at server side</a></h3>
<p>You can test <code>TextBoxComponent</code> we have created earlier with node.js using <code>commonjs</code> module target:</p>
<pre><code class="language-sh">tsc app.ts --module commonjs
node app.js
</code></pre>
<p>When executed it produces the following output:</p>
<pre><code class="language-text">Rendering 'hello world' value.
</code></pre>
<p>TypeScript automatically compiles referenced modules.
It starts with <code>app.ts</code>, resolves and compiles <code>module1</code> as <code>module1.ts</code> file,
and produces two JavaScript files <code>app.js</code> and <code>module.js</code> that can be executed by node.js.</p>
<p>Here's an example of <code>app.js</code> file content:</p>
<pre><code class="language-js">&quot;use strict&quot;;
// app.ts
var module1_1 = require(&quot;./module1&quot;);
var textBox = new module1_1.TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="running-in-browser"><a class="header" href="#running-in-browser">Running in browser</a></h3>
<p>In order to run module-based application in browser you can take <code>SystemJS</code> loader:</p>
<pre><code class="language-html">&lt;script src=&quot;systemjs/dist/system.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  SystemJS.import('/app/app.js');
&lt;/script&gt;
</code></pre>
<p>Let's take a look at a simple TypeScript application that references an external module.</p>
<pre><code class="language-ts">// logger.ts
export class Logger {

  output: any;

  constructor(outputId: string) {
    this.output = document.getElementById(outputId);
  }

  info(message: string) {
    this.output.innerText = `INFO: ${message}`;
  }

}
</code></pre>
<p>Our simple <code>logger</code> is going to put a message as a content of the document element provided from the outside.</p>
<pre><code class="language-ts">// app.ts
import { Logger } from './logger';

let logger = new Logger('content');
logger.info('hello world');
</code></pre>
<p>The application needs to be compiled with SystemJS support to load correctly.
You can configure TypeScript to generate compatible JavaScript code by setting module code generation setting to <code>system</code>:</p>
<pre><code class="language-sh">tsc app.ts --module system
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find source code for the examples above in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/typescript/systemjs-example">typescript/systemjs-example</a>&quot; folder.</p>
</blockquote>
<p>To install dependencies, compile and run the demo use the following commands:</p>
<pre><code class="language-sh">npm install
npm start
</code></pre>
<p>Your default browser should run example page automatically.
Once the page gets loaded you should see an expected message:</p>
<pre><code class="language-text">INFO: hello world
</code></pre>
<h2 id="decorators"><a class="header" href="#decorators">Decorators</a></h2>
<p>TypeScript introduces <code>decorators</code> feature, metadata expressions similar to Java annotation tags or C# and Swift attributes.
ECMAScript does not yet have native support for annotating classes and class members (the feature is in the <code>proposal</code> state),
so <code>decorators</code> is an experimental TypeScript feature.</p>
<p>Decorators have a traditional notation of <code>@expression</code> where <code>expression</code> is the name of the function that should be invoked at runtime.</p>
<p>This function receives <code>decorated</code> target as a parameter and can be attached to:</p>
<ul>
<li>class declaration</li>
<li>method</li>
<li>accessor</li>
<li>property</li>
<li>parameter</li>
</ul>
<h3 id="class-decorators"><a class="header" href="#class-decorators">Class Decorators</a></h3>
<p>Class decorators are attached to class declarations.
At runtime, the function that backs the decorator gets applied to the class constructor.
That allows decorators inspecting, modifying or even replacing class instances if needed.</p>
<p>Here's a simple example of the <code>LogClass</code> decorator that outputs some log information every time being invoked:</p>
<pre><code class="language-ts">function LogClass(constructor: Function) {
    console.log('LogClass decorator executed for the constructor:');
    console.log(constructor);
}
</code></pre>
<p>Now you can use newly created decorator with different classes:</p>
<pre><code class="language-ts">@LogClass
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}
</code></pre>
<p>When a new instance of <code>TextWidget</code> class is created, the <code>@LogClass</code> attribute will be automatically invoked:</p>
<pre><code class="language-ts">let widget = new TextWidget();
widget.render();
</code></pre>
<p>The class decorator should produce the following output:</p>
<pre><code class="language-text">LogClass decorator executed for the constructor:
[Function: TextWidget]
Rendering text: default text
</code></pre>
<h4 id="decorators-with-parameters"><a class="header" href="#decorators-with-parameters">Decorators with parameters</a></h4>
<p>It is also possible passing values to decorators. You can achieve this with a feature known as <code>decorator factories</code>.
A <em>decorator factory</em> is a function returning an expression that is called at runtime:</p>
<p>Let's create another simple decorator with log output that accepts additional <code>prefix</code> and <code>suffix</code> settings:</p>
<pre><code class="language-ts">function LogClassWithParams(prefix: string, suffix: string) {
    return (constructor: Function) =&gt; {
        console.log(`
            ${prefix} 
            LogClassWithParams decorator called for: 
            ${constructor} 
            ${suffix}
        `);
    };
}
</code></pre>
<p>It can now be tested with the <code>TextWidget</code> class created earlier:</p>
<pre><code class="language-ts">@LogClassWithParams('BEGIN:', ':END')
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>You have marked <code>TextWidget</code> class with the <code>LogClassWithParams</code> decorator having a <code>prefix</code> and <code>suffix</code> properties
set to <code>BEGIN:</code> and <code>:END</code> values. The console output, in this case, should be:</p>
<pre><code class="language-text">BEGIN:
LogClassWithParams decorator called for: 
function TextWidget(text) {
    if (text === void 0) { text = 'default text'; }
        this.text = text;
    }
}
:END
</code></pre>
<h4 id="multiple-decorators"><a class="header" href="#multiple-decorators">Multiple decorators</a></h4>
<p>You are not limited to a single decorator per class.
TypeScript allows declaring as much class and member decorators as needed:</p>
<pre><code class="language-ts">@LogClass
@LogClassWithParams('BEGIN:', ':END')
@LogClassWithParams('[', ']')
class TextWidget {
    // ...
}
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
It means that first decorator that gets executed is:</p>
<pre><code class="language-ts">@LogClassWithParams('[', ']')
</code></pre>
<p>and the last decorator is going to be</p>
<pre><code class="language-ts">@LogClass
</code></pre>
<h3 id="method-decorators"><a class="header" href="#method-decorators">Method Decorators</a></h3>
<p>Method decorators are attached to class methods and can be used to inspect, modify or completely replace method definition of the class.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Let's create a decorator to inspect those parameters:</p>
<pre><code class="language-ts">function LogMethod(target: any, 
                   propertyKey: string, 
                   descriptor: PropertyDescriptor) {
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Below is an example of this decorator applied to a <code>render</code> method of <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethod
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>The console output in this case will be as following:</p>
<pre><code class="language-text">TextWidget { render: [Function] }
render
{ value: [Function],
  writable: true,
  enumerable: true,
  configurable: true }
Rendering text: default text
</code></pre>
<p>You can use <code>decorator factories</code> also with method decorators to support additional parameters.</p>
<pre><code class="language-ts">function LogMethodWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`${propertyKey}: ${message}`);
    };
}
</code></pre>
<p>This decorator can now be applied to methods. You can attach multiple decorators to a single method:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethodWithParams('hello')
    @LogMethodWithParams('world')
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
If you run the code the output should be as follows:</p>
<pre><code class="language-text">render: world
render: hello
Rendering text: default text
</code></pre>
<h3 id="accessor-decorators"><a class="header" href="#accessor-decorators">Accessor Decorators</a></h3>
<p>Accessor decorators are attached to property <code>getters</code> or <code>setters</code> and can be used to inspect, modify or completely replace accessor definition of the property.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Note that you can attach accessor decorator to either <code>getter</code> or <code>setter</code> but not both.
This restriction exists because on the low level decorators deal with
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Property Descriptors</a>
that contain both <code>get</code> and <code>set</code> accessors.</p>
<p>Let's create a decorator to inspect parameters:</p>
<pre><code class="language-ts">function LogAccessor(target: any, 
                     propertyKey: string, 
                     descriptor: PropertyDescriptor) {
    console.log('LogAccessor decorator called');
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Now the decorator can be applied to the following <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessor
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>Once invoked the decorator should produce the following output:</p>
<pre><code class="language-text">LogAccessor decorator called
TextWidget { text: [Getter/Setter] }
text
{ get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true }
</code></pre>
<p>Same as with class and method decorators you can use decorator factories feature to pass parameters to your accessor decorator.</p>
<pre><code class="language-ts">function LogAccessorWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`Message from decorator: ${message}`);
    }
}
</code></pre>
<p>TypeScript allows using more than one decorator given you attach it to the same property accessor:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    @LogAccessorWithParams('world')
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>The console output should be as shown below, note the right-to-left execution order:</p>
<pre><code class="language-text">Message from decorator: world
Message from decorator: hello
</code></pre>
<p>In case you declare decorator for both accessors TypeScript generates an error at compile time:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    get text(): string {
        return this._text;
    }
    
    @LogAccessorWithParams('world')
    set text(value: string) {
        this._text = value;
    }
}
</code></pre>
<pre><code class="language-text">error TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.
</code></pre>
<h3 id="property-decorators"><a class="header" href="#property-decorators">Property Decorators</a></h3>
<p>Property decorators are attached to class properties.
At runtime, property decorator receives the following arguments:</p>
<ul>
<li>target object</li>
<li>property name</li>
</ul>
<p>Due to technical limitations, it is not currently possible observing or modifying property initializers.
That is why property decorators do not get Property Descriptor value at runtime
and can be used mainly to observe a property with a particular name has been defined for a class.</p>
<p>Here's a simple property decorator to display parameters it gets at runtime:</p>
<pre><code class="language-ts">function LogProperty(target: any, propertyKey: string) {
    console.log('LogProperty decorator called');
    console.log(target);
    console.log(propertyKey);
}
</code></pre>
<pre><code class="language-ts">class TextWidget {

    @LogProperty
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        // ...
    }
}

let widget = new TextWidget('text1');
</code></pre>
<p>The output in this case should be as following:</p>
<pre><code class="language-text">LogProperty decorator called
TextWidget { render: [Function] }
id
</code></pre>
<h3 id="parameter-decorators"><a class="header" href="#parameter-decorators">Parameter Decorators</a></h3>
<p>Parameter decorators are attached to function parameters.
At runtime, every parameter decorator function is called with the following arguments:</p>
<ul>
<li>target</li>
<li>parameter name</li>
<li>parameter position index</li>
</ul>
<p>Due to technical limitations, it is possible only detecting that a particular parameter has been declared on a function.</p>
<p>Let's inspect runtime arguments with this simple parameter decorator:</p>
<pre><code class="language-ts">function LogParameter(target: any, 
                      parameterName: string, 
                      parameterIndex: number) {
    console.log('LogParameter decorator called');
    console.log(target);
    console.log(parameterName);
    console.log(parameterIndex);
}
</code></pre>
<p>You can now use this decorator with a class constructor and method parameters:</p>
<pre><code class="language-ts">class TextWidget {

    render(@LogParameter positionX: number, 
           @LogParameter positionY: number) {
        // ...
    }

}
</code></pre>
<p>Parameter decorators are also executed in right-to-left order.
So you should see console outputs for <code>positionY</code> and then <code>positionX</code>:</p>
<pre><code class="language-text">LogParameter decorator called
TextWidget { render: [Function] }
render
1
LogParameter decorator called
TextWidget { render: [Function] }
render
0
</code></pre>
<h1 id="angular-cli"><a class="header" href="#angular-cli">Angular CLI</a></h1>
<p>The <a href="https://cli.angular.io">Angular CLI</a> is a command line interface for Angular.</p>
<p><img src="images/cli-logo.png" alt="Angular CLI" /></p>
<p>As you might have noticed from the previous chapters, creating a project structure for a new web app may be a non-trivial task.
Working with multiple projects or frequently creating new ones may become extremely time-consuming
as you need configuring project structure again and again.</p>
<blockquote>
<p>The Angular CLI makes it easy to create an application that already works, right out of the box.
It already follows our best practices!</p>
</blockquote>
<p>This command line tool automates and simplifies many common scenarios, including:</p>
<ul>
<li>create new project structure from scratch with most optimal configuration out of the box</li>
<li>scaffold common Angular building blocks using one of the various blueprints (components, directives, pipes, services and other)</li>
<li>serving, watching and live reload</li>
<li>code linting</li>
<li>unit testing, code coverage reports, and end-to-end testing</li>
<li>development and production builds</li>
</ul>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<pre><code class="language-sh">npm install -g @angular/cli
</code></pre>
<p>The tool installs globally and is available via <code>ng</code> command.
Angular CLI supports lots of features; you can view details on available commands with the <code>help</code> command:</p>
<pre><code class="language-sh">ng help
</code></pre>
<h2 id="your-first-application"><a class="header" href="#your-first-application">Your First Application</a></h2>
<p>To create a new application you should use <code>ng new &lt;project-name&gt;</code> command:</p>
<pre><code class="language-sh">ng new my-first-app
</code></pre>
<p>The <code>ng</code> tool should produce console output similar to the following one:</p>
<pre><code class="language-text">installing ng
  create .editorconfig
  create README.md
  create src/app/app.component.css
  create src/app/app.component.html
  create src/app/app.component.spec.ts
  create src/app/app.component.ts
  create src/app/app.module.ts
  create src/assets/.gitkeep
  create src/environments/environment.prod.ts
  create src/environments/environment.ts
  create src/favicon.ico
  create src/index.html
  create src/main.ts
  create src/polyfills.ts
  create src/styles.css
  create src/test.ts
  create src/tsconfig.app.json
  create src/tsconfig.spec.json
  create src/typings.d.ts
  create .angular-cli.json
  create e2e/app.e2e-spec.ts
  create e2e/app.po.ts
  create e2e/tsconfig.e2e.json
  create .gitignore
  create karma.conf.js
  create package.json
  create protractor.conf.js
  create tsconfig.json
  create tslint.json
Successfully initialized git.
Installing packages for tooling via npm.
Installed packages for tooling via npm.
You can `ng set --global packageManager=yarn`.
Project 'my-first-app' successfully created.
</code></pre>
<p>The <code>scripts</code> section of the <code>package.json</code> file should point to <code>ng</code> tool for all the actions:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;ng&quot;: &quot;ng&quot;,
        &quot;start&quot;: &quot;ng serve&quot;,
        &quot;build&quot;: &quot;ng build&quot;,
        &quot;test&quot;: &quot;ng test&quot;,
        &quot;lint&quot;: &quot;ng lint&quot;,
        &quot;e2e&quot;: &quot;ng e2e&quot;
    }
}
</code></pre>
<h2 id="running-application"><a class="header" href="#running-application">Running Application</a></h2>
<p>Now switch to the newly generated <code>my-first-app</code> folder and launch the app:</p>
<pre><code class="language-sh">cd my-first-app/
ng serve
</code></pre>
<p>The <code>ng serve</code> command compiles and serves entire project using <code>webpack</code> bundler with an output similar to following:</p>
<pre><code class="language-text">** NG Live Development Server is running on http://localhost:4200 **
Hash: 2c5e702e0dbbc24e055c
Time: 10564ms
chunk    {0} polyfills.bundle.js, polyfills.bundle.js.map (polyfills) 158 kB {4} [initial] [rendered]
chunk    {1} main.bundle.js, main.bundle.js.map (main) 3.62 kB {3} [initial] [rendered]
chunk    {2} styles.bundle.js, styles.bundle.js.map (styles) 9.77 kB {4} [initial] [rendered]
chunk    {3} vendor.bundle.js, vendor.bundle.js.map (vendor) 2.37 MB [initial] [rendered]
chunk    {4} inline.bundle.js, inline.bundle.js.map (inline) 0 bytes [entry] [rendered]
webpack: Compiled successfully.
</code></pre>
<p>It is important to note that with <code>ng serve</code> you are going to run your project with <code>live development server</code>.
The server is going to watch for code changes, rebuild all affected bundles and reload the browser.</p>
<p>Now if you navigate to <code>http://localhost:4200</code> you should see the following default text:</p>
<pre><code class="language-text">app works!
</code></pre>
<p>Alternatively, you can run <code>serve</code> command with the <code>--open</code> switch to automatically open system browser with the application once compilation is complete:</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>It is also possible configuring default <code>host</code> and <code>port</code> settings:</p>
<pre><code class="language-sh">ng serve --host 0.0.0.0 --port 3000
</code></pre>
<p>The command above allows accessing your application from the local machine and local network via port 3000.</p>
<p>There are plenty of options and switches that can be used with <code>ng serve</code> command; you can refer to full details by calling <code>ng help</code>.</p>
<h2 id="code-linting"><a class="header" href="#code-linting">Code Linting</a></h2>
<p>Checking code is one of the essential steps.
Angular CLI ships with the TSLint support and predefined set of rules in the <code>tsconfig.json</code> file.</p>
<pre><code class="language-sh">ng lint
</code></pre>
<p>Default auto-generated project should contain no errors. You should see the following result in the console:</p>
<pre><code class="language-text">All files pass linting.
</code></pre>
<p>Let's try to ensure TSLint works as expected by modifying the <code>/src/app/app.component.ts</code> file.
Just change single quotes with double quotes like below:</p>
<pre><code class="language-ts">export class AppComponent {
  title = &quot;app works!&quot;;
}
</code></pre>
<p>Now running <code>ng lint</code> should produce next output:</p>
<pre><code class="language-text">src/app/app.component.ts[9, 11]: &quot; should be '
Lint errors found in the listed files.
</code></pre>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>You get a predefined unit testing configuration with every generated project.
By default, you are going to use <code>Karma</code> runner with the <code>Jasmine</code> test framework.</p>
<pre><code class="language-sh">ng test
</code></pre>
<p><img src="images/unit-tests.png" alt="Unit tests" /></p>
<p>Tests run in <code>watch</code> mode, meaning they automatically re-run upon code changes.</p>
<p><em>Please note that out-of-box configuration requires Google Chrome browser to run tests,
via the <code>karma-chrome-launcher</code> plugin.</em></p>
<p>As per Angular code style guides, all the unit test files reside next to the components tested.
The Angular CLI generates three dummy tests in the <code>src/app/app.component.spec.ts</code>:</p>
<pre><code class="language-ts">it('should create the app', async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  const app = fixture.debugElement.componentInstance;
  
  expect(app).toBeTruthy();
}));

it(`should have as title 'app works!'`, async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  const app = fixture.debugElement.componentInstance;
  
  expect(app.title).toEqual('app works!');
}));

it('should render title in a h1 tag', async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  fixture.detectChanges();
  
  const compiled = fixture.debugElement.nativeElement;
  expect(compiled.querySelector('h1').textContent).toContain('app works!');
}));
</code></pre>
<p>Let's check what happens when a test fails.</p>
<p>Append the following code to the end of the &quot;app.component.spec.ts&quot;:</p>
<pre><code class="language-ts">it('should fail', () =&gt; {
  expect(true).toBe(false);
});
</code></pre>
<p>Now if you run <code>ng test</code> once again you should see the following report:</p>
<p><img src="images/failed-test-details.png" alt="Failed test" /></p>
<p>There are two tabs on the page: <strong>Spec List</strong> and <strong>Failures</strong>.
You should see <strong>Failures</strong> by default but if there's more than one unit test failed you can check them on the <strong>Spec List</strong> page:</p>
<p><img src="images/failed-test-spec-list.png" alt="Spec List" /></p>
<p>If you do not plan to debug tests and just want to see a quick result of the test run just add <code>--single-run</code> switch to the <code>test</code> command:</p>
<pre><code class="language-sh">ng test --single-run
</code></pre>
<p>Developers typically use single run configurations for continuous integration (CI) scenarios.</p>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code Coverage</a></h2>
<p>You can generate a coverage report for your unit tests by adding <code>--code-coverage</code> switch to the <code>test</code> command:</p>
<pre><code class="language-sh">ng test --single-run --code-coverage
</code></pre>
<p>Under the hood the <code>ng</code> tool performs the following actions:</p>
<ul>
<li>compile the project with webpack, including TypeScript transpilation with source maps</li>
<li>use Karma runner and Jasmine to execute unit tests</li>
<li>remap code coverage report for JavaScript back to TypeScript</li>
<li>generate HTML report within <code>coverage</code> folder</li>
</ul>
<p>After testing finishes you can either open <code>coverage/index.html</code> with your favorite browser.</p>
<p>For example:</p>
<pre><code class="language-sh">open ./coverage/index.html
</code></pre>
<p>The command above should serve your coverage report and automatically launches default browser with the main page.</p>
<p><img src="images/code-coverage-main.png" alt="Code Coverage" /></p>
<p>Click the <code>src/app</code> and then <code>app.component.ts</code> to see TypeScript coverage:</p>
<p><img src="images/code-coverage-single-file.png" alt="Code Coverage for single file" /></p>
<h2 id="development-and-production-builds"><a class="header" href="#development-and-production-builds">Development and Production builds</a></h2>
<p>The Angular CLI supports producing both <code>development</code> and <code>production</code> using the <code>build</code> command:</p>
<pre><code class="language-sh">ng build
</code></pre>
<p>The format of the command is:</p>
<pre><code class="language-sh">ng build &lt;options...&gt;
</code></pre>
<p>By default it is running in <code>development</code> mode (an equivalent of <code>ng build -dev</code>) and produces output to the <code>dist/</code> folder.
You will get bundles together with source maps for better debugging:</p>
<table><thead><tr><th>File</th><th>Size</th></tr></thead><tbody>
<tr><td>favicon.ico</td><td>5430</td></tr>
<tr><td>index.html</td><td>613</td></tr>
<tr><td>inline.bundle.js</td><td>5764</td></tr>
<tr><td>inline.bundle.js.map</td><td>5824</td></tr>
<tr><td>main.bundle.js</td><td>6539</td></tr>
<tr><td>main.bundle.js.map</td><td>3817</td></tr>
<tr><td>polyfills.bundle.js</td><td>169209</td></tr>
<tr><td>polyfills.bundle.js.map</td><td>204535</td></tr>
<tr><td>styles.bundle.js</td><td>10039</td></tr>
<tr><td>styles.bundle.js.map</td><td>13372</td></tr>
<tr><td>vendor.bundle.js</td><td>2884505</td></tr>
<tr><td>vendor.bundle.js.map</td><td>3081499</td></tr>
</tbody></table>
<p>For production purposes you will want using the following command:</p>
<pre><code class="language-sh">ng build -prod
</code></pre>
<p>Which is an equivalent of the:</p>
<pre><code class="language-sh">ng build --target=production
</code></pre>
<p>This will give you much smaller output:</p>
<table><thead><tr><th>File</th><th>Size</th></tr></thead><tbody>
<tr><td>favicon.ico</td><td>5430</td></tr>
<tr><td>inline.d72284a6a83444350a39.bundle.js</td><td>1460</td></tr>
<tr><td>main.e088c8ce83e51568eb21.bundle.js</td><td>12163</td></tr>
<tr><td>polyfills.f52c146b4f7d1751829e.bundle.js</td><td>58138</td></tr>
<tr><td>styles.d41d8cd98f00b204e980.bundle.css</td><td>0</td></tr>
<tr><td>vendor.a2da17b9c49cdce7678a.bundle.js</td><td>362975</td></tr>
</tbody></table>
<p>Please note that <code>styles</code> bundle will be empty because by default newly generated app has <code>src/styles.css</code> file empty.</p>
<p>The <code>ng</code> tool removes <code>dist</code> folder between the builds so you should not worry about files left from previous builds and modes.</p>
<p>The content of the <code>dist</code> folder is everything you need to deploy your application to the remote server.
You can also use any web server of your choice to run the application in production.</p>
<p>For example:</p>
<ul>
<li>Nginx server</li>
<li>Tomcat server</li>
<li>IIS server</li>
<li>and many others</li>
</ul>
<p>In addition, you can deploy your application to any static pages host, like:</p>
<ul>
<li><a href="https://pages.github.com/">GitHub pages</a></li>
<li><a href="https://www.netlify.com/">Netlify</a></li>
<li>and many others</li>
</ul>
<p>It is still possible to use Angular CLI and embedded development server to test production builds.
You can use the following command to build the app in production mode and then run and open default browser to check it:</p>
<pre><code class="language-sh">ng serve --prod --open
</code></pre>
<h2 id="using-blueprints"><a class="header" href="#using-blueprints">Using blueprints</a></h2>
<p>Besides generating new application project structure, the <code>ng</code> tool supports creating core Angular building blocks
be means of <code>generate</code> (or <code>g</code>) command and several <code>blueprints</code>.</p>
<pre><code class="language-sh">ng generate &lt;blueprint&gt; &lt;options...&gt;
</code></pre>
<p>For the time being Angular CLI supports the following set of blueprints out-of-box:</p>
<table><thead><tr><th>Blueprint name</th><th>Command line usage</th></tr></thead><tbody>
<tr><td>Component</td><td>ng g component my-new-component</td></tr>
<tr><td>Directive</td><td>ng g directive my-new-directive</td></tr>
<tr><td>Pipe</td><td>ng g pipe my-new-pipe</td></tr>
<tr><td>Service</td><td>ng g service my-new-service</td></tr>
<tr><td>Class</td><td>ng g class my-new-class</td></tr>
<tr><td>Guard</td><td>ng g guard my-new-guard</td></tr>
<tr><td>Interface</td><td>ng g interface my-new-interface</td></tr>
<tr><td>Enum</td><td>ng g enum my-new-enum</td></tr>
<tr><td>Module</td><td>ng g module my-module</td></tr>
</tbody></table>
<p>Let's assume you have generated a new <code>my-first-app</code> like suggested below:</p>
<pre><code class="language-sh">ng new my-first-app
cd my-first-app
</code></pre>
<p>Now to create a new component, you should be using  the following command:</p>
<pre><code class="language-sh">ng g component my-first-component
</code></pre>
<p>The <code>ng</code> tool takes your current directory and creates all component related files:</p>
<pre><code class="language-text">installing component
  create src/app/my-first-component/my-first-component.component.css
  create src/app/my-first-component/my-first-component.component.html
  create src/app/my-first-component/my-first-component.component.spec.ts
  create src/app/my-first-component/my-first-component.component.ts
  update src/app/app.module.ts
</code></pre>
<p>If you are running <code>ng generate</code> command (or <code>ng g</code> by alias) from the root of your project,
the CLI should automatically put content to <code>src/app/&lt;feature&gt;</code> folder like shown above.</p>
<p>You can also specify additional folder structure that should become relative to <code>src/app</code> during generation.
All missing directories get created automatically.</p>
<p>Run the following command from the root project folder:</p>
<pre><code class="language-sh">ng g service services/simple-service
</code></pre>
<p>The <code>ng</code> tool creates <code>src/app/services</code> path and puts <code>simple-service</code> implementation there:</p>
<pre><code class="language-text">installing service
  create src/app/services/simple-service.service.spec.ts
  create src/app/services/simple-service.service.ts
  WARNING Service is generated but not provided, it must be provided to be used
</code></pre>
<p>Finally, you can change current directory and generate Angular artifacts there:</p>
<pre><code class="language-sh">mkdir src/app/directives
cd src/app/directives/
ng g directive my-first-directive
</code></pre>
<p>In this case, you should see get following output:</p>
<pre><code class="language-text">installing directive
  create src/app/directives/my-first-directive.directive.spec.ts
  create src/app/directives/my-first-directive.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>All blueprints follow common Angular code style guides.
You get a separate folder and all files one should expect when starting with a new Angular component:</p>
<ul>
<li>code file (<code>&lt;component&gt;.ts</code>)</li>
<li>external template file (<code>&lt;component&gt;.html</code>)</li>
<li>external css file (<code>&lt;component&gt;.css</code>)</li>
<li>unit test file (<code>&lt;component&gt;.spec.ts</code>)</li>
</ul>
<p>One of the best features of Angular CLI is that you do not get just placeholder files but a valid ready to use artefact and unit tests.
Let's peek inside <code>MyFirstComponent</code> component we have created earlier, and try integrating into the application.</p>
<pre><code class="language-ts">import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-my-first-component',
  templateUrl: './my-first-component.component.html',
  styleUrls: ['./my-first-component.component.css']
})
export class MyFirstComponentComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
</code></pre>
<p>You get <code>app-my-first-component</code> selector, external template and style,
together with a constructor and <code>OnInit</code> placeholder to save your time.</p>
<p>The stylesheet file (<strong>my-first-component.component.css</strong>) is empty by default,
and template file (<strong>my-first-component.component.html</strong>) contains the following simple layout:</p>
<pre><code class="language-html">&lt;p&gt;
  my-first-component works!
&lt;/p&gt;
</code></pre>
<p>The CLI will even update <code>src/app/app.module.ts</code> to include your newly created component into the application module:</p>
<pre><code class="language-ts">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppComponent } from './app.component';
import { MyFirstComponentComponent } from './my-first-component/my-first-component.component';

@NgModule({
  declarations: [
    AppComponent,
    MyFirstComponentComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>To test the generated component you can use main application template:</p>
<pre><code class="language-html">&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;app-my-first-component&gt;
&lt;/app-my-first-component&gt;
</code></pre>
<p>Finally, you can run development server if it is not running already:</p>
<pre><code class="language-sh">ng serve
</code></pre>
<p><img src="images/ng-cli-component.png" alt="Angular CLI component" /></p>
<p>As a starting point you also get a simple ready-to-run unit test for your component:</p>
<pre><code class="language-ts">import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyFirstComponentComponent } from './my-first-component.component';

describe('MyFirstComponentComponent', () =&gt; {
  let component: MyFirstComponentComponent;
  let fixture: ComponentFixture&lt;MyFirstComponentComponent&gt;;

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ MyFirstComponentComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyFirstComponentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () =&gt; {
    expect(component).toBeTruthy();
  });
});
</code></pre>
<p>As mentioned earlier you can run unit tests in <code>watch</code> mode with the help of <code>ng test</code> command:</p>
<p><img src="images/ng-cli-component-test.png" alt="Component Test" /></p>
<p>If you have added your component to the <code>app.component.html</code> template, some unit tests may fail.
To fix them you should update test configuration in <code>app.component.spec.ts</code>
and include your component into the test module:</p>
<pre><code class="language-ts">import { TestBed, async } from '@angular/core/testing';

import { AppComponent } from './app.component';
import { MyFirstComponentComponent } from './my-first-component/my-first-component.component';

describe('AppComponent', () =&gt; {
  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
        MyFirstComponentComponent
      ],
    }).compileComponents();
  }));

  ...
});
</code></pre>
<h2 id="creating-modules"><a class="header" href="#creating-modules">Creating Modules</a></h2>
<p>The Angular CLI tool also provides support for multiple modules
and generating entities that belong to the particular module.</p>
<p>Let's start by generating a new module using the next command:</p>
<pre><code class="language-sh">ng g module my-components
</code></pre>
<p>The output in the console should look similar to the following:</p>
<pre><code class="language-text">create src/app/my-components/my-components.module.ts (196 bytes)
</code></pre>
<p>And the content of the module contains a basic implementation like in the example below:</p>
<pre><code class="language-ts">// src/app/my-components/my-components.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: []
})
export class MyComponentsModule { }
</code></pre>
<p>Note that by default Angular creates a folder for your module, similar to what it does for components.
This is handy once you create components, services, directives and pipes that need to belong to this module.
But if you want to put the resulting module in a single file next to the &quot;app.module.ts&quot; use the &quot;--flat&quot; switch.</p>
<pre><code class="language-sh">ng g module my-components --flat
</code></pre>
<p>In that case, the output will be:</p>
<pre><code class="language-text">create src/app/my-components.module.ts (196 bytes)
</code></pre>
<p>You can check more details on the available switches by running the &quot;ng g module --help&quot; command.</p>
<h3 id="assigning-components-to-modules"><a class="header" href="#assigning-components-to-modules">Assigning components to modules</a></h3>
<p>By default, Angular CLI appends all generated content to the main application module inside &quot;app.module.ts&quot;.
Once you have two or more modules in the application, the CLI will require the module name for every new content.</p>
<p>Try running the following command to see what happens:</p>
<pre><code class="language-sh">ng g component my-button-1
</code></pre>
<p>The output should be similar to the following one:</p>
<pre><code class="language-text">Error: More than one module matches.
Use skip-import option to skip importing the component into the closest module.
</code></pre>
<p>To include your new component into a particular module use the &quot;--module&quot; switch.
If you are building a shared module, you might also use the &quot;--export&quot; switch,
so that module exports your component besides declaration.</p>
<pre><code class="language-sh">ng g component my-button-1 --module=my-components --export
</code></pre>
<p>This time, you will get the following result:</p>
<pre><code class="language-text">  create src/app/my-button-1/my-button-1.component.css (0 bytes)
  create src/app/my-button-1/my-button-1.component.html (30 bytes)
  create src/app/my-button-1/my-button-1.component.spec.ts (651 bytes)
  create src/app/my-button-1/my-button-1.component.ts (287 bytes)
  update src/app/my-components.module.ts (321 bytes)
</code></pre>
<p>And the module content now looks like in the code example below:</p>
<pre><code class="language-ts">// src/app/my-components.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MyButton1Component } from './my-button-1/my-button-1.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [MyButton1Component],
  exports: [MyButton1Component]
})
export class MyComponentsModule { }
</code></pre>
<p>Do not forget to check the &quot;ng g component --help&quot; to see all available options.</p>
<p>You can also include your new module into some other existing module from the command line.</p>
<pre><code class="language-sh">ng g module my-feature --module=my-components --flat
</code></pre>
<p>As a result, the &quot;MyComponentsModule&quot; module will include &quot;MyFeatureModule&quot;:</p>
<pre><code class="language-ts">// src/app/my-components.module.ts

@NgModule({
  imports: [
    CommonModule,
    MyFeatureModule
  ],
  declarations: [MyButton1Component],
  exports: [MyButton1Component]
})
export class MyComponentsModule { }
</code></pre>
<h2 id="routing-support"><a class="header" href="#routing-support">Routing Support</a></h2>
<p>If you plan working with Angular Router or want to experiment with routing capabilities,
the Angular CLI can generate an application for you with initial Router support.</p>
<p>Use the &quot;--routing&quot; switch if you want to generate a routing module scaffold with your application.</p>
<pre><code class="language-sh">ng new my-app --routing
</code></pre>
<p>The routing scaffold should look similar to the one below:</p>
<pre><code class="language-ts">// src/app/app-routing.module.ts

import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
</code></pre>
<p>In addition, the main application component is going to contain the router outlet component:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<h2 id="generating-standalone-scripts"><a class="header" href="#generating-standalone-scripts">Generating Standalone Scripts</a></h2>
<p>The Angular CLI provides a special feature that allows detaching command line tools from the project,
and generating a set of scripts needed for standalone project compilation and testing:</p>
<pre><code class="language-sh">ng eject
</code></pre>
<p>Which is an equivalent for <code>ng eject -dev</code> or <code>ng eject --target=development</code>,
and instructs <code>ng</code> tool to use <code>development</code> configuration.
Alternatively, you can use <code>-prod</code> or <code>--target=production</code> switches to enable <code>production</code> mode.</p>
<p>Upon running <code>eject</code> command, the CLI will:</p>
<ul>
<li>update <code>package.json</code> with all dependencies needed to compile project without extra tools</li>
<li>generate and output the proper webpack configuration (<code>webpack.config.js</code>) and scripts for testing</li>
</ul>
<p>The tool might provide additional notes in the console output like below:</p>
<pre><code class="language-text">==============================================================
Ejection was successful.

To run your builds, you now need to do the following commands:
   - &quot;npm run build&quot; to build.
   - &quot;npm run test&quot; to run unit tests.
   - &quot;npm start&quot; to serve the app using webpack-dev-server.
   - &quot;npm run e2e&quot; to run protractor.

Running the equivalent CLI commands results in error.

==============================================================
Some packages were added. Please run &quot;npm install&quot;.
</code></pre>
<p>Now <code>scripts</code> section in your <code>package.json</code> file should link to local content for a <code>start</code>, <code>build</code> and various <code>test</code> scripts:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;ng&quot;: &quot;ng&quot;,
        &quot;start&quot;: &quot;webpack-dev-server --port=4200&quot;,
        &quot;build&quot;: &quot;webpack&quot;,
        &quot;test&quot;: &quot;karma start ./karma.conf.js&quot;,
        &quot;lint&quot;: &quot;ng lint&quot;,
        &quot;e2e&quot;: &quot;protractor ./protractor.conf.js&quot;,
        &quot;prepree2e&quot;: &quot;npm start&quot;,
        &quot;pree2e&quot;: &quot;webdriver-manager update --standalone false --gecko false --quiet&quot;
    }
}
</code></pre>
<h1 id="angular"><a class="header" href="#angular">Angular</a></h1>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/6">todo: Needs introduction</a></em></p>
<h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components are the main building blocks in Angular.</p>
<p>A typical Angular application is represented by a tree of elements starting with a single root one.</p>
<pre><code class="language-html">&lt;app-root&gt;

    &lt;app-header title=&quot;My header&quot;&gt;
        &lt;!-- ... --&gt;
    &lt;/app-header&gt;

    &lt;app-layout type=&quot;horizontal&quot;&gt;

        &lt;app-sidebar&gt;
            &lt;!-- ... --&gt;
        &lt;/app-sidebar&gt;

        &lt;app-content&gt;
            &lt;!-- ... --&gt;
        &lt;/app-content&gt;

    &lt;/app-layout&gt;

    &lt;app-footer&gt;
        &lt;!-- ... --&gt;
    &lt;/app-footer&gt;

&lt;/app-root&gt;
</code></pre>
<p>As you can see from the markup above, our main application template consists at least of the following six components:</p>
<ul>
<li>app-root</li>
<li>app-header</li>
<li>app-layout</li>
<li>app-sidebar</li>
<li>app-content</li>
<li>app-footer</li>
</ul>
<p>Schematically it should look similar to the following:</p>
<p><img src="images/components-app-structure.png" alt="App Structure with Components" /></p>
<h2 id="creating-a-simple-component"><a class="header" href="#creating-a-simple-component">Creating a Simple Component</a></h2>
<p>Let's build a simple Angular component in the new &quot;basic-components&quot; project.</p>
<p>The easiest and quickest way to prepare a project structure is using Angular CLI to setup scaffold.</p>
<blockquote>
<p><strong>Angular CLI</strong></p>
<p>You can find detailed information on setting up project scaffolds in the <strong><a href="ch04-00-angular-cli.html">Angular CLI</a></strong> chapter.</p>
</blockquote>
<p>You start creating a component with importing the <code>@Component</code> decorator from the <code>@angular/core</code>:</p>
<pre><code class="language-ts">import { Component } from '@angular/core';
</code></pre>
<p>The <code>@Component</code> decorator supports multiple properties,
and we are going review them in the <strong><a href="ch05-04-component-metadata.html">Component Metadata</a></strong> section later in this chapter.
For the bare minimum, you need to set the &quot;selector&quot; and &quot;template&quot; values to create a basic reusable component.</p>
<p>Our minimal &quot;Header&quot; component implementation can look in practice like in the following example.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-header',
  template: '&lt;div&gt;{{ title }}&lt;/div&gt;'
})
export class HeaderComponent {

  title: string = 'Header';

}
</code></pre>
<p>You set the selector value to 'app-header'. That means you are registering a new HTML element called <code>&lt;app-header&gt;</code>.</p>
<p>You also set a &quot;template&quot; property that holds the inline HTML template string.
At run time the Header element is to be rendered as a <code>&lt;div&gt;</code> element with its inner text bound to the &quot;title&quot; property of the &quot;HeaderComponent&quot; class.</p>
<p>Note that before using Header component within an application, we need to register it within the main application module.</p>
<blockquote>
<p><strong>Application Module</strong></p>
<p>You are going to get more detailed information on Angular modules in a separate <strong><a href="ch05-02-creating-a-simple-component.html#modules">Modules</a></strong> chapter.</p>
<p>For now, it is good for you to have just a basic understanding of how components get registered within modules.</p>
</blockquote>
<p>Below you can see an example of how typically register a component.
For the sake of simplicity, we are going to see only newly added content.</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...
import { HeaderComponent } from './components/header.component';

@NgModule({
  declarations: [
    // ...
    HeaderComponent
  ],
  // ...
})
export class AppModule { }
</code></pre>
<p>Finally, to test your component just put the following content into the main application template HTML file.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.template --&gt;
&lt;app-header&gt;&lt;/app-header&gt;
</code></pre>
<p>Once you compile and run your web application, you should see the following content on the main page.</p>
<pre><code class="language-text">Header
</code></pre>
<p>Congratulations, you have just created a basic Angular component that you can now reuse across all your web application.</p>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/basic-components">angular/components/basic-components</a></strong> folder.</p>
</blockquote>
<h2 id="generating-components-with-angular-cli"><a class="header" href="#generating-components-with-angular-cli">Generating Components with Angular CLI</a></h2>
<p>Now let's try creating another component utilizing the Angular CLI.</p>
<p>This time we are going to create a Footer element.
That should give a good comparison on manual versus automatically generated approaches.</p>
<p>Using the command line prompt execute the following command in the project root directory:</p>
<pre><code class="language-sh">ng g component components/footer
</code></pre>
<p>You should instantly notice how Angular CLI saves your time.
It creates you a full set of files for your Footer component and event modifies the main application module file for you.</p>
<p>You can check the console output below:</p>
<pre><code class="language-text">installing component
  create src/app/components/footer/footer.component.css
  create src/app/components/footer/footer.component.html
  create src/app/components/footer/footer.component.spec.ts
  create src/app/components/footer/footer.component.ts
  update src/app/app.module.ts
</code></pre>
<blockquote>
<p><strong>Angular CLI</strong></p>
<p>You can find detailed information on blueprints and content generation in the <a href="ch04-00-angular-cli.html">4. Angular CLI</a> chapter.</p>
</blockquote>
<p>As a result, you get an initial component implementation with an external HTML and CSS templates and even a unit test scaffold.</p>
<pre><code class="language-ts">//src/app/components/footer/footer.component.ts
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-footer',
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.css']
})
export class FooterComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
</code></pre>
<p>Finally, you can update your main application template to see both header and footer elements in action:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;app-header&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Upon compiling the application and reloading the page, you should see the following output.</p>
<pre><code class="language-text">Header
footer works!
</code></pre>
<p>Note how Angular CLI provides a content of the automatically generated Footer element.</p>
<p>So as you can from the examples above, you save an enormous amount of time when using Angular CLI when it comes to scaffold generation.</p>
<h2 id="component-metadata"><a class="header" href="#component-metadata">Component Metadata</a></h2>
<p>According to the official documentation, you can use the following set of properties with a <code>@Component</code> decorator:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>changeDetection</td><td>ChangeDetectionStrategy</td><td>Defines the change detection strategy the component should use.</td></tr>
<tr><td>viewProviders</td><td>Provider[]</td><td>Defines the set of injectable objects that are visible to its view DOM children.</td></tr>
<tr><td>moduleId</td><td>string</td><td>ES/CommonJS module id of the file in which this component is defined.</td></tr>
<tr><td>templateUrl</td><td>string</td><td>Specifies a URL containing a relative path to an external file containing a template for the view.</td></tr>
<tr><td>template</td><td>string</td><td>An inline-defined template for the view.</td></tr>
<tr><td>styleUrls</td><td>string[]</td><td>List of URLs containing relative paths to the stylesheets to apply to this component's view at runtime.</td></tr>
<tr><td>styles</td><td>string[]</td><td>List of inline-defined styles to apply to this component's view at runtime.</td></tr>
<tr><td>animations</td><td>any[]</td><td>List of animations of this component in a special DSL-like format.</td></tr>
<tr><td>encapsulation</td><td>ViewEncapsulation</td><td>Defines style encapsulation strategy used by this component.</td></tr>
<tr><td>interpolation</td><td>[string, string]</td><td>Overrides the default encapsulation start and end delimiters (respectively <code>{{</code> and <code>}}</code>).</td></tr>
<tr><td>entryComponents</td><td>Array&lt;Type&lt;any&gt; | any[]&gt;</td><td>List of components that are dynamically inserted into the view of this component.</td></tr>
</tbody></table>
<p>The <code>@Component</code> decorator extends the <code>@Directive</code> one, so it also inherits the following set of properties you can use as well:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>selector</td><td>string</td><td>CSS selector that identifies this component in a template.</td></tr>
<tr><td>inputs</td><td>string[]</td><td>List of class property names to data-bind as component inputs.</td></tr>
<tr><td>outputs</td><td>string[]</td><td>List of class property names that expose output events that others can subscribe to.</td></tr>
<tr><td>host</td><td>{ [key: string]: string; }</td><td>Map that specifies the events, actions, properties and attributes related to the host element.</td></tr>
<tr><td>providers</td><td>Provider[]</td><td>List of providers available to this component and its children.</td></tr>
<tr><td>exportAs</td><td>string</td><td>A name under which the component instance is exported in a template.</td></tr>
<tr><td>queries</td><td>{ [key: string]: any; }</td><td>Map of queries that can be injected into the component.</td></tr>
</tbody></table>
<h2 id="templates"><a class="header" href="#templates">Templates</a></h2>
<p>There are two ways to assign a component view template: inline-defined and external file.</p>
<h3 id="inline-templates"><a class="header" href="#inline-templates">Inline Templates</a></h3>
<p>You specify inline template by setting the &quot;template&quot; field value of the <code>@Component</code> decorator.
To get better formatting and multi-line support, you can use template literals feature introduced in ES6 and backed by TypeScript out of the box.</p>
<blockquote>
<p><strong>Template Literals</strong></p>
<p>Template literals are string literals allowing embedded expressions.
You can use multi-line strings and string interpolation features with them.</p>
<p>For more detailed information on this ES6 feature, please refer to the following <strong><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals">Template literals</a></strong> article.</p>
</blockquote>
<p>Most of the modern IDEs already have support for mixed content, including TypeScript files.
If you are using <a href="https://code.visualstudio.com/">Visual Studio Code</a> for development,
then you already have syntax highlighting for HTML and CSS.</p>
<p>Let's edit the Header component template to take multiple lines like in the example below:</p>
<pre><code class="language-ts">// src/app/components/header.component.ts
@Component({
  selector: 'app-header',
  template: `
    &lt;div&gt;
        &lt;div&gt;{{ title }}&lt;/div&gt;
    &lt;/div&gt;
  `
})
export class HeaderComponent {
  title: string = 'Header';
}
</code></pre>
<p>Using backtick characters also allows you to have single and double quotes in HTML without any additional escaping or string concatenation.
You are using the same HTML content inlined as you would have in separate files.</p>
<p>Typically you may want to use inline templates only when your component view is small.</p>
<h3 id="external-templates"><a class="header" href="#external-templates">External Templates</a></h3>
<p>The HTML code in the templates usually grows over time and becomes less maintainable.
That is why storing HTML in the separate files may be more practical and productive.</p>
<p>The <code>@Component</code> decorator provides support for external templates through the &quot;templateUrl&quot; option.
Please note that you should set only &quot;template&quot; or &quot;templateUrl&quot;, you cannot define both of them at the same time.</p>
<p>Let's now update our Header component we created earlier and move its HTML template to a separate file.</p>
<pre><code class="language-html">&lt;!-- src/app/components/header.component.html --&gt;
&lt;div&gt;
    &lt;div&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>The <code>templateUrl</code> property should always point to a path relative to the component class file.
In our case, we put both files together in the same directory and update decorator declaration accordingly.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts
@Component({
  selector: 'app-header',
  templateUrl: './header.component.html'
})
export class HeaderComponent {
  title: string = 'Header';
}
</code></pre>
<p>Typically developers put them next to the component class implementation and give the same name for the file as the component:</p>
<ul>
<li>header.component.html</li>
<li>header.component.ts</li>
</ul>
<blockquote>
<p><strong>External Files</strong></p>
<p>External files are the most convenient and recommended way of storing your components' HTML templates.</p>
</blockquote>
<h2 id="styles"><a class="header" href="#styles">Styles</a></h2>
<p>Similar to the HTML templates, the <code>@Component</code> decorator also provides support for CSS styles in either inline or external form.</p>
<h3 id="inline-styles"><a class="header" href="#inline-styles">Inline Styles</a></h3>
<p>If your component is small and you decided to use inline HTML templates then high chances you may want to inline CSS styles as well.</p>
<p>The &quot;styles&quot; property of the <code>@Component</code> decorator is used to store an array of CSS styles that Angular applies to the component at runtime.</p>
<p>To test that in practice let's add a couple of class names to the HTM elements inside the component's template.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({
    selector: 'app-header',
    template: `
        &lt;div class=&quot;app-header&quot;&gt;
            &lt;div class=&quot;app-header-title&quot;&gt;
                {{ title }}
            &lt;/div&gt;
        &lt;/div&gt;
    `
})
export class HeaderComponent { ... }
</code></pre>
<p>We just added &quot;app-header&quot; and &quot;app-header-title&quot; classes, and it is time to provide some CSS for those elements.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({
    selector: 'app-header',
    template: `
        &lt;div class=&quot;app-header&quot;&gt;
            &lt;div class=&quot;app-header-title&quot;&gt;
                {{ title }}
            &lt;/div&gt;
        &lt;/div&gt;
    `,
    styles: [`
        .app-header {
            border: 1px solid gray;
            padding: 4px;
        }
        .app-header-title {
            font-weight: bold;
        }
    `]
})
export class HeaderComponent { ... }
</code></pre>
<p>Now if you compile and run your web application you should see a nice grey border around your Header component.
Also, the &quot;Header&quot; title should have the bold font style.</p>
<p><img src="images/components-01.png" alt="Inline Component Styles" /></p>
<p>As with the inline templates, you may want to inline your style files only for the small components.</p>
<h3 id="external-styles"><a class="header" href="#external-styles">External Styles</a></h3>
<p>The CSS styles tend to grow over time even faster than HTML content.
So it is recommended to move them to the separate files at early stages.</p>
<p>Similar to external HTML templates Angular provides support for external CSS.
You can use &quot;styleUrls&quot; property to provide an array of the URLs with relative paths to corresponding files.</p>
<p>You already know how to use external HTML templates with your components.
Let's now extract the CSS into a separate file as well.
Typically the main style file is called after the parent component class, in our case, it becomes &quot;header.component.css&quot;.</p>
<pre><code class="language-css">/* src/app/components/header.component.css */

.app-header {
  border: 1px solid gray;
  padding: 4px;
}

.app-header-title {
  font-weight: bold;
}
</code></pre>
<p>You should now have &quot;Header&quot; component split into the three separate files:</p>
<ul>
<li>header.component.css</li>
<li>header.component.html</li>
<li>header.component.ts</li>
</ul>
<p>With the changes to @Component decorator properties, the component implementation should now look like the following:</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  styleUrls: [
    './header.component.css'
  ]
})
export class HeaderComponent { ... }
</code></pre>
<p>Visually the component should look the same as with the inline CSS styles.
Once you compile and run your web application, the main page looks like on the screenshot below.</p>
<p><img src="images/components-01.png" alt="External Component Styles" /></p>
<blockquote>
<p><strong>External files</strong></p>
<p>External files are the most convenient and recommended way of storing your components' CSS stylesheets.</p>
</blockquote>
<h2 id="input-properties"><a class="header" href="#input-properties">Input properties</a></h2>
<p>The <code>@Input</code> decorator is used to mark a class property that binds to incoming data.</p>
<p>Let's take a closer look at our Header component created earlier in this chapter.</p>
<p>The component exposes a &quot;title&quot; property of the &quot;string&quot; type and with the default value set to &quot;Header&quot;.</p>
<pre><code class="language-ts">@Component({...})
export class HeaderComponent {
  title: string = 'Header';
}
</code></pre>
<p>We have also provided an HTML template that binds to the underlying &quot;title&quot; property.</p>
<pre><code class="language-html">&lt;div class=&quot;app-header&quot;&gt;
  &lt;div class=&quot;app-header-title&quot;&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>As you can notice from the example above the major limitation of the Header component is that we cannot change the header title text from the outside.</p>
<p>The only way we can use it so far is by utilizing plain selector:</p>
<pre><code class="language-html">&lt;app-header&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Next, let's provide data-binding support for the &quot;title&quot; property using <code>@Input</code> decorator as following:</p>
<pre><code class="language-ts">//src/app/components/header.component.ts

import { ..., Input } from '@angular/core';

@Component({ ... })
export class HeaderComponent {

  @Input()
  title: string = 'Header';
}
</code></pre>
<p>You can now use Header component with custom title values.
Set the value to &quot;My Header&quot; to test that in action.</p>
<pre><code class="language-html">&lt;app-header title=&quot;My Header&quot;&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>This time once your web application compiles and starts the Header should look like on the picture below:</p>
<p><img src="images/components-input-01.png" alt="" /></p>
<p>You can also bind &quot;title&quot; property value to another property.
For example, imagine a scenario when main application component maintains global settings and initializes Header and Footer content.</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({ ... })
export class AppComponent {
  title = 'app';
}
</code></pre>
<p>In this case, you can bind the Header title like following:</p>
<pre><code class="language-html">&lt;app-header [title]=&quot;title&quot;&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Reload the page, and you are going to see the header having now the &quot;app&quot; title as per main application component implementation.</p>
<p><img src="images/components-input-02.png" alt="" /></p>
<blockquote>
<p><strong>Binding to expressions</strong></p>
<p>Keep in mind that you are binding to JavaScript expressions when using square brackets with element attributes.</p>
<p>The example above can also be changed to bind to a string or component class method.
For example <code>&lt;app-header [title]=&quot;getHeaderTitle()&quot;&gt;</code> or <code>&lt;app-header [title]=&quot;'Hello ' + 'world'&quot;&gt;</code>.</p>
</blockquote>
<p>By default, the <code>@Input</code> takes the name of the decorated property when setting up the bindings.
You can, however, change the name of the resulting HTML attribute.</p>
<p>@Input decorator accepts additional optional property alias &quot;bindingPropertyName&quot; to redefine the name to use in the template.
Let's change the binding name of the &quot;title&quot; property to the &quot;title-text&quot; value.</p>
<pre><code class="language-ts">export class HeaderComponent {

    @Input('title-text')
    title: string = 'Header';

}
</code></pre>
<p>From now on you should be settings &quot;title-text&quot; attribute in HTML templates when using Header component with the custom title.</p>
<pre><code class="language-html">&lt;app-header title-text=&quot;My Title&quot;&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Please note that you are going to deal with two different property names at the same time when using input aliases.
The component template still references property by the original name &quot;title&quot; while externally this property is known as &quot;title-text&quot;:</p>
<pre><code class="language-html">&lt;div class=&quot;app-header&quot;&gt;
  &lt;div class=&quot;app-header-title&quot;&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p><strong>Avoid aliasing inputs and outputs</strong></p>
<p>According to the Angular Style Guide (<a href="https://angular.io/guide/styleguide#style-05-13">Style 05-13</a>),
you should avoid using alias for <code>@Input</code> and <code>@Output</code> decorators except when is needed and serves an important purpose.</p>
<p>Two names for the same property is confusing and may require additional documentation and maintenance over time.</p>
</blockquote>
<h2 id="output-events"><a class="header" href="#output-events">Output Events</a></h2>
<p>You use <code>@Output</code> decorator in combination with the <code>EventEmitter</code> type to create component events.</p>
<p>To better understand how events are used and work let's introduce and see a component event in action.</p>
<h3 id="raising-events"><a class="header" href="#raising-events">Raising Events</a></h3>
<p>We are going to extend our Header component with a &quot;click&quot; event.
Every time the header title gets clicked the component is going to raise a &quot;titleClick&quot; event.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

import { ..., Output, EventEmitter } from '@angular/core';

@Component({...})
export class HeaderComponent {
    // ...

    @Output()
    titleClick = new EventEmitter();
}
</code></pre>
<p>Now to raise the newly introduced event from the component, we call its <code>next</code> method:</p>
<pre><code class="language-ts">this.titleClick.next();
</code></pre>
<p>Next, we need to wire component template with the underlying method <code>handleTitleClick</code>.
The latter is going to be responsible for raising the corresponding <code>titleClick</code> event.</p>
<pre><code class="language-html">&lt;!-- src/app/components/header.component.html --&gt;

&lt;div class=&quot;app-header&quot;&gt;
  &lt;div class=&quot;app-header-title&quot; (click)=&quot;handleTitleClick()&quot;&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>The <code>handleTitleClick</code> implementation can be as follows:</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({...})
export class HeaderComponent {
    ...

    @Output()
    titleClick = new EventEmitter();

    handleTitleClick() {
        this.titleClick.next();
    }
}
</code></pre>
<h3 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h3>
<p>We have extended our Header component to raise an event once a user clicks the title.
Now let's make our main application handle this event and display click counter on the page.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-header
  [title]=&quot;title&quot;
  (titleClick)=&quot;onTitleClicked()&quot;&gt;
&lt;/app-header&gt;

&lt;div&gt;
  Header clicks: {{ headerClicks }}
&lt;/div&gt;

&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>As you can see from the code above the main application component subscribes
to the <code>titleClick</code> event and uses <code>onTitleClicked</code> method as an event handler.</p>
<p>The component also displays the <code>headerClicks</code> property value for us to see the event handler works.
The final thing we need right now is incrementing the counter property like in the code below:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({...})
export class AppComponent {

    headerClicks = 0;

    onTitleClicked() {
        this.headerClicks += 1;
    }

}
</code></pre>
<p>Now if you run the web application and click several times on the header text,
you should see the clicks counter increase in real time.</p>
<p><img src="images/components-output-01.png" alt="" /></p>
<h3 id="typed-events"><a class="header" href="#typed-events">Typed Events</a></h3>
<p>The EventEmitter type we used for earlier is a generic type, and by default takes the type variable of <code>any</code>.</p>
<pre><code class="language-text">EventEmitter&lt;any&gt;
</code></pre>
<p>In many cases, you may want to provide the additional event arguments to enable better handling of your component events.
For example, a &quot;click&quot; event may expose details on the mouse cursor position or a &quot;textChanged&quot; event that exposes old and new text values.</p>
<p>In the previous section, we have already created a Header component that raises generic &quot;titleClick&quot; event with no arguments.
To compare both approaches let's now update Footer component with the similar event but of a specific type.</p>
<p>The Footer is going to count the number of clicks itself and provide the value as part of the event.
The main application is no longer required to keep track on clicks as it is going to get exact values from the corresponding event arguments.</p>
<p>If you remember, we created a Footer component using the following Angular CLI command:</p>
<pre><code class="language-sh">ng g component components/footer
</code></pre>
<p>First, create a <code>FooterClickedEvent</code> class to hold the clicks-related information for our <code>titleClicked</code> event:</p>
<pre><code class="language-ts">// src/app/components/footer/footer-clicked.event.ts

export class FooterClickedEvent {

    constructor(public readonly totalClicks: number = 0) {
    }

}
</code></pre>
<p>For the sake of simplicity, we are going to create a class with a single read-only property <code>totalClicks</code>
we assign in the constructor, and that defaults to zero if not provided.</p>
<p>Next, edit your footer component and update its code with the following pieces
that add a <code>title</code> input property and <code>titleClicked</code> output event:</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

import { ..., Output, EventEmitter } from '@angular/core';
import { FooterClickedEvent } from './footer-clicked.event';

@Component({...})
export class FooterComponent {

    @Input()
    title = 'Footer';

    @Output()
    titleClick = new EventEmitter&lt;FooterClickedEvent&gt;();

}
</code></pre>
<p>As you can see above, we also declare a private property <code>totalClicks</code> to hold the overall clicks count.</p>
<p>Note how we use <code>EventEmitter</code> type this time.
Using <code>FooterClickedEvent</code> as an EventEmitter's type variable allows us now to create an instance of the given type and emit as an event.</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

@Component({...})
export class FooterComponent {
    ...

    private totalClicks = 0;

    handleTitleClick() {
        const event = new FooterClickedEvent(++this.totalClicks)
        this.titleClick.next(event);
    }

}
</code></pre>
<p>Now we can update the component template to display the title and handle mouse clicks:</p>
<pre><code class="language-html">&lt;!-- src/app/components/footer/footer.component.html --&gt;

&lt;p&gt;
  &lt;span (click)=&quot;handleTitleClick()&quot;&gt;{{ title }}&lt;/span&gt;
&lt;/p&gt;
</code></pre>
<p>Every time user clicks the &quot;title&quot; element of the Footer, the component is going to increment clicks counter
and raise an event with its actual value.</p>
<h3 id="accessing-event-parameters"><a class="header" href="#accessing-event-parameters">Accessing Event Parameters</a></h3>
<p>Angular provides a way to access the original event by using a special <code>$event</code> variable that you can pass to your handlers.</p>
<pre><code class="language-html">&lt;app-footer
  title=&quot;My footer&quot;
  (titleClick)=&quot;onHeaderClicked($event)&quot;&gt;
&lt;/app-footer&gt;
</code></pre>
<p>In our current case, we handle the <code>titleClick</code> event and pass original <code>FooterClickedEvent</code> to the <code>onHeaderClicked</code> handler inside application controller.
That provides access to the <code>totalClicks</code> property we created earlier.</p>
<blockquote>
<p><strong>DOM events</strong></p>
<p>Please keep in mind that &quot;$event&quot; usage applies to all events, either custom or standard DOM ones.
For instance, you can inspect &quot;click&quot;, &quot;hover&quot;, &quot;input&quot; and many other DOM events from within your class methods.</p>
</blockquote>
<p>Let's now update our main application component to display the number of times the user clicked the Footer.</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...
import { FooterClickedEvent } from './components/footer/footer-clicked.event';

@Component({...})
export class AppComponent {
    ...
    footerClicks = 0;

    onHeaderClicked(event: FooterClickedEvent) {
        this.footerClicks = event.totalClicks;
    }
}
</code></pre>
<p>As you can see in the example above, we now can import the <code>FooterClickedEvent</code> type and
use with the event handler parameters to get type checking and code completion support in your IDE.</p>
<p>Finally, let's update the main component template to display click counters for the Footer alongside the Header.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-header
  [title]=&quot;title&quot;
  (titleClick)=&quot;onTitleClicked()&quot;&gt;
&lt;/app-header&gt;

&lt;div&gt;Header clicks: {{ headerClicks }}&lt;/div&gt;
&lt;div&gt;Footer clicks: {{ footerClicks }}&lt;/div&gt;

&lt;app-footer
  title=&quot;My footer&quot;
  (titleClick)=&quot;onHeaderClicked($event)&quot;&gt;
&lt;/app-footer&gt;
</code></pre>
<p>You can now run your web application and make several clicks on Header and Footer components to see all event handlers in action.
You should see results similar to the following:</p>
<p><img src="images/components-output-02.png" alt="" /></p>
<h3 id="aliased-outputs"><a class="header" href="#aliased-outputs">Aliased Outputs</a></h3>
<p>Similar to the <code>@Input</code> decorator the <code>@Output</code> one also supports custom aliases for event names
and takes the name of the decorated property as the default value.</p>
<p>In the previous examples, we used the <code>titleClick</code> for the output property name:</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

@Component({...})
export class FooterComponent {
    // ...

    @Output()
    titleClick = new EventEmitter&lt;FooterClickedEvent&gt;();
}
</code></pre>
<p>You could also provide the <code>title-click</code> alias for the event like below:</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

@Component({...})
export class FooterComponent {
    // ...

    @Output('title-click')
    titleClick = new EventEmitter&lt;FooterClickedEvent&gt;();
}
</code></pre>
<p>In this case the &quot;official&quot; (or public) event name for the Footer's <code>titleClick</code> component would be <code>title-click</code>, and not <code>titleClick</code>:</p>
<pre><code class="language-html">&lt;app-footer
  title=&quot;My footer&quot;
  (title-click)=&quot;onHeaderClicked($event)&quot;&gt;
&lt;/app-footer&gt;
</code></pre>
<blockquote>
<p><strong>Avoid aliasing inputs and outputs</strong></p>
<p>According to the Angular Style Guide (<a href="https://angular.io/guide/styleguide#style-05-13">Style 05-13</a>),
you should avoid using alias for the <code>@Input</code> and <code>@Output</code> decorators except when is needed and serves an important purpose.</p>
<p>Two names for the same property is confusing and may require additional documentation and maintenance over time.</p>
</blockquote>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>Every Angular component can declare its own set of providers.
The use of local providers allows developers to replace global instances of services,
and register and use a new copy of the service for the given component and all child components.</p>
<p>Let's see how local component providers work in practice.
We are going to need a new service 'ClickCounterService' that you can generate with the following Angular CLI command:</p>
<pre><code class="language-sh">ng g service click-counter
</code></pre>
<p>The service is going to keep track of the user clicks on the elements.
Our components should notify the service upon every click,
and also subscribe to the service events to get notifications on clicks from other components.</p>
<p>Add the <code>clicks</code> property to the service to hold total amount of clicks happened across the application.
Then, add the <code>clicked</code> event to allow components to subscribe and perform custom actions if needed.
Finally, implement the <code>click</code> method that increments the click counter and emits the corresponding event at the same time.</p>
<pre><code class="language-ts">import { Injectable, EventEmitter } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class ClickCounterService {

  clicks = 0;

  clicked = new EventEmitter&lt;number&gt;();

  click() {
    this.clicks += 1;
    this.clicked.emit(this.clicks);
  }

}
</code></pre>
<p>Let's register the newly created &quot;ClickCounterService&quot; service as part of the global providers, in the main application module.</p>
<blockquote>
<p><strong>Registering service</strong></p>
<p>Given that developers can register services in different places,
the Angular CLI does not perform default registration and does not modify &quot;app.module.ts&quot; file
like it does for other Angular entities.</p>
</blockquote>
<p>Please refer to the code below for an example of service registration:</p>
<pre><code class="language-ts">// src/app/app.module.ts

// ...
import { ClickCounterService } from './click-counter.service';

@NgModule({
  ...
  providers: [
    ClickCounterService
  ],
  ...
})
export class AppModule { }
</code></pre>
<p>For the next step, we are going to need three simple components.
You can quickly generate them using the following Angular CLI commands:</p>
<pre><code class="language-sh">ng g component componentA
ng g component componentB
ng g component componentC
</code></pre>
<p>Now, replace the content of the main application component template with the following code:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-component-a&gt;&lt;/app-component-a&gt;
&lt;app-component-b&gt;&lt;/app-component-b&gt;
&lt;app-component-c&gt;&lt;/app-component-c&gt;
</code></pre>
<p>Once you build and run the application, you should see the following content on the main page:</p>
<pre><code class="language-text">component-a works!
component-b works!
component-c works!
</code></pre>
<p>Now, let's integrate one of the components with the &quot;ClickCounterService&quot; service we introduced earlier.</p>
<p>Our component is going to have an HTML button that invokes <code>onClick</code> method upon every click.
The component also subscribes to the service's &quot;clicked&quot; event to update the local <code>totalClicks</code> property and display it to the user.</p>
<pre><code class="language-ts">// src/app/component-a/component-a.component.ts

import { Component, OnInit } from '@angular/core';
import { ClickCounterService } from '../click-counter.service';

@Component({
  selector: 'app-component-a',
  templateUrl: './component-a.component.html',
  styleUrls: ['./component-a.component.css']
})
export class ComponentAComponent implements OnInit {

  totalClicks = 0;

  constructor(private clickService: ClickCounterService) { }

  ngOnInit() {
    this.clickService.clicked.subscribe((clicks) =&gt; {
      this.totalClicks = clicks;
    });
  }

  onClick() {
    this.clickService.click();
  }

}
</code></pre>
<p>Also, replace the component template content with the following markup:</p>
<pre><code class="language-html">&lt;!-- src/app/component-a/component-a.component.html --&gt;

Component A &lt;br&gt;
Clicks: {{ totalClicks }} &lt;br&gt;
&lt;button (click)=&quot;onClick()&quot;&gt;Click&lt;/button&gt;
</code></pre>
<p>Run the application or switch to the running one. Click the component button multiple times to see the counter updates.</p>
<p><img src="images/component-providers-01.png" alt="" /></p>
<p>Repeat the same procedure for other two components we got.
All three components should display the total number of clicks fetched from the server, and have a button for the user to click.</p>
<p>Also, let's slightly improve the main application template and add dividers for better visibility:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-component-a&gt;&lt;/app-component-a&gt;
&lt;hr&gt;
&lt;app-component-b&gt;&lt;/app-component-b&gt;
&lt;hr&gt;
&lt;app-component-c&gt;&lt;/app-component-c&gt;
</code></pre>
<p>Switch to your running application and try clicking one of the buttons several times.
You should see that all click counters get updated automatically with the same value.
That is an expected behavior because all we got three components powered by the same instance of the &quot;ClickCounterService&quot; service.
Every time we click a button, the service notifies other components that update local counter properties and display labels.</p>
<p><img src="images/component-providers-02.png" alt="" /></p>
<p>Now, let's see what happens if one of the components, let it be the <code>Component B</code>, declares its own <code>providers</code> collection.
Import the &quot;ClickCounterService&quot; and declare it as in the example below:</p>
<pre><code class="language-ts">// src/app/component-b.component.ts

// ...
import { ClickCounterService } from '../click-counter.service';

@Component({
  selector: 'app-component-b',
  templateUrl: './component-b.component.html',
  styleUrls: ['./component-b.component.css'],
  providers: [
    ClickCounterService
  ]
})
export class ComponentBComponent implements OnInit {
  // ...
}
</code></pre>
<p>If now you start clicking on the first component, only &quot;Component A&quot; and &quot;Component C&quot; are going to update the labels.
The &quot;Component B&quot; should remain with the zero value.</p>
<p><img src="images/component-providers-03.png" alt="" /></p>
<p>As you can see, the &quot;Component B&quot; declares its local instance of the service, so it does not react to the events raised by the global one.
Now if you click the &quot;Component B&quot; button several times, its counter label should update separately from other components.
Moreover, other components are not going to update on &quot;Component B&quot; clicks, as they are listening to the global service events.</p>
<p><img src="images/component-providers-04.png" alt="" /></p>
<p>The component-level provider is a great feature.
It allows you to have more than one instance of the service or to have custom service implementation
or replacement for a particular component and all child components that you use in its template.</p>
<blockquote>
<p><strong>Advanced feature</strong></p>
<p>You should be very careful and use this feature only when it is necessary
as it is quite easy to introduce an issue when creating multiple instances of the same service type.
For example the Authentication Service. Typically you may want always to have only one instance,
as the service might keep the authentication state or some other critical data,
and having more than one service leads to application issues.</p>
</blockquote>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/blob/master/angular/components/component-providers">angular/components/component-providers</a></strong> folder.</p>
</blockquote>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p>The host property is an object of a Map type and specifies the events, actions,
properties and attributes related to the resulting element.</p>
<p>Use the following Angular CLI command to generate a new <code>host-events</code> component for the tests:</p>
<pre><code class="language-sh">ng g component host-events
</code></pre>
<p>Also, replace the content of the main application component template with your component declaration:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Host events:&lt;/h2&gt;
&lt;app-host-events&gt;&lt;/app-host-events&gt;
</code></pre>
<p>Run the application and ensure the main page looks similar to the following:</p>
<p><img src="images/component-host-01.png" alt="" /></p>
<h3 id="css-class"><a class="header" href="#css-class">CSS Class</a></h3>
<p>Your component or directive can assign a class name to the corresponding DOM element that serves the root of the component.
For example setting the class name to the <code>host-events</code> value looks like the following:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts

@Component({
  selector: 'app-host-events',
  templateUrl: './host-events.component.html',
  styleUrls: ['./host-events.component.css'],
  host: {
    class: 'host-events'
  }
})
export class HostEventsComponent implements OnInit {
  //...
}
</code></pre>
<p>At runtime, if you use the &quot;Inspect element&quot; tool to view the compiled HTML output, it should look similar to the following:</p>
<pre><code class="language-html">&lt;app-host-events _ngcontent-c0=&quot;&quot; class=&quot;host-events&quot; _nghost-c1=&quot;&quot;&gt;
    &lt;p _ngcontent-c1=&quot;&quot;&gt;
        host-events works!
    &lt;/p&gt;
&lt;/app-host-events&gt;
</code></pre>
<p>Note that the main <code>app-host-events</code> element has now the <code>host-events</code> class name associated with it.</p>
<p>You can also set multiple classes based on property values using the following format:</p>
<pre><code class="language-text">host: {
    '[class.&lt;className1&gt;]': '&lt;statement1&gt;',
    '[class.&lt;classNameN&gt;]': '&lt;statementN&gt;'
}
</code></pre>
<p>Let's bind a couple of CSS class names to the component class properties:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts

@Component({
  selector: 'app-host-events',
  templateUrl: './host-events.component.html',
  styleUrls: ['./host-events.component.css'],
  host: {
    '[class.is-invalid]': 'isInvalid',
    '[class.is-readonly]': 'isReadonly'
  }
})
export class HostEventsComponent implements OnInit {
    // ...

    isInvalid: boolean = false;
    isReadonly: boolean = false;
}
</code></pre>
<p>The class values are toggled based on the corresponding property values.</p>
<p>For example, the <code>is-invalid</code> is appended to the class list of the DOM element as soon as the <code>isInvalid</code> property value turns to <code>true</code>,
also, is automatically removed from the class list if it has the value of <code>false</code>.</p>
<h3 id="host-events"><a class="header" href="#host-events">Host Events</a></h3>
<p>The component or directive you create can also use <code>host</code> metadata property to bind element events to the class methods.
The usage format, in this case, is as follows:</p>
<pre><code class="language-text">host: {
    '(&lt;event&gt;)': '&lt;statement&gt;'
}
</code></pre>
<p>To test the event bindings in action let's wire the <code>mouseenter</code> and <code>mouseleave</code> DOM events
with the <code>onMouseEnter</code> and <code>onMouseLeave</code> methods that are going to change the <code>color</code> property value:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-host-events',
  templateUrl: './host-events.component.html',
  styleUrls: ['./host-events.component.css'],
  host: {
    class: 'host-events',
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()'
  }
})
export class HostEventsComponent {

  color = 'black';

  onMouseEnter() {
    this.color = 'red';
  }

  onMouseLeave() {
    this.color = 'black';
  }

}
</code></pre>
<p>Finally, update the component template to use the <code>color</code> property like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/host-events/host-events.component.html --&gt;

&lt;p [style.color]=&quot;color&quot;&gt;
  host-events works!
&lt;/p&gt;
</code></pre>
<p>Now, switch to the running application and try moving the mouse cursor over the component text.
You should see the colour of the text changing automatically upon mouse events.</p>
<p><img src="images/component-host-02.png" alt="" /></p>
<p>Your component can also listen to global events using the following format:</p>
<pre><code class="language-text">host: {
    '(&lt;target&gt;:&lt;event&gt;)': '&lt;statement&gt;'
}
</code></pre>
<p>Where 'target' can be of one the following values:</p>
<ul>
<li>window</li>
<li>document</li>
<li>body</li>
</ul>
<p>For example, the component can listen to 'window.resize' events and adapt the layout accordingly:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts
// ...

@Component({
  // ...
  
  host: {
    class: 'host-events',
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()',
    '(window:resize)': 'onWindowResize()'
  }
})
export class HostEventsComponent {

  // ...

  onWindowResize() {
    console.log('Window resized');
  }

}
</code></pre>
<p>If you run the developer tools in your browser and try resizing the browser window,
you should notice the component reacts on that and writes corresponding messages to the console log.</p>
<h3 id="host-attributes"><a class="header" href="#host-attributes">Host Attributes</a></h3>
<p>The Angular framework allows you to map multiple HTML attributes to the class properties or static string values.
Let's set the <code>role</code> and <code>aria-label</code> attributes from within the host metadata:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts
// ...

@Component({
  // ...
  
  host: {
    class: 'host-events',
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()',
    '(window:resize)': 'onWindowResize()',
    'role': 'button',
    'aria-label': 'Demo button'
  }
})
export class HostEventsComponent {
  // ...
}
</code></pre>
<p>As soon as the page gets rendered, you can inspect the compiled HTML layout to check the element attributes.
The <code>app-host-events</code> element now contains the expected attributes:</p>
<pre><code class="language-html">&lt;app-host-events _ngcontent-c0=&quot;&quot; aria-label=&quot;Demo button&quot; class=&quot;host-events&quot; role=&quot;button&quot; _nghost-c1=&quot;&quot;&gt;
    &lt;p _ngcontent-c1=&quot;&quot; style=&quot;color: black;&quot;&gt;
        host-events works!
    &lt;/p&gt;
&lt;/app-host-events&gt;
</code></pre>
<h3 id="host-properties"><a class="header" href="#host-properties">Host Properties</a></h3>
<p>Finally, you can bind component properties to element properties.
That might be useful when developing Angular directives.</p>
<p>For example, a directive that automatically changes the button value based on one of its properties can look like the following:</p>
<pre><code class="language-ts">// src/app/host-properties.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appHostProperties]',
  host: {
    '[innerHTML]': 'value'
  }
})
export class HostPropertiesDirective {

  value = 'Custom Value';

}
</code></pre>
<p>Now, let's define a simple button and see the directive in action:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Host events:&lt;/h2&gt;
&lt;app-host-events&gt;&lt;/app-host-events&gt;

&lt;hr&gt;
&lt;button appHostProperties&gt;Click me&lt;/button&gt;
</code></pre>
<p>Note that we provided the button text in the HTML template.
Switch back to the browser window and ensure the button value got changed by the directive as per the host metadata settings.</p>
<p><img src="images/component-host-03.png" alt="" /></p>
<p>Similar to the CSS classes, you can provide values for multiple attributes of the decorated DOM element using the following syntax:</p>
<pre><code class="language-text">host: {
    '[attr.&lt;name1&gt;]': '&lt;statement1&gt;',
    '[attr.&lt;nameN&gt;]': '&lt;statementN&gt;',
}
</code></pre>
<p>Let's bind a &quot;custom1&quot; attribute to the &quot;attrValue&quot; property of the class to check how that feature works.</p>
<pre><code class="language-ts">import { Directive } from '@angular/core';

@Directive({
  selector: '[appHostProperties]',
  host: {
    '[innerHTML]': 'value',
    '[attr.custom1]': 'attrValue'
  }
})
export class HostPropertiesDirective {

  value = 'Custom Value';
  attrValue = 'some attribute value';
}

</code></pre>
<p>If you remember, we got a button element declared in the main application template like below:</p>
<pre><code class="language-html">&lt;button appHostProperties&gt;Click me&lt;/button&gt;
</code></pre>
<p>At the runtime, the element gets a custom attribute from the directive:</p>
<pre><code class="language-html">&lt;button _ngcontent-c0=&quot;&quot; apphostproperties=&quot;&quot; custom1=&quot;some attribute value&quot;&gt;Custom Value&lt;/button&gt;
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/component-host">angular/components/component-host</a></strong> folder.</p>
</blockquote>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>There may be scenarios when you need accessing child components from your current component that contains them.
That becomes useful when you need calling public methods or change properties of the children.</p>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/component-queries">angular/components/component-queries</a></strong> folder.</p>
</blockquote>
<h3 id="preparing-the-project"><a class="header" href="#preparing-the-project">Preparing the Project</a></h3>
<p>Let's start by creating a new Angular project with the help of Angular CLI, and creating two components <code>List</code> and <code>ListItem</code> to experiment.</p>
<pre><code class="language-sh">ng g component list
ng g component list-item
</code></pre>
<p>Extend the generated List component with an extra property <code>title</code> marked with the <code>@Input</code> decorator.</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

import { /*...,*/ Input } from '@angular/core';

@Component({/*...*/})
export class ListComponent implements OnInit {

  @Input()
  title = 'List Title';

  // ...
}
</code></pre>
<p>Next, update the component HTML template to display the <code>title</code> value,
and also the <code>ng-content</code> component to render any other components or HTML elements the end developers provide:</p>
<pre><code class="language-html">&lt;!-- src/app/list/list.component.html --&gt;

&lt;div&gt;{{ title }} &lt;/div&gt;
&lt;ng-content&gt;&lt;/ng-content&gt;
</code></pre>
<p>Now you can declare a List element in the main application component template, and also put several ListItem components inside its tags:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;
</code></pre>
<p>At runtime, the code above should give you the following output on the main page:</p>
<p><img src="images/component-queries-01.png" alt="" /></p>
<h3 id="viewchild"><a class="header" href="#viewchild">@ViewChild</a></h3>
<p>The <code>@ViewChild</code> decorator allows you to retrieve and reference the component or directive from the current component View.</p>
<p>For example, the main application component can gain access to the List component we have defined in its HTML template,
and modify properties of the component instance from the code.</p>
<p>To do that we need to use a <code>@ViewChild</code> decorator with the target type.</p>
<p>You can access the property decorated with the <code>@ViewChild</code> only after component's View initializes.
The <code>AfterViewInit</code> interface and corresponding method is the most appropriate place for that.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ ViewChild, AfterViewInit } from '@angular/core';
import { ListComponent } from './list/list.component';

@Component({...})
export class AppComponent implements AfterViewInit {

  @ViewChild(ListComponent)
  list: ListComponent;

  ngAfterViewInit() {
    this.list.title = 'custom list title';
  }
}
</code></pre>
<p>In the code snippet above, we change the title of the child List component from code.
Switch to the browser running your application, and you should see the following:</p>
<p><img src="images/component-queries-02.png" alt="" /></p>
<p>The component query is not limited to the target type reference.
You can also use local references and use string identifiers, for example, mark the List with the &quot;myList&quot; id:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list #myList&gt;
  &lt;!-- ... --&gt;
&lt;/app-list&gt;
</code></pre>
<p>Now you can use this id with the <code>@ViewChild</code> decorator if needed:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent implements AfterViewInit {

  @ViewChild('myList')
  list: ListComponent;

  // ...
}
</code></pre>
<h3 id="viewchildren"><a class="header" href="#viewchildren">@ViewChildren</a></h3>
<p>If you declare more than one List component, you should notice that every time only the first instance is fetched.
To get a reference to all the child instances of the particular component type you need to use a <code>@ViewChildren</code> decorator.</p>
<p>Let's have two List components separated by a horizontal line like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;

&lt;hr&gt;

&lt;app-list&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;
</code></pre>
<p>Now create a <code>lists</code> property in the underlying component class to reference all &quot;ListComponent&quot; instances after View gets initialized:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ QueryList, ViewChildren } from '@angular/core';
import { ListComponent } from './list/list.component';

@Component({/*...*/})
export class AppComponent implements AfterViewInit {

  @ViewChild(ListComponent)
  list: ListComponent;

  @ViewChildren(ListComponent)
  lists: QueryList&lt;ListComponent&gt;;

  // ...
}
</code></pre>
<p>For the next step, we are going to update the <code>title</code> property of every List component in the View:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ AfterViewInit, QueryList, ViewChildren } from '@angular/core';
import { ListComponent } from './list/list.component';

@Component({/*...*/})
export class AppComponent implements AfterViewInit {
  // ...

  @ViewChildren(ListComponent)
  lists: QueryList&lt;ListComponent&gt;;

  ngAfterViewInit() {
    let i = 0;
    this.lists.forEach(l =&gt; {
      l.title = 'Custom title #' + (i++);
    });
  }
}
</code></pre>
<p>Switch back to the browser and once the application compiles and restarts you should see the following:</p>
<p><img src="images/component-queries-03.png" alt="ViewChildren Queries" /></p>
<h3 id="contentchild"><a class="header" href="#contentchild">@ContentChild</a></h3>
<p>The <code>@ViewChild</code> provides access only to components and directives that are part of the view but not inside the <code>ng-content</code> tags.
You need to use <code>@ContentChild</code> decorator to work with the elements inside <code>ng-content</code> container.</p>
<p>If you remember, the List component template already features the <code>ng-template</code>:</p>
<pre><code class="language-html">&lt;!-- src/app/list/list.component.html --&gt;

&lt;div&gt;{{ title }} &lt;/div&gt;
&lt;ng-content&gt;&lt;/ng-content&gt;
</code></pre>
<p>Update the ListItemComponent component class with the &quot;title&quot; property like in the following example:</p>
<pre><code class="language-ts">// src/app/list-item/list-item.component.ts
// ...

@Component({/*...*/})
export class ListItemComponent {

  title = 'list-item works!';

}
</code></pre>
<p>For the sake of simplicity just replace the content of the ListItem component template with the next block of HTML:</p>
<pre><code class="language-html">&lt;!-- src/app/list-item/list-item.component.html --&gt;

&lt;p&gt;
  {{ title }}
&lt;/p&gt;
</code></pre>
<p>For a start, let's access the very first entry of the List content collection
by introducing a <code>firstListItem</code> property decorated with the <code>@ContentChild</code>.</p>
<p>As soon as component content gets initialized, we are going to update the title of the referenced item.</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

import { /*...,*/ ContentChild, AfterContentInit } from '@angular/core';
import { ListItemComponent } from '../list-item/list-item.component';

@Component({/*...*/})
export class ListComponent implements AfterContentInit {
  ...

  @ContentChild(ListItemComponent)
  firstListItem: ListItemComponent;

  ngAfterContentInit() {
    this.firstListItem.title = 'first item';
  }
}
</code></pre>
<p>Note that your component now needs to implement the <code>AfterContentInit</code> interface
and have the corresponding <code>ngAfterContentInit</code> method implementation.
That is the most recommended place to work with the elements provided using the <code>@ContentChild</code> decorator.</p>
<p>Switch to the browser, and you should now look the following on the main page:</p>
<p><img src="images/component-queries-04.png" alt="ContentChild Query" /></p>
<h3 id="contentchildren"><a class="header" href="#contentchildren">@ContentChildren</a></h3>
<p>Similar to the <code>@ViewChild</code>, the <code>@ContentChild</code> decorator always returns the first found element
if there are more than one declared in the Component View.</p>
<p>You are going to need a <code>@ContentChildren</code> decorator if you intend working with all the instances.</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

import { /*...,*/ ContentChildren, QueryList } from '@angular/core';
import { ListItemComponent } from '../list-item/list-item.component';

@Component({/*...*/})
export class ListComponent implements AfterContentInit {
  // ...

  @ContentChildren(ListItemComponent)
  listItems: QueryList&lt;ListItemComponent&gt;;

  ngAfterContentInit() {
    this.listItems.forEach(item =&gt; {
      item.title = item.title + ' (' + new Date().toLocaleDateString() + ')';
    });
  }
}
</code></pre>
<p>The example above should already be familiar to you.
We have just updated every item in the list by changing its title.
The main page in the browser should be looking similar to the following one:</p>
<p><img src="images/component-queries-05.png" alt="ContentChildren Query" /></p>
<h3 id="listening-for-view-and-content-changes"><a class="header" href="#listening-for-view-and-content-changes">Listening for View and Content Changes</a></h3>
<p>So with <code>@ContentChild</code>, <code>@ContentChildren</code>, <code>@ViewChild</code> and <code>@ViewChildren</code> decorators we can import
and manipulate elements and components in the controller class.</p>
<p>But what if developer applies conditional visibility to the layout entries like in the example below?</p>
<pre><code class="language-html">&lt;app-list&gt;
  &lt;app-list-item *ngIf=&quot;showFirstItem&quot;&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;
</code></pre>
<p>As we already know, based on the &quot;ngIf state&quot;, the Angular will remove a corresponding element from the DOM, or add it back.
There are many scenarios, however, when your component controller needs to know about such changes.
For example, imagine a &quot;DataTable&quot; component that uses child components to define column structure,
but then turns developer-defined view or content elements to some internal representation.
The component must always know what is the &quot;visible&quot; part of the layout to work with.</p>
<p>Let's now extend our previous &quot;ViewChildren&quot; example with an extra flag to toggle visibility of the first list entry.
We will add a &quot;showFirstItem&quot; property, and a button that changes the property value on each click.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent implements AfterViewInit {

  showFirstItem = true;

  // ...
}
</code></pre>
<p>Next, append the following block to the component template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;hr&gt;

&lt;button (click)=&quot;showFirstItem = !showFirstItem&quot;&gt;
  Toggle first item
&lt;/button&gt;
</code></pre>
<p>We have declared two List components in the previous examples.
Let's now wire the first entry of each of the components with the <code>showFirstItem</code> condition like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list&gt;
  &lt;app-list-item *ngIf=&quot;showFirstItem&quot;&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;

&lt;hr&gt;

&lt;app-list&gt;
  &lt;app-list-item *ngIf=&quot;showFirstItem&quot;&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;

&lt;hr&gt;

&lt;button (click)=&quot;showFirstItem = !showFirstItem&quot;&gt;
  Toggle first item
&lt;/button&gt;
</code></pre>
<p>If you run the application now, you will see every first item appear and disappear from the list each time you click the &quot;Toggle first item&quot; buttons.
We have just emulated the situation when layout changes based on the external criteria.
But how does the component now react on those changes?</p>
<p>The &quot;QueryList&quot; class exposes a special &quot;changes&quot; property of the <code>Observable&lt;any&gt;</code>
type that can help us watch for the layout changes and achieve the desired behavior.</p>
<p>Now you can update the ListComponent implementation and add a simple change tracking code like in the following example:</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

@Component({/*...*/})
export class ListComponent implements AfterContentInit {

  // ...

  ngAfterContentInit() {
    // ...

    this.listItems.changes.subscribe(() =&gt; {
      console.log(
        `List content changed and has now ${this.listItems.length} items.`
      );
    });
  }
}
</code></pre>
<p>Please run the application once again and click the &quot;Toggle first item&quot; button a few times.
Alongside the element being added to and removed from the page, you will see the following console output:</p>
<pre><code class="language-text">List content changed and has now 2 items.
List content changed and has now 2 items.
List content changed and has now 3 items.
List content changed and has now 3 items.
List content changed and has now 2 items.
List content changed and has now 2 items.
</code></pre>
<p>We have two instances of the ListComponent declared in the application component template.
And both lists have its first element wired with conditional visibility expression.
That is why you will see messages from both components in the browser console output window.</p>
<p>As you can see, subscribing and listening to <code>QueryList&lt;T&gt;.change</code> events gives you an ability
to react on layout changes and perform extra behaviors at the component level.</p>
<h2 id="component-lifecycle"><a class="header" href="#component-lifecycle">Component Lifecycle</a></h2>
<p>Angular supports multiple lifecycle events for components, directives and services.</p>
<p>For the Components, the Angular invokes the following methods at runtime, in the order of execution:</p>
<ul>
<li>ngOnChanges</li>
<li>ngOnInit</li>
<li>ngDoCheck</li>
<li>ngAfterContentInit</li>
<li>ngAfterContentChecked</li>
<li>ngAfterViewInit</li>
<li>ngAfterViewChecked</li>
<li>ngOnDestroy</li>
</ul>
<p>As Directives do not have UI templates, they get the following set of lifecycle methods supported out of the box:</p>
<ul>
<li>ngOnChanges</li>
<li>ngOnInit</li>
<li>ngDoCheck</li>
<li>ngOnDestroy</li>
</ul>
<p>Finally, the Services get the next methods:</p>
<ul>
<li>ngOnDestroy</li>
</ul>
<p>Every method represents a separate interface in the <code>@angular/core</code> namespace and contains a <code>ng</code> prefix appended to the interface name.</p>
<p>For example, the <code>OnInit</code> interface declares a <code>ngOnInit</code> method, and so on.
We are going to dive deeper into details on each method and interface below.</p>
<p>Technically, the interfaces for the lifecycle events are optional.
The Angular is going to call those events in any case, and if the corresponding methods are present, they get automatically invoked.
It is a good practice, however, to still expose those interfaces in your classes to enable static checks by TypeScript.</p>
<p>You can find additional information on the lifecycle events in the following official docs: <a href="https://angular.io/guide/lifecycle-hooks#component-lifecycle-hooks-overview">Lifecycle Hooks</a></p>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/lifecycle">angular/components/lifecycle</a></strong> folder.</p>
</blockquote>
<h3 id="ngonchanges"><a class="header" href="#ngonchanges">ngOnChanges</a></h3>
<p>The <code>ngOnChanges</code> method is related to the <code>OnChanges</code> hook.
Angular calls it every time an input property of the component or directive gets changed.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface OnChanges {
    ngOnChanges(changes: SimpleChanges): void;
}
</code></pre>
<p>Let's create a new Angular CLI project and generate an <code>on-changes-demo</code> component to see the <code>OnChanges</code> hook in action.</p>
<pre><code class="language-sh">ng g component on-changes-demo
</code></pre>
<p>To visualize the property change, we need two properties to store the current and old values.</p>
<p>The <code>text</code> property stores current string value and is decorated with the <code>@Input</code>
to enable two-way bindings with template components, or external input.</p>
<p>The <code>previous</code> property provides the one-way binding support to display the old string.</p>
<pre><code class="language-ts">// src/app/on-changes-demo/on-changes-demo.component.ts

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-on-changes-demo',
  templateUrl: './on-changes-demo.component.html',
  styleUrls: ['./on-changes-demo.component.css']
})
export class OnChangesDemoComponent {

  @Input()
  text = 'hello world';

  previous: string;

}
</code></pre>
<p>Now that we have a code defined, the minimal component implementation can look like in the following example:</p>
<pre><code class="language-html">&lt;!-- src/app/on-changes-demo/on-changes-demo.component.html --&gt;

&lt;p&gt;
  Text: {{ text }}
  &lt;br&gt;
  Previous: {{ previous }}
&lt;/p&gt;
</code></pre>
<p>At this point, we are ready to implement the <code>OnChanges</code> interface from the <code>@angular/core</code> package.
Your <code>ngOnChanges</code> method can look like the next one:</p>
<pre><code class="language-ts">// src/app/on-changes-demo/on-changes-demo.component.ts
import { /*...,*/ OnChanges, SimpleChanges } from '@angular/core';

@Component({...})
export class OnChangesDemoComponent implements OnChanges {

  @Input()
  text = 'hello world';

  previous: string;

  ngOnChanges(changes: SimpleChanges) {
    if (changes.text) {
      this.previous = changes.text.previousValue;
    }
  }

}
</code></pre>
<p>As you already know, the Angular keeps track of all property changes.</p>
<p>In our current case, the framework collects the changes made to the <code>OnChangesDemoComponent</code> component properties and,
wraps into a special <code>SimpleChanges</code> map and passes to the corresponding hook method.</p>
<pre><code class="language-ts">interface SimpleChanges {
    [propName: string]: SimpleChange;
}
</code></pre>
<p>Every value of the <code>SimpleChanges</code> map implements a <code>SimpleChange</code> interface with at least the following properties and methods:</p>
<ul>
<li>previousValue: any;</li>
<li>currentValue: any;</li>
<li>firstChange: boolean;</li>
<li>isFirstChange(): boolean;</li>
</ul>
<p>As you can see the <code>SimpleChange</code> API allows you to inspect the current and previous values,
as well as to check whether this is the first time the particular property gets changed.
The <code>firstChange</code> property allows you to distinguish between setting default property
value within the class initializer as opposed to the changes caused by user interaction or runtime changes.</p>
<p>Now let's use our newly created component with the main application one.
The simple way to test value changes is to bind an input element to the &quot;text&quot; property like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;input [(ngModel)]=&quot;text&quot;&gt;
&lt;app-on-changes-demo [text]=&quot;text&quot;&gt;&lt;/app-on-changes-demo&gt;
</code></pre>
<p>Note that you are going to need an extra <code>text</code> property for the application component controller class:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  @Input()
  text: string;

}
</code></pre>
<p>Run the application with the <code>ng serve --open</code> command and try typing text in the main page.
Notice that our component displays both old and new values as you type them into the input element.</p>
<p><img src="images/lifecycle-01.png" alt="OnChanges example" /></p>
<h3 id="ngoninit"><a class="header" href="#ngoninit">ngOnInit</a></h3>
<p>The <code>OnInit</code> is the most common lifecycle hook. You are probably going to use it a lot in your custom components.</p>
<p>It is a good practice to perform component initialization in the <code>ngOnInit</code> method and not in the constructor.
Angular invokes the &quot;ngOnInit&quot; after the construction and once all input properties set,
so you can setup your component based on the property values from the outside.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface OnInit {
    ngOnInit(): void;
}
</code></pre>
<p>In the same project, we created earlier, generate a new &quot;on-init-demo&quot; component with the following command:</p>
<pre><code class="language-sh">ng g component on-init-demo
</code></pre>
<p>Next, define a property <code>currentDate</code> of the <code>Date</code> type, and set its value in the <code>ngOnInit</code> method like in the following example:</p>
<pre><code class="language-ts">// src/app/on-init-demo/on-init-demo.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-on-init-demo',
  templateUrl: './on-init-demo.component.html',
  styleUrls: ['./on-init-demo.component.css']
})
export class OnInitDemoComponent implements OnInit {

  currentDate: Date;

  constructor() { }

  ngOnInit() {
    this.currentDate = new Date();
  }

}
</code></pre>
<p>Update the component template to render the value of the <code>currentDate</code>:</p>
<pre><code class="language-html">&lt;!-- src/app/on-init-demo/on-init-demo.component.html --&gt;

&lt;p&gt;
  Date: {{ currentDate }}
&lt;/p&gt;
</code></pre>
<p>Given that we do not have any input properties, the main application component template can contain just the empty tag.</p>
<p>Append the following code to the existing template HTML:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngOnInit&lt;/h2&gt;

&lt;app-on-init-demo&gt;&lt;/app-on-init-demo&gt;
</code></pre>
<p>If you run the application right now, you should see current date and time with default string formatting:</p>
<p><img src="images/lifecycle-02.png" alt="" /></p>
<p>Let's now try creating the component multiple times on the fly to see the <code>ngOnInit</code> method calls in practice.
We can wrap our custom <code>OnInitDemoComponent</code> with the <code>ng-container</code> element decorated by the <code>ngIf</code> directive.</p>
<p>Add a new <code>showNgOnInit</code> property of the <code>boolean</code> type to the component controller class,
and bind the checkbox to toggle component at runtime:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({...)
export class AppComponent {

  // ...

  showNgOnInit = true;

}
</code></pre>
<p>Update the application controller template to look like the following code:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngOnInit&lt;/h2&gt;

&lt;label&gt;
  &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;showNgOnInit&quot;&gt;
  Toggle ngOnInit demo
&lt;/label&gt;

&lt;ng-container *ngIf=&quot;showNgOnInit&quot;&gt;
  &lt;app-on-init-demo&gt;&lt;/app-on-init-demo&gt;
&lt;/ng-container&gt;
</code></pre>
<blockquote>
<p><strong>ngModel</strong></p>
<p>Don't forget that you need to import <code>FormsModule</code> to your root application module so that you can use the <code>ngModel</code> with components.</p>
</blockquote>
<p>Now, every time you tick the checkbox element a new <code>OnInitDemoComponent</code> is created and displayed,
and a new date value assigned by the <code>ngOnInit</code> method.</p>
<p><img src="images/lifecycle-03.png" alt="" /></p>
<p>As you can imagine, we used a pretty basic scenario for component setup.
In real life, your <code>ngOnInit</code> content might be more complex.</p>
<h3 id="ngdocheck"><a class="header" href="#ngdocheck">ngDoCheck</a></h3>
<p>The <code>DoCheck</code> hook allows you to integrate into the change detection cycle and find changes within the objects references
or any areas where Angular did not detect changes automatically.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface DoCheck {
    ngDoCheck(): void;
}
</code></pre>
<blockquote>
<p><strong>Performance Penalty</strong></p>
<p>Please keep in mind that, depending on the component tree size and complexity,
the &quot;ngDoCheck&quot; method is going to execute enormous amount of times
and may become a performance bottleneck if you poorly implement the code.
Avoid using &quot;ngDoCheck&quot; method unless necessary.</p>
</blockquote>
<p>When using properties of the object type, the Angular is going to watch the changes by value reference,
meaning detects the change of the entire value, but not the changes in the child properties.
That is the case where we are going to use <code>DoCheck</code> lifecycle hook and detect changes in the object.</p>
<p>For the next exercise, we need a new component called &quot;DoCheckDemoComponent&quot; that you can generate using the following command:</p>
<pre><code class="language-sh">ng g component do-check-demo
</code></pre>
<p>Let's integrate it into the main application template now to save the time later.
Append the next HTML snippet to the content of the component template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;
&lt;hr&gt;
&lt;h2&gt;ngDoCheck&lt;/h2&gt;
&lt;app-do-check-demo&gt;&lt;/app-do-check-demo&gt;
</code></pre>
<p>Next, we need an object value and custom properties.
For the sake of simplicity let's create a &quot;User&quot; object featuring first and last names as separate properties.</p>
<p>The component should have the <code>current</code> and <code>previous</code> values to facilitate property checks.</p>
<pre><code class="language-ts">// src/app/do-check-demo/do-check-demo.component.ts

import { Component, Input, DoCheck } from '@angular/core';

@Component({
  selector: 'app-do-check-demo',
  templateUrl: './do-check-demo.component.html',
  styleUrls: ['./do-check-demo.component.css']
})
export class DoCheckDemoComponent implements DoCheck {

  currentUser = {
    firstName: 'John',
    lastName: 'Doe'
  };

  previousUser = {
    firstName: '',
    lastName: ''
  };

  ngDoCheck() {
  }

}
</code></pre>
<p>For the first iteration leave the <code>ngDoCheck</code> method empty and switch to the component template.
Our component needs to display values for both current and previous property values.</p>
<pre><code class="language-html">&lt;!-- src/app/do-check-demo/do-check-demo.component.html --&gt;

&lt;p&gt;
  Current user: {{ currentUser.firstName + ' ' + currentUser.lastName }}
  &lt;br&gt;
  Previous user: {{ previousUser.firstName + ' ' + previousUser.lastName }}
&lt;/p&gt;
</code></pre>
<p>You can run the application and check that component works as expected.
The main page should contain the full name of the user stored in the <code>currentUser</code> property.
The text for the <code>previousUser</code> property should be empty because we have not yet changed anything.</p>
<p><img src="images/lifecycle-04.png" alt="" /></p>
<p>As mentioned earlier, Angular calls <code>DoCheck</code> many times based on the change detection cycle.</p>
<p>To see that in practice, let's introduce a new field <code>checks</code> that should hold a count of checks performed for our component.
We are going to increment this field every time the <code>ngDoCheck</code> get called.</p>
<p>Next, we create a field <code>updates</code> to hold a count of the <code>currentUser</code> updates detected by our custom <code>ngDoCheck</code> implementation.
The method checks both <code>firstName</code> and <code>lastName</code> property values and updates the counter,
in addition to setting a new instance of the <code>previousUser</code> value.</p>
<p>Finally, let's introduce an &quot;Update user&quot; button that changes the value of the current user
and so triggers the change detection cycle and our custom checks. The button calls <code>updateUser</code> method upon every click.</p>
<p>Below is the implementation of all the mentioned class members and behavior:</p>
<pre><code class="language-ts">// src/app/do-check-demo/do-check-demo.component.ts

@Component({/*...*/})
export class DoCheckDemoComponent implements DoCheck {

  currentUser = {
    firstName: 'John',
    lastName: 'Doe'
  };

  previousUser = {
    firstName: '',
    lastName: ''
  };

  checks = 0;
  updates = 0;

  updateUser() {
    this.currentUser = {
      firstName: 'James',
      lastName: 'Bond'
    };
  }

  ngDoCheck() {
    this.checks ++;
    
    if (
      this.previousUser.firstName !== this.currentUser.firstName
      || this.previousUser.lastName !== this.currentUser.lastName
    ) {
      this.updates ++;
      this.previousUser = Object.assign({}, this.currentUser);
    }
  }

}
</code></pre>
<p>Now, edit the component HTML template to add necessary labels and a button to update the underlying user.</p>
<pre><code class="language-html">&lt;!-- src/app/do-check-demo/do-check-demo.component.html --&gt;

&lt;p&gt;
  Current user: {{ currentUser.firstName + ' ' + currentUser.lastName }}
  &lt;br&gt;
  Previous user: {{ previousUser.firstName + ' ' + previousUser.lastName }}
&lt;/p&gt;

&lt;p&gt;
  Checks: {{ checks }} &lt;br&gt;
  Updates: {{ updates }} &lt;br&gt;
  &lt;button (click)=&quot;updateUser()&quot;&gt;Update user&lt;/button&gt;
&lt;/p&gt;
</code></pre>
<p>Run the application or switch to the corresponding browser tab if it is already running.
You should see something like the following:</p>
<p><img src="images/lifecycle-05.png" alt="" /></p>
<p>Now click the &quot;Update user&quot; button one time and check that both counters got incremented.</p>
<p><img src="images/lifecycle-06.png" alt="" /></p>
<p>If you continue clicking the button, you should notice that the <code>checked</code> counter keeps incrementing.
Note that it increments even if you click some other buttons or clickable Angular components.
That demonstrates that our custom component reacts on change detection cycle managed by Angular, and increments the counter as designed.</p>
<p><img src="images/lifecycle-07.png" alt="" /></p>
<p>The <code>update</code> counter, however, should remain the same.
That is obvious as we change the values of the user only once.</p>
<h3 id="ngaftercontentinit"><a class="header" href="#ngaftercontentinit">ngAfterContentInit</a></h3>
<p>The <code>ngAfterContentInit</code> method belongs to the <code>AfterContentInit</code> hook in Angular,
and is part of the &quot;Content Projection&quot; feature.</p>
<p>Angular raises <code>AfterContentInit</code> every time an injected child component gets initialized
and is ready for use and access from the code if needed.</p>
<blockquote>
<p><strong>Content Projection</strong></p>
<p>Content projection is the process of injection of the external HTML content and other Angular components into the body of your component template.
You can get more information in the <a href="ch05-12-component-lifecycle.html#ng-content-projection">Content Projection</a> section later in this chapter.</p>
</blockquote>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface AfterContentInit {
  ngAfterContentInit(): void;
}
</code></pre>
<p>As all in all previous cases, let's start by generating a separate component to experiment with the hook:</p>
<pre><code class="language-sh">ng g component after-content-init-demo
</code></pre>
<p>For our exercise, we do not need a &quot;constructor&quot; and the <code>OnInit</code> implementation.
You can clean the component class and replace with the <code>AfterContentInit</code> interface implementation.</p>
<pre><code class="language-ts">// src/app/after-content-init-demo/after-content-init-demo.component.ts

import { Component, AfterContentInit } from '@angular/core';

@Component({/*...*/})
export class AfterContentInitDemoComponent implements AfterContentInit {

  ngAfterContentInit() {
  }

}
</code></pre>
<p>The <code>ng-content</code> element is going to be an injection point for external content.
Update the component template to look like the following markup:</p>
<pre><code class="language-html">&lt;!-- src/app/after-content-init-demo/after-content-init-demo.component.html --&gt;

Projected content below:
&lt;div&gt;
  &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/div&gt;
</code></pre>
<p>We now need to generate a second component to test the Angular lifecycle hook.</p>
<pre><code class="language-sh">ng g component after-content-init-child
</code></pre>
<p>You can clean the component class code as we need just a default implementation.</p>
<pre><code class="language-ts">// src/app/after-content-init-child/after-content-init-child.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-after-content-init-child',
  templateUrl: './after-content-init-child.component.html',
  styleUrls: ['./after-content-init-child.component.css']
})
export class AfterContentInitChildComponent {
}
</code></pre>
<p>Also, the default component template should work fine as well.
The Angular CLI usually generates a <code>&lt;component&gt; works!</code> label out of the box.</p>
<pre><code class="language-html">&lt;!-- src/app/after-content-init-child/after-content-init-child.component.html --&gt;

&lt;p&gt;
  after-content-init-child works!
&lt;/p&gt;
</code></pre>
<p>Finally, let's extend the main application template with the testing parent-child hierarchy with our newly introduced components.
Just append the following HTML snippet to existing template markup.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngAfterContentInit&lt;/h2&gt;

&lt;app-after-content-init-demo&gt;

    &lt;app-after-content-init-child&gt;
    &lt;/app-after-content-init-child&gt;

&lt;/app-after-content-init-demo&gt;
</code></pre>
<p>Serve the application with the <code>ng serve --open</code> command or switch to a running one in the browser.
You should see the next layout at the bottom of your page:</p>
<p><img src="images/lifecycle-08.png" alt="" /></p>
<p>Typically you are going to use <code>AfterContentInit</code> hook with the <code>@ContentChild</code> decorator.
While we use the <code>ngAfterContentInit</code> to detect when an injected component finished initializing,
the <code>ContentChild</code> allows getting references to the component instance.</p>
<p>Please refer to the example below to get a better understanding of how both APIs work together.</p>
<pre><code class="language-ts">// src/app/after-content-init-demo/after-content-init-demo.component.ts
import { Component, OnInit, AfterContentInit, ContentChild } from '@angular/core';
import { AfterContentInitChildComponent } from '../after-content-init-child/after-content-init-child.component';

@Component({/*...*/})
export class AfterContentInitDemoComponent implements AfterContentInit {

  @ContentChild(AfterContentInitChildComponent)
  child: AfterContentInitChildComponent;

  ngAfterContentInit() {
    console.log('AfterContentInit:', this.child);
  }

}
</code></pre>
<p>Once you run your application and open the developer tools,
you should see the following content in the browser console output:</p>
<p><img src="images/lifecycle-09.png" alt="" /></p>
<p>At this point, your parent component can perform additional setup for the child one,
like changing properties, subscribing to events or calling methods.</p>
<h3 id="ngaftercontentchecked"><a class="header" href="#ngaftercontentchecked">ngAfterContentChecked</a></h3>
<p>The <code>ngAfterContentChecked</code> method belongs to the <code>AfterContentChecked</code> interface in Angular, and is part of the &quot;Content Projection&quot; feature.</p>
<p>The <code>AfterContentChecked</code> lifecycle hook allows you to provide a custom mechanism for checking changes in the projected components.
The behavior is similar to the <code>DoCheck</code> but applied to the components that are part of the <code>ng-content</code> container.</p>
<blockquote>
<p><strong>Content Projection</strong></p>
<p>Content projection is the process of injection of the external HTML content and other Angular components into the body of your component template.
You can get more information in the <a href="ch05-12-component-lifecycle.html#ng-content-projection">Content Projection</a> section later in this chapter.</p>
</blockquote>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface AfterContentChecked {
  ngAfterContentChecked(): void;
}
</code></pre>
<p>Let's use the same <code>AfterContentInitDemoComponent</code> we created earlier.
For the sake of simplicity, we are going to add the <code>checked</code> counter field and update it on every change detection cycle.</p>
<pre><code class="language-ts">// src/app/after-content-init-demo/after-content-init-demo.component.ts
import { /*...,*/ AfterContentChecked } from '@angular/core';
...

@Component({/*...*/})
export class AfterContentInitDemoComponent implements AfterContentInit, AfterContentChecked {

  checked = 0;

  // ...

  ngAfterContentChecked() {
    this.checked ++;
  }

}
</code></pre>
<p>Update the component template to also display the <code>checked</code> counter after the projected content.</p>
<pre><code class="language-html">&lt;!-- src/app/after-content-init-demo/after-content-init-demo.component.html --&gt;

Projected content below:
&lt;div&gt;
  &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/div&gt;
&lt;div&gt;
  Checked (times): {{ checked }}
&lt;/div&gt;
</code></pre>
<p>Once your application starts or reloads, the bottom of the page should look similar to the following:</p>
<p><img src="images/lifecycle-10.png" alt="" /></p>
<p>Please note that the counter is going to update multiple times even if you interact with some other components or elements on the page.
You should keep the code inside <code>ngAfterContentChecked</code> method body fast and small not to introduce a performance bottleneck for the entire application.</p>
<h3 id="ngafterviewinit"><a class="header" href="#ngafterviewinit">ngAfterViewInit</a></h3>
<p>Angular invokes the <code>ngAfterViewInit</code> hook once the view of the component is ready.
That also includes the child components that may be part of the template.</p>
<p>You can access child instance members and perform additional tasks in the code,
for example changing properties or subscribing to events.</p>
<p>Check out the code of the interface below:</p>
<pre><code class="language-ts">interface AfterViewInit {
  ngAfterViewInit(): void;
}
</code></pre>
<p>Let's introduce a basic scenario that requires us to access view elements and update their properties.
We are going to have two buttons in the component template that have no text,
and once the view gets initialized our component should update the text of each button.</p>
<p>We need a separate <code>AfterViewInitDemoComponent</code> component that gets generated with the next Angular CLI command:</p>
<pre><code class="language-sh">ng g component after-view-init-demo
</code></pre>
<p>Import and implement the <code>AfterViewInit</code> interface from the <code>@angular/core</code> package.
The <code>ngAfterViewInit</code> method can be blank for now, and we are going to implement it shortly.</p>
<pre><code class="language-ts">// src/app/after-view-init-demo/after-view-init-demo.component.ts

import { Component, OnInit, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-after-view-init-demo',
  templateUrl: './after-view-init-demo.component.html',
  styleUrls: ['./after-view-init-demo.component.css']
})
export class AfterViewInitDemoComponent implements AfterViewInit {

  ngAfterViewInit() {
  }

}
</code></pre>
<p>Next, add two buttons to the template.
Each of the button needs to have a template reference id
so that our component class can access each button using the <code>prevPageButton</code> and <code>nextPageButton</code> id values.</p>
<pre><code class="language-html">&lt;!-- src/app/after-view-init-demo/after-view-init-demo.component.html --&gt;

&lt;div&gt;
  after-view-init-demo works!
  &lt;div&gt;
      &lt;button #prevPageButton&gt;&lt;/button&gt;
      &lt;button #nextPageButton&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>As a next step, declare the newly generated component within the main application template
by appending the following code to the existing markup:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngAfterViewInit&lt;/h2&gt;
&lt;app-after-view-init-demo&gt;&lt;/app-after-view-init-demo&gt;
</code></pre>
<p>Serve the application right now and ensure the component renders its template with a default label
and two buttons with missing labels as in the picture below:</p>
<p><img src="images/lifecycle-11.png" alt="" /></p>
<p>You also need importing the <code>ViewChild</code> decorator type.
This decorator is used to get a reference to the native element of the component template.</p>
<p>Also, create two separate properties <code>prevButton</code> and <code>nextButton</code> of the <code>ElementRef</code> type.
Every instance of the <code>ElementRef</code> exposes a <code>nativeElement</code> property that you can use to access the DOM element,
in our case HTML button inputs.</p>
<p>The component sets the <code>innerText</code> values for both buttons inside the <code>ngAfterViewInit</code> method body like in the next example:</p>
<pre><code class="language-ts">// src/app/after-view-init-demo/after-view-init-demo.component.ts

import { /*...,*/ ViewChild, ElementRef } from '@angular/core';

@Component({...})
export class AfterViewInitDemoComponent implements AfterViewInit {

  @ViewChild('prevPageButton')
  prevButton: ElementRef;

  @ViewChild('nextPageButton')
  nextButton: ElementRef;

  ngAfterViewInit() {
    this.prevButton.nativeElement.innerText = 'Left Page';
    this.nextButton.nativeElement.innerText = 'Right Page';
  }

}
</code></pre>
<p>This time, when you run the application, both buttons should have correct labels:</p>
<p><img src="images/lifecycle-12.png" alt="" /></p>
<p>The <code>AfterViewInit</code> is usually used to modify the behavior of the view elements once the corresponding component is ready.</p>
<h3 id="ngafterviewchecked"><a class="header" href="#ngafterviewchecked">ngAfterViewChecked</a></h3>
<p>The <code>ngAfterViewChecked</code> method represents the <code>AfterViewChecked</code> lifecycle hook and interface.
It allows you to provide custom change tracking that is not handled by Angular due to some reason.
The behavior is similar to the <code>AfterContentChecked</code> hook but applies to the view template children rather than projected content.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface AfterViewChecked {
  ngAfterViewChecked(): void;
}
</code></pre>
<p>As with previous examples, let's introduce a &quot;checked&quot; field to hold the number of checks,
and use the previous component with two buttons to demonstrate the lifecycle hook in practice.</p>
<pre><code class="language-ts">// src/app/after-view-init-demo/after-view-init-demo.component.ts

import { /*...,*/ AfterViewChecked } from '@angular/core';

@Component({/*...*/})
export class AfterViewInitDemoComponent implements AfterViewInit, AfterViewChecked {

  checked = 0;

  // ...

  ngAfterViewChecked() {
    this.checked ++;
  }

}
</code></pre>
<p>Don't forget to update the component template by appending the label like in the next snippet:</p>
<pre><code class="language-html">&lt;!-- src/app/after-view-init-demo/after-view-init-demo.component.html --&gt;
&lt;!-- ... --&gt;

&lt;div&gt;
  Checked (times): {{ checked }}
&lt;/div&gt;
</code></pre>
<p>Now run the application and try clicking the buttons.
You should notice that the counter updates every time you interact with the button inside the component template,
or any other Angular component on the page.</p>
<p><img src="images/lifecycle-13.png" alt="" /></p>
<p>Needless to say that your custom change tracking code should be highly optimized and run fast.
Otherwise, you risk getting a performance bottleneck.</p>
<h3 id="ngondestroy"><a class="header" href="#ngondestroy">ngOnDestroy</a></h3>
<p>The <code>OnDestroy</code> lifecycle hook provides you with a way to run cleanup operations for your component,
directive or service to reduce resources and avoid potential memory leaks.</p>
<p>If your component controller subscribes to various event handlers,
the <code>ngOnDestroy</code> method is the most appropriate place to tear down all event subscriptions.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface OnDestroy {
  ngOnDestroy(): void;
}
</code></pre>
<p>Let's generate a new component to see how <code>OnDestroy</code> hook works in practice.
We are going to produce two log entries for the browser console log,
one during the <code>OnInit</code> call and one for the <code>OnDestroy</code>.</p>
<pre><code class="language-sh">ng g component on-destroy-demo
</code></pre>
<pre><code class="language-ts">// src/app/on-destroy-demo/on-destroy-demo.component.ts

import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-on-destroy-demo',
  templateUrl: './on-destroy-demo.component.html',
  styleUrls: ['./on-destroy-demo.component.css']
})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  constructor() { }

  ngOnInit() {
    console.log('OnInit');
  }

  ngOnDestroy() {
    console.log('OnDestroy');
  }

}
</code></pre>
<p>Next, declare a <code>showNgOnDestroy</code> property for the main application component class
to control the visibility of our generated component.</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {
  // ...

  showNgOnDestroy = true;

}
</code></pre>
<p>For the last step, declare a checkbox with the label to control the value of the <code>showNgOnDestroy</code> property,
and a <code>ng-container</code> element that wraps the <code>app-on-destroy-demo</code>.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngOnDestroy&lt;/h2&gt;
&lt;label&gt;
  &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;showNgOnDestroy&quot;&gt;
  Toggle ngOnDestroy demo
&lt;/label&gt;

&lt;ng-container *ngIf=&quot;showNgOnDestroy&quot;&gt;
  &lt;app-on-destroy-demo&gt;&lt;/app-on-destroy-demo&gt;
&lt;/ng-container&gt;
</code></pre>
<p>At runtime, the component should look like the following once the application starts:</p>
<p><img src="images/lifecycle-14.png" alt="" /></p>
<p>As soon as you untick the checkbox, the Angular is going to tear down the component
that should no longer be on the page and call the &quot;ngOnDestroy&quot; method.</p>
<p>Open the development tools for your current browser and try clicking the checkbox multiple times.
The console output should look like the one below:</p>
<p><img src="images/lifecycle-15.png" alt="" /></p>
<h4 id="cleaning-up-subscriptions"><a class="header" href="#cleaning-up-subscriptions">Cleaning up subscriptions</a></h4>
<p>Also, the <code>OnDestroy</code> event is also used to cleanup subscriptions to external service or component events.
It is very important to unsubscribe from all the events to prevent memory leaks and performance degradation.</p>
<p>Let's take an example of a service that exposes multiple events.</p>
<pre><code class="language-ts">// src/app/on-destroy-demo/simple.service.ts

import { Injectable } from '@angular/core';
import { Subject } from 'rxjs/Subject';

@Injectable()
export class SimpleService {

  loaded = new Subject();
  changed = new Subject();
  somethingElse = new Subject();

}
</code></pre>
<p>We use dependency injection to get an instance of this service injected into the component constructor.
And we use the <code>OnInit</code> hook to set up the event handlers.</p>
<pre><code class="language-ts">// src/app/on-destroy-demo/on-destroy-demo.component.ts

@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  constructor(private service: SimpleService) {}

  ngOnInit() {
    this.service.loaded.subscribe(() =&gt; {/*...*/});
    this.service.changed.subscribe(() =&gt; {/*...*/});
  }

  ngOnDestroy() {/*...*/}
}
</code></pre>
<p>It is sometimes difficult to spot the problem in such an approach, but we may get a memory leak with the code above.</p>
<p>The issue is that the service we inject is a singleton one, and Angular keeps its instance somewhere.
It also means that now service instance will keep a reference to our component alive due to the event handler and subscription.
That is why we need to clean all subscriptions during destroy phase.</p>
<p>When using Observables, you get an instance of the Subscription each time you call <code>subscribe</code> method of the <code>Observable</code> or <code>Subject</code>.</p>
<blockquote>
<p><strong>Subscription</strong></p>
<p>Represents a disposable resource, such as the execution of an Observable.
Subscription has one important method, <code>unsubscribe</code>, that takes no argument and just disposes the resource held by the subscription.</p>
</blockquote>
<p>The easiest way to process multiple subscriptions is to use them in bulk, wrapping into a private array variable.
That saves a lot of time and prevents issues related to missed variables or <code>unsubscribe</code> calls.</p>
<p>First, let's create a private property <code>subscriptions</code> of the array type that will hold all our subscriptions to external events.</p>
<pre><code class="language-ts">@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  private subscriptions: Subscription[] = [];

}
</code></pre>
<p>Now you can push multiple subscriptions into the array like in the next example:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  private subscriptions: Subscription[] = [];

  constructor(private service: SimpleService) {}

  ngOnInit() {
    this.subscriptions.push(
      this.service.loaded.subscribe(() =&gt; {/*...*/}),
      this.service.changed.subscribe(() =&gt; {/*...*/}),
      this.service.somethingElse.subscribe(() =&gt; {{/*...*/})
    );
  }

  ngOnDestroy() {/*...*/}

}
</code></pre>
<p>Keeping all subscriptions in one place makes it easy to cleanup them in bulk when Angular invokes <code>ngOnDestroy</code> life-cycle hook.</p>
<pre><code class="language-ts">@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  private subscriptions: Subscription[] = [];

  constructor(private service: SimpleService) {}

  ngOnInit() {/*...*/}

  ngOnDestroy() {
    this.subscriptions.forEach(s =&gt; s.unsubscribe());
    this.subscriptions = [];
  }

}
</code></pre>
<p>Do not forget about the technique above when dealing with subscriptions.
It should prevent memory leaks and performance issues when the component is re-created or gets destroyed.</p>
<h2 id="content-projection"><a class="header" href="#content-projection">Content Projection</a></h2>
<p>The process of adding custom content into the existing components without rebuilding them is often called content projection.</p>
<h3 id="ng-container-directive"><a class="header" href="#ng-container-directive">ng-container directive</a></h3>
<p>In most cases when using structural directives or components you are dealing with an extra DOM element that serves as a root one.
There are scenarios, however, when you will want to have raw content emitted at run-time, with no wrapping elements.</p>
<p>The <code>ng-container</code> directive allows you to group single or multiple elements and components producing no HTML output.</p>
<pre><code class="language-html">&lt;ng-container&gt;
  &lt;!-- Your content comes here --&gt;
&lt;/ng-container&gt;
</code></pre>
<p>Let's take a simple repeater example and render a sequence of strings wrapped with a div element
and compare the same solution with <code>ng-container</code> use case.</p>
<p>First, take any existing, or generate a new Angular application using Angular CLI tools.
Create an <code>items</code> property with a set of strings values so you can use that property with the <code>*ngFor</code> directive.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Component } from '@angular/core';

@Component({/*...*/})
export class AppComponent  {

  items = ['One', 'Two', 'Three', 'Four'];

}
</code></pre>
<p>Next, update the component template and append the following code:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Using container element&lt;/h2&gt;

&lt;div *ngFor=&quot;let item of items&quot;&gt;
  {{ item }}
&lt;/div&gt;
</code></pre>
<p>Once you run the application, the main page should contain a header element and a list of strings like following:</p>
<pre><code class="language-text">Using container element

One
Two
Three
Four
</code></pre>
<p>If you now look at the generated HTML (right-clicking on the list and using &quot;Inspect Element&quot; menu item),
you will see something like in the following example:</p>
<pre><code class="language-html">&lt;h2 _ngcontent-c69=&quot;&quot;&gt;Using container element&lt;/h2&gt;
&lt;!--bindings={
  &quot;ng-reflect-ng-for-of&quot;: &quot;One,Two,Three,Four&quot;
}--&gt;
&lt;div _ngcontent-c69=&quot;&quot;&gt;
  One
&lt;/div&gt;&lt;div _ngcontent-c69=&quot;&quot;&gt;
  Two
&lt;/div&gt;&lt;div _ngcontent-c69=&quot;&quot;&gt;
  Three
&lt;/div&gt;&lt;div _ngcontent-c69=&quot;&quot;&gt;
  Four
&lt;/div&gt;
</code></pre>
<p>Note that every string is wrapped with the &quot;div&quot; element.
That is what we will now try to avoid by using ng-container directive.</p>
<p>For comparison, let's leave the exiting layout as it is now,
and append a new block at the bottom with the following code.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Using ng-container&lt;/h2&gt;

&lt;ng-container *ngFor=&quot;let item of items&quot;&gt;
  {{ item }}
&lt;/ng-container&gt;
</code></pre>
<p>That is the same code, but we replaced &quot;div&quot; element with the &quot;ng-container&quot; one.
At run-time, however, the result should look different.</p>
<pre><code class="language-text">Using ng-container

One Two Three Four
</code></pre>
<p>Note that repeated values are now forming a string rather than a vertical list.
If you now check the source code, you will see that there are no additional elements on the page.
Angular replaces them with the HTML comments instead.</p>
<pre><code class="language-html">&lt;h2 _ngcontent-c69=&quot;&quot;&gt;Using ng-container&lt;/h2&gt;
&lt;!--bindings={
  &quot;ng-reflect-ng-for-of&quot;: &quot;One,Two,Three,Four&quot;
}--&gt;&lt;!----&gt;
  One
&lt;!----&gt;
  Two
&lt;!----&gt;
  Three
&lt;!----&gt;
  Four
</code></pre>
<p>Angular does not restrict you to the <code>ngFor</code> directive only.</p>
<p>You can use the <code>ng-container</code> in any parts of the template where you need to have a &quot;virtual&quot; container element,
or there's a need to group multiple elements without introducing an extra content in the DOM.</p>
<p>Most times using <code>ng-container</code> should also simplify layout and CSS maintenance.</p>
<blockquote>
<p><strong>Source Code and Demo</strong></p>
<p>You can find the source code and the <a href="https://stackblitz.com/edit/dwa-ng-container?file=app%2Fapp.component.html">live demo</a> on Stackblitz.</p>
</blockquote>
<h3 id="projecting-single-entity"><a class="header" href="#projecting-single-entity">Projecting Single Entity</a></h3>
<p>A good example of the custom content projection is container components.
You can have a panel-like component with some predefined content and styles.
At the same time the component can host external elements in panel body implementation.</p>
<p>Let's now create a panel component to see content projection in action.
Use the following Angular CLI command to get started:</p>
<pre><code class="language-sh">ng g component my-panel
</code></pre>
<p>Next, you should edit the main application template and replace its contents with the following HTML block:</p>
<pre><code class="language-html">&lt;app-my-panel&gt;&lt;/app-my-panel&gt;
</code></pre>
<p>For demonstration and testing purposes, let's update the generated panel component.
First, replace the &quot;p&quot; element with the &quot;div&quot;.</p>
<pre><code class="language-html">&lt;!-- src/app/my-panel/my-panel.component.html --&gt;

&lt;div&gt;
  my-panel works!
&lt;/div&gt;
</code></pre>
<p>Then you can update its stylesheet, add the border to all the &quot;div&quot; children of the root component layout.</p>
<pre><code class="language-css">/* src/app/my-panel/my-panel.component.css */

:host &gt; div {
  border: 1px solid gray;
}
</code></pre>
<p>Run the application and should see the main page with the panel component looking like on the picture below.</p>
<p><img src="images/ng-projection-01.png" alt="Default Panel" /></p>
<h4 id="supporting-external-content"><a class="header" href="#supporting-external-content">Supporting External Content</a></h4>
<p>To provide a basic support for external content projection, add the <code>ng-content</code> element somewhere in the panel template layout.</p>
<pre><code class="language-html">&lt;!-- src/app/my-panel/my-panel.component.html --&gt;

&lt;div&gt;
  my-panel works!
  &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/div&gt;
</code></pre>
<p>Now your panel component can receive custom HTML elements and Angular components inside its selector tags.
Update the main application template with a header element inside the panel to see that in practice.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-my-panel&gt;
  &lt;h2&gt;My custom external content&lt;/h2&gt;
&lt;/app-my-panel&gt;
</code></pre>
<p>Once your application restarts, the main page should now look similar to the next picture:</p>
<p><img src="images/ng-projection-02.png" alt="Panel with custom content" /></p>
<p>Note you can see both the native panel content presented by the <code>my-panel works!</code> and the external &quot;h2&quot; element from the application level.</p>
<p>For your custom Angular components, treat the <code>ng-content</code> element as a placeholder for something that comes from the outside.</p>
<h3 id="projecting-multiple-entities"><a class="header" href="#projecting-multiple-entities">Projecting Multiple Entities</a></h3>
<p>We got support for a single entity projection so far,
but there are many scenarios when you will need to fill multiple placeholders in your Angular component template.</p>
<p>You can achieve that by using the <code>selector</code> support that <code>ng-content</code> container exposes.
It allows you to match placeholders using HTML selectors, for example CSS class names, or DOM element names.</p>
<p>The usage format is as follows:</p>
<pre><code class="language-html">&lt;ng-content select=&quot;&lt;selector&gt;&quot;&gt;&lt;/ng-content&gt;
</code></pre>
<h4 id="projecting-with-css-selectors"><a class="header" href="#projecting-with-css-selectors">Projecting with CSS selectors</a></h4>
<p>For the first step, provide support for injecting Header, Content and Footer content for our panel component,
and see CSS class name selectors in action.</p>
<p>You should start by adding three new content placeholders that point to unique class names.</p>
<pre><code class="language-html">&lt;!-- src/app/my-panel/my-panel.component.html --&gt;

&lt;div&gt;
  &lt;ng-content select=&quot;.my-panel-header&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;
&lt;div&gt;
  my-panel works!
  &lt;ng-content select=&quot;.my-panel-content&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;ng-content select=&quot;.my-panel-footer&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;
</code></pre>
<p>To populate those placeholders, you components or DOM elements now need to declare corresponding CSS class names.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-my-panel&gt;
  &lt;div class=&quot;my-panel-header&quot;&gt;
      Header
  &lt;/div&gt;
  &lt;h2 class=&quot;my-panel-content&quot;&gt;
    My custom external content
  &lt;/h2&gt;
  &lt;div class=&quot;my-panel-footer&quot;&gt;
    Footer
  &lt;/div&gt;
&lt;/app-my-panel&gt;
</code></pre>
<p>At runtime, the main application page should now look like the following:</p>
<p><img src="images/ng-projection-03.png" alt="Projecting with class selectors" /></p>
<p>You have projected custom content for panel's Header, Content and Footer areas.</p>
<h4 id="projecting-with-component-selectors"><a class="header" href="#projecting-with-component-selectors">Projecting with Component Selectors</a></h4>
<p>When dealing with CSS class name-based selectors, things may get complicated once your layout grows.
Header and Footer content might need own complex layout, styling, effects or conditional rendering.</p>
<p>The best approach for handling application growth is to introduce separate components
that encapsulate the logic and presentation for panel primitives.</p>
<p>You can practice better separation of concerns by introducing three granular components to compose the panel.</p>
<pre><code class="language-sh">ng g component my-panel/my-panel-header
ng g component my-panel/my-panel-content
ng g component my-panel/my-panel-footer
</code></pre>
<p>Note that by default, Angular CLI generates &quot;app-&quot; prefixes for the component selectors.
So &quot;MyPanelHeaderComponent&quot; will have &quot;app-my-panel-header&quot; selector. Same for other components we create.</p>
<p>Now update the panel template to reference the DOM element selectors instead of the CSS class names like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/my-panel/my-panel.component.html --&gt;

&lt;div&gt;
  &lt;ng-content select=&quot;app-my-panel-header&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;

&lt;div&gt;
  my-panel works!
  &lt;ng-content select=&quot;app-my-panel-content&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;ng-content select=&quot;app-my-panel-footer&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;
</code></pre>
<p>That allows us to refactor the main page and use Angular components instead of the DOM elements with class names:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-my-panel&gt;
  &lt;app-my-panel-header&gt;&lt;/app-my-panel-header&gt;
  &lt;app-my-panel-content&gt;&lt;/app-my-panel-content&gt;
  &lt;app-my-panel-footer&gt;&lt;/app-my-panel-footer&gt;
&lt;/app-my-panel&gt;
</code></pre>
<p>Run the web application again and ensure that all content is on the expected places.</p>
<p><img src="images/ng-projection-04.png" alt="Projecting with component selectors" /></p>
<p>The main benefit for using Angular components over the DOM elements is that your components can have own content projection support.
Besides that components can hide the complexity of the layout and expose different input properties and output events.</p>
<h5 id="fallback-content"><a class="header" href="#fallback-content">Fallback content</a></h5>
<p>You can further improve coding experience for the developers that reuse your panel component.
It is possible to provide a default fallback content to support the cases when custom projection is missing.
Also, the panel may provide shortcuts for common features, like providing a simple string value for the Header
via the input property, in case developer does not need complex layout.</p>
<p>Importing the references to content children of the component into the code can further help
reuse them in the template and building conditional visibility expressions for other elements.</p>
<p>Let's import the <code>MyPanelHeaderComponent</code> component and also introduce the optional <code>title</code> shortcut property.</p>
<pre><code class="language-ts">// src/app/my-panel/my-panel.component.ts

import { Input, Component, ContentChild,  } from '@angular/core';
import { MyPanelHeaderComponent } from './my-panel-header/my-panel-header.component';

@Component({
  selector: 'app-my-panel',
  templateUrl: './my-panel.component.html',
  styleUrls: ['./my-panel.component.css']
})
export class MyPanelComponent {

  @Input()
  title = 'Default title';

  @ContentChild(MyPanelHeaderComponent)
  header: MyPanelHeaderComponent;

}
</code></pre>
<p>Now update the panel template, if there is no <code>header</code> element provided
and there is a <code>title</code> input property defined, we display the value of the <code>title</code>.</p>
<pre><code class="language-html">&lt;!-- src/app/my-panel/my-panel.component.html --&gt;

&lt;div&gt;
  &lt;ng-container *ngIf=&quot;!header &amp;&amp; title&quot;&gt;{{ title }}&lt;/ng-container&gt;
  &lt;ng-content select=&quot;app-my-panel-header&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;

&lt;div&gt;
  my-panel works!
  &lt;ng-content select=&quot;app-my-panel-content&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;ng-content select=&quot;app-my-panel-footer&quot;&gt;&lt;/ng-content&gt;
&lt;/div&gt;
</code></pre>
<p>If you want to test new functionality, comment out the header tags in the main page template and reload the application.</p>
<pre><code class="language-html">&lt;app-my-panel&gt;
  &lt;!-- &lt;app-my-panel-header&gt;&lt;/app-my-panel-header&gt; --&gt;
  &lt;app-my-panel-content&gt;&lt;/app-my-panel-content&gt;
  &lt;app-my-panel-footer&gt;&lt;/app-my-panel-footer&gt;
&lt;/app-my-panel&gt;
</code></pre>
<p>We have set the default title value to &quot;Default title&quot;, that is the text you should now see rendered.</p>
<p><img src="images/ng-projection-05.png" alt="Projecting fallback title" /></p>
<p>Now set custom value for the &quot;title&quot; attribute to test that fallback content works as we expect:</p>
<pre><code class="language-html">&lt;app-my-panel title=&quot;Custom title&quot;&gt;
  &lt;!-- &lt;app-my-panel-header&gt;&lt;/app-my-panel-header&gt; --&gt;
  &lt;app-my-panel-content&gt;&lt;/app-my-panel-content&gt;
  &lt;app-my-panel-footer&gt;&lt;/app-my-panel-footer&gt;
&lt;/app-my-panel&gt;
</code></pre>
<p>The panel should reflect your changes and web application should now render the &quot;Custom title&quot; value in the Header area.</p>
<p><img src="images/ng-projection-06.png" alt="Projecting custom title" /></p>
<p>The dual rendering approach we have just tried helps a lot when you need to provide default layout portions,
but still want to allow developers replacing them on demand.</p>
<p>Imagine a dialog with the toolbar, for instance, where developers can project a new toolbar implementation,
but can also have a predefined set of buttons.</p>
<blockquote>
<p><strong>Source Code and Demo</strong></p>
<p>You can find the source code and the
<a href="https://stackblitz.com/github/DenysVuika/dwa-content-projection?file=src%2Fapp%2Fapp.component.html">live demo</a> on Stackblitz.</p>
</blockquote>
<h1 id="dependency-injection"><a class="header" href="#dependency-injection">Dependency Injection</a></h1>
<p>Dependency Injection, also known as DI, is one of the major features of the Angular framework.</p>
<p>With dependency injection, Angular greatly improves development and testing process
by providing an infrastructure that helps to move share coded into the separate application services and blocks
that can be centrally maintained, reused or replaced at run time.</p>
<p>In this chapter, we are going to try key features of dependency injection in practice.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code as an Angular CLI project for this chapter in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/dependency-injection">angular/dependency-injection</a>&quot; folder.</p>
</blockquote>
<h2 id="preparing-a-project"><a class="header" href="#preparing-a-project">Preparing a Project</a></h2>
<p>First, let's use Angular CLI tool and generate a new project called &quot;dependency-injection&quot;.</p>
<pre><code class="language-sh">ng new dependency-injection
cd dependency-injection
</code></pre>
<p>Next, generate two components <code>component1</code> and <code>component2</code>, as in the example below:</p>
<pre><code class="language-sh">ng g component component1
ng g component component2
</code></pre>
<p>Finally, update the main application component template to use both components we have just created:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-component1&gt;&lt;/app-component1&gt;
&lt;app-component2&gt;&lt;/app-component2&gt;
</code></pre>
<p>If you now run the application with the <code>ng serve --open</code> command you should see two default component templates
that get generated automatically by Angular CLI:</p>
<pre><code class="language-text">component1 works!
component2 works!
</code></pre>
<p>You now have a working project ready for DI experiments.</p>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<h3 id="creating-logservice"><a class="header" href="#creating-logservice">Creating LogService</a></h3>
<p>As an example, let's build a shared Logger service now.</p>
<p>Logging is an excellent example of how to turn a frequently used functionality into an injectable service.
That is something you are not going to re-implement in each component.</p>
<p>You can save your time by using Angular CLI to generate a new &quot;log&quot; service utilizing the following command:</p>
<pre><code class="language-sh">ng g service services/log
</code></pre>
<p>That should give you a scaffold for a new service called <code>LogService</code>:</p>
<pre><code class="language-ts">// src/app/services/log.service.ts

import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class LogService {

  constructor() { }

}
</code></pre>
<p>We use a special <code>@Injectable</code> decorator here to mark the class and instruct Angular
that the given class should participate in the dependency injection layer.</p>
<p>All classes marked with <code>@Injectable</code> can get imported into other entities like services, components, directives or pipes.
The Angular framework creates instances of those classes, usually in the form of &quot;singletons&quot;,
and injects into other primitives on demand.</p>
<p>Note the warning message that Angular CLI generates for every new service scaffold:</p>
<pre><code class="language-text">installing service
  create src/app/services/log.service.spec.ts
  create src/app/services/log.service.ts
  WARNING Service is generated but not provided, it must be provided to be used
</code></pre>
<p>We are going to walk through Modules feature later in this chapter.
For now, just edit the <code>app.module.ts</code> file and add the <code>LogService</code> file to the <code>providers</code> section as in the following example:</p>
<pre><code class="language-ts">// src/app/app.module.ts
// ...

import { LogService } from './services/log.service';

@NgModule({
  declarations: [/* ... */],
  imports: [/* ... */],
  providers: [
    LogService
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>That allows injecting <code>LogService</code> into all application components,
including the <code>component1</code> and <code>component2</code> we have created earlier.</p>
<p>Next, let's extend the service implementation with an <code>info</code> method we can reuse across the components:</p>
<pre><code class="language-ts">// src/app/services/log.service.ts

@Injectable({ providedIn: 'root' })
export class LogService {

  constructor() { }

  info(message: string) {
    console.log(`[info] ${message}`);
  }

}
</code></pre>
<p>At this point, we got a minimal logging service implementation that we can use in our components.</p>
<h3 id="injecting-and-using-logservice"><a class="header" href="#injecting-and-using-logservice">Injecting and Using LogService</a></h3>
<p>We are going to use constructor parameters to inject the <code>LogService</code> created earlier.</p>
<p>The Angular framework takes care of all the intermediate steps needed to find the expected type of the service,
instantiate it and provide as a parameter when building our component.</p>
<pre><code class="language-ts">// src/app/component1/component1.component.ts

import { Component } from '@angular/core';
import { LogService } from './../services/log.service';

@Component({/*...*/})
export class Component1Component {

  constructor(logService: LogService) {
    logService.info('Component 1 created');
  }

}
</code></pre>
<p>You can now try to update the second component implementation yourself
and add the same LogService integration as in the example above.</p>
<p>Once you are finished updating the code, run the application,
and you should see the following output in the browser console:</p>
<pre><code class="language-text">[info] Component 1 created
[info] Component 2 created
</code></pre>
<h2 id="providers-1"><a class="header" href="#providers-1">Providers</a></h2>
<p>In the previous examples, you should have noticed that to import and use a class decorated with <code>@Injectable</code>
one needs to declare its Type in the <code>providers</code> array of the main application Module.</p>
<p>That makes Angular &quot;know&quot; about the services when instantiating components for your web application.</p>
<p>You can have numerous services that perform various sets of functionality, all registered within the root module:</p>
<pre><code class="language-ts">@NgModule({
  // ...,

  providers: [
    ...
    LogService,
    AuthenticationService,
    AvatarService,
    UserService,
    ChatService
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The concept of <code>providers</code> in Angular goes beyond the collection of classes, in fact,
it supports several powerful ways to control how dependency injection behaves at runtime.</p>
<p>Besides strings, the framework supports an object-based notation for defining providers.</p>
<h3 id="using-a-class"><a class="header" href="#using-a-class">Using a Class</a></h3>
<p>Earlier in this chapter, we have been using a string value to define a LogService dependency in the <code>providers</code> section.
We can express the same value with the help of the following notation:</p>
<pre><code class="language-ts">{ provide: &lt;key&gt;, useClass: &lt;class&gt; }
</code></pre>
<p>Let's take a look at the next example:</p>
<pre><code class="language-ts">@NgModule({
  // ...
  
  providers: [
    { provide: LogService, useClass: LogService }
  ],

  //...
})
export class AppModule { }
</code></pre>
<p>We are using <code>LogService</code> both as a &quot;key&quot; for injection and as a &quot;value&quot; to build a new instance for injection.</p>
<p>The main feature of this approach is that &quot;key&quot; and &quot;value&quot; can be different classes.
That allows swapping the value of the service with a custom implementation if needed, or with a Mock object for an improved unit testing experience.</p>
<p>Now, let's create a custom logger implementation <code>CustomLogService</code>:</p>
<pre><code class="language-sh">ng g service services/custom-log
</code></pre>
<p>Next, implement the <code>info</code> method, but this time it should contain some different output for us to distinguish both implementations:</p>
<pre><code class="language-ts">import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CustomLogService {

  constructor() { }

  info(message: string) {
    console.log(`[custom]: [info] ${message}`);
  }

}
</code></pre>
<p>Finally, you need to import this class into the main application module and declare as a new provider with the &quot;LogService&quot; key.
Don't forget to comment out or remove the former logger declaration as in the example below:</p>
<pre><code class="language-ts">import { LogService } from './services/log.service';
import { CustomLogService } from './services/custom-log.service';

@NgModule({
  // ...,

  providers: [
    // LogService
    { provide: LogService, useClass: CustomLogService }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The code above means that all the components that inject the <code>LogService</code> as part of the constructor parameters
are going to receive the <code>CustomLogService</code> implementation at runtime.</p>
<p>Essentially we are swapping the value of the logger, and no component is going to notice that.
That is the behavior developers often use for unit testing purposes.</p>
<p>If you now run the web application and navigate to browser console, you should see the following output:</p>
<pre><code class="language-text">[custom]: [info] Component 1 created
[custom]: [info] Component 2 created
</code></pre>
<p>Strings now contain &quot;[custom]: &quot; as a prefix, which proves the <code>Component1</code> and <code>Component2</code>
are now dealing with the <code>CustomLogService</code> code that has been successfully injected using the <code>LogService</code> key.</p>
<h3 id="using-a-class-factory"><a class="header" href="#using-a-class-factory">Using a Class Factory</a></h3>
<p>Previously we have been relying on the Angular framework to create instances of the injectable entities.</p>
<p>There is also a possibility to control how the class gets instantiated if you need more than just a default constructor calls.
Angular provides support for &quot;class factories&quot; for that very purpose.</p>
<p>You are going to use the following notation for class factories:</p>
<pre><code class="language-ts">{ provide: &lt;key&gt;, useFactory: &lt;function&gt; }
</code></pre>
<p>Before we jump into configuration details, let's extend our newly introduced <code>CustomLogService</code> service with the custom &quot;prefix&quot; support.
We are going to implement a special <code>setPrefix</code> method:</p>
<pre><code class="language-ts">import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CustomLogService {

  private prefix = '[custom]';

  setPrefix(value: string) {
    this.prefix = value;
  }

  info(message: string) {
    console.log(`${this.prefix}: [info] ${message}`);
  }

}
</code></pre>
<p>As you can see from the code above the <code>info</code> method is going to use a custom prefix for all the messages.</p>
<p>Next, create an exported function <code>customLogServiceFactory</code> that is going to control how the CustomLogService instance gets created.
In our case we are going to provide a custom prefix like in the example below:</p>
<pre><code class="language-ts">export function customLogServiceFactory() {
  const service = new CustomLogService();
  service.setPrefix('(factory demo)');
  return service;
}
</code></pre>
<p>As you can imagine, there could be more sophisticated configuration scenarios for all application building blocks,
including services, components, directives and pipes.</p>
<p>Finally, you can use the factory function for the <code>LogService</code>.
In this case, we both replace the real instance with the <code>CustomLogService</code>, and pre-configure the latter with a custom prefix for info messages:</p>
<pre><code class="language-ts">@NgModule({
  // ...
  
  providers: [
    { provide: LogService, useFactory: customLogServiceFactory }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>This time, when the application runs, you should see the following output:</p>
<pre><code class="language-text">(factory demo): [info] Component 1 created
(factory demo): [info] Component 2 created
</code></pre>
<h4 id="class-factories-with-dependencies"><a class="header" href="#class-factories-with-dependencies">Class Factories With Dependencies</a></h4>
<p>When you use the default provider registration for a service, directive or component,
the Angular framework automatically manages and injects dependencies if needed.
In the case of factories, you can use additional <code>deps</code> property to define dependencies
and allow your factory function to access corresponding instances during execution.</p>
<p>Let's imagine we need to manually bootstrap the <code>AuthenticationService</code>
that depends on the <code>RoleService</code> and <code>LogService</code> instances.</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class AuthenticationService {

  constructor(private roles: RoleService,
              private log: LogService) {
  }
  
  // ...
}
</code></pre>
<p>We should declare our factory-based provider the following way now:</p>
<pre><code class="language-ts">@NgModule({
  // ...,
  
  providers: [
      {
        provide: AuthenticationService,
        useFactory: authServiceFactory,
        deps: [ RoleService, LogService ]
      }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>With the code above we instruct Angular to resolve the <code>RoleService</code> and <code>LogService</code>
and use with our custom factory function when the <code>AuthenticationService</code> singleton instance gets created for the first time.</p>
<p>Finally, your factory implementation should look similar to the following one:</p>
<pre><code class="language-ts">export function authServiceFactory(roles: RoleService, log: LogService) {
  const service = new AuthenticationService(roles, log);
  // do some additional service setup
  return service;
}
</code></pre>
<h3 id="using-inject-decorator"><a class="header" href="#using-inject-decorator">Using @Inject Decorator</a></h3>
<p>Another important scenario you might be interested in is the <code>@Inject</code> decorator.</p>
<p>The <code>@Inject</code> decorator instructs Angular that a given parameter must get injected at runtime.
You can also use it to get references to &quot;injectables&quot; using string-based keys.</p>
<p>To demonstrate <code>@Inject</code> decorator in practice let's create a <code>dateFactory</code> function to generate current date:</p>
<pre><code class="language-ts">// src/app/app.module.ts

export function dateFactory() {
  return new Date();
}
</code></pre>
<p>Now we define a custom provider with the key <code>DATE_NOW</code> that is going to use our new factory.</p>
<pre><code class="language-ts">@NgModule({
  // ...,

  providers: [
    { provide: 'DATE_NOW', useFactory: dateFactory }
  ],

  // ...
})
export class AppModule { }
</code></pre>
<p>For the next step, you can import the <code>@Inject</code> decorator from the <code>angular/core</code> namespace
and use it with the <code>Component1</code> we created earlier in this chapter:</p>
<pre><code class="language-ts">import { /*...,*/ Inject } from '@angular/core';

@Component({...})
export class Component1Component {

  constructor(logService: LogService, @Inject('DATE_NOW') now: Date) {
    logService.info('Component 1 created');
    logService.info(now.toString());
  }

}
</code></pre>
<p>There are two points of interest in the code above. First, we inject <code>LogService</code> instance
as a <code>logService</code> parameter using its type definition: <code>logService: LogService</code>.
Angular is smart enough to resolve the expected value based on the <code>providers</code> section in the Module, using <code>LogService</code> as the key.</p>
<p>Second, we inject a date value into the <code>now</code> parameter.
This time Angular may experience difficulties resolving the value based on the <code>Date</code> type,
so we have to use the <code>@Inject</code> decorator to explicitly bind <code>now</code> parameter to the <code>DATE_NOW</code> value.</p>
<p>The browser console output, in this case, should be as the following one:</p>
<pre><code class="language-text">(factory demo): [info] Component 1 created
(factory demo): [info] Sun Aug 06 2017 08:45:36 GMT+0100 (BST)
(factory demo): [info] Component 2 created
</code></pre>
<p>Another important use case for the @Inject decorator is using custom types in TypeScript
when the service has different implementation class associated with the provider key,
like in our early examples with LogService and CustomLogService.</p>
<p>Below is an alternative way you can use to import <code>CustomLogService</code> into the component and use all the API exposed:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class Component1Component {

  constructor(@Inject(LogService) logService: CustomLogService) {
    logService.info('Component 1 created');
  }

}
</code></pre>
<p>In this case, you are getting access to real <code>CustomLogService</code> class that is injected by Angular for all the <code>LogService</code> keys.
If your custom implementation has extra methods and properties, not provided by the <code>LogService</code> type, you can use them from within the component now.</p>
<p>This mechanism is often used in unit testing when the Mock classes expose additional features to control the execution and behavior flow.</p>
<h3 id="using-a-value"><a class="header" href="#using-a-value">Using a Value</a></h3>
<p>Another scenario for registering providers in the Angular framework is providing instances directly, without custom or default factories.</p>
<p>The format, in this case, should be as following:</p>
<pre><code class="language-ts">{ provide: &lt;key&gt;, useValue: &lt;value&gt; }
</code></pre>
<p>There are two main scenarios of providing the values.</p>
<p>The first scenario is pretty much similar to the factory functions you can create and initialize the service instance
before other components and services use it.</p>
<p>Below is the basic example of how you can instantiate and register custom logging service by value:</p>
<pre><code class="language-ts">const logService = new CustomLogService();
logService.setPrefix('(factory demo)');

@NgModule({
  // ...
  
  providers: [
    { provide: LogService, useValue: logService }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The second scenario is related to configuration objects you can pass to initialize or setup other components and services.</p>
<p>Let's now register a <code>logger.config</code> provider with a JSON object value:</p>
<pre><code class="language-ts">@NgModule({
  // ...,

  providers: [
    {
      LogService,
      {
        provide: 'logger.config',
        useValue: {
          logLevel: 'info',
          prefix: 'my-logger'
        }
      }
    }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>Now any component, service or directive can receive the configuration values by injecting it as <code>logger.config</code>.
To enable static type checking you can create a TypeScript interface describing the settings object:</p>
<pre><code class="language-ts">export interface LoggerConfig {
  logLevel?: string;
  prefix?: string;
}
</code></pre>
<p>Finally, proceed to the <code>LogService</code> code and inject the JSON object
using the <code>logger.config</code> token and <code>LoggerConfig</code> interface like in the following example:</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class LogService {

  constructor(@Inject('logger.config') config: LoggerConfig) {
    console.log(config);
  }

  info(message: string) {
    console.log(`[info] ${message}`);
  }

}
</code></pre>
<p>For the sake of simplicity we just log the settings content to the browser console.
Feel free to extend the code with configuring the log service behavior based on the incoming setting values.</p>
<p>If you run the web application right now and open the browser console you should see the next output:</p>
<pre><code class="language-text">{
  logLevel: 'info',
  prefix: 'my-logger'
}
</code></pre>
<p>Registering providers with exact values is a compelling feature when it comes to global configuration and setup.
Especially if you are building redistributable components, directives or services that developers can configure from the application level.</p>
<h3 id="using-an-alias"><a class="header" href="#using-an-alias">Using an Alias</a></h3>
<p>The next feature we are going to see in action is &quot;provider alias&quot;.</p>
<p>You are probably not going to use this feature frequently in applications,
but it is worth taking a look at what it does if you plan to create and maintain redistributable component libraries.</p>
<p>Let's imagine a scenario when you have created a shared component library with an <code>AuthenticationService</code> service
that performs various login and logout operations that you and other developers
can reuse across multiple applications and other component libraries.</p>
<p>After some time you may find another service implementation with the same APIs,
or let's assume you want to replace the service with a newer <code>SafeAuthenticationService</code> implementation.</p>
<p>The main issue you are going to come across when replacing Types is related to breaking changes.
The old service might be in use in a variety of modules and applications, many files import the Type,
use in constructor parameters to inject it, and so on.</p>
<p>For the scenario above is where &quot;alias&quot; support comes to the rescue.
It helps you to smooth the transition period for old content and provide backwards compatibility with existing integrations.</p>
<p>Let's now take a look at the next example:</p>
<pre><code class="language-ts">@NgModule({
  // ...
  
  providers: [
    SafeAuthenticationService,
    { provide: AuthenticationService, useExisting: SafeAuthenticationService }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>As you can see from the example above, we register a new <code>SafeAuthenticationService</code> service
and then declare an <code>AuthenticationService</code> that points to the same <code>SafeAuthenticationService</code>.</p>
<p>Now all the components that use <code>AuthenticationService</code> are going to receive the instance of the <code>SafeAuthenticationService</code> service automatically.
All the newly introduced components can now reference new service without aliases.</p>
<blockquote>
<p><strong>Difference with the &quot;useClass&quot;</strong></p>
<p>You may wonder what's the difference with the <code>useClass</code> provider registration compared to the <code>useExisting</code> one.</p>
<p>When using <code>useClass</code>, you are going to end up with two different instances registered at the same time.
That is usually not a desirable behavior as services may contain events for example, and various components may have issues finding the &quot;correct&quot; instance.</p>
<p>The <code>useExisting</code> approach allows you to have only one singleton instance referenced by two or more injection tokens.</p>
</blockquote>
<h2 id="injection-tokens"><a class="header" href="#injection-tokens">Injection Tokens</a></h2>
<p>As you might have already understood the Angular dependency injection layer keeps a map of providers that are being identified by &quot;keys&quot;,
also known as &quot;injection tokens&quot;, and uses this map to resolve, create and inject instances at runtime.</p>
<p>The injection tokens can be of different types. We have already tried Types and Strings in action in previous sections.</p>
<h3 id="type-tokens"><a class="header" href="#type-tokens">Type Tokens</a></h3>
<p>Type-based injection tokens are the most commonly used way to register providers.
Typically you import the service type from the corresponding file and put it into the <code>providers</code> section of the module.</p>
<pre><code class="language-ts">import { LogService } from './services/log.service';

@NgModule({
  // ...
  
  providers: [
    LogService
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The same applies to custom provider registration options we tried earlier:</p>
<pre><code class="language-ts">providers: [
  { provide: LogService, useClass: LogService },
  { provide: LogService, useFactory: customLogServiceFactory },
  { provide: LogService, useValue: logService },
  { provide: AuthenticationService, useExisting: SafeAuthenticationService }
]
</code></pre>
<p>In all the cases above we use a real Type reference to register a new provider.</p>
<h3 id="string-tokens"><a class="header" href="#string-tokens">String Tokens</a></h3>
<p>Another way to register a provider involves the string-based injection tokens.
Typically you are going to use strings when there is no Type reference available,
for example when registering plain values or objects:</p>
<pre><code class="language-ts">providers: [
  { provide: 'DATE_NOW', useFactory: dateFactory },
  { provide: 'APP_VERSION', useValue: '1.1.0' },
  {
    provide: 'logger.config',
    useValue: {
      logLevel: 'info',
      prefix: 'my-logger'
    }
  }
]
</code></pre>
<h3 id="generic-injectiontoken"><a class="header" href="#generic-injectiontoken">Generic InjectionToken</a></h3>
<p>Also, Angular provides a special generic class <code>InjectionToken&lt;T&gt;</code> to help you create custom injection tokens
backed by specific types: primitives, classes or interfaces.
That enables static type checks and prevents many type-related errors at early stages.</p>
<p>Let's create separate file <code>tokens.ts</code> to hold our custom injection tokens, and create a simple string-based one:</p>
<pre><code class="language-ts">import { InjectionToken } from '@angular/core';

export const REST_API_URL = new InjectionToken&lt;string&gt;('rest.api.url');
</code></pre>
<p>Now we can use this token within the main application module to register a URL value
that all components and services can use when needed:</p>
<pre><code class="language-ts">import { REST_API_URL } from './tokens';

@NgModule({
  // ...,

  providers: [
    // ...,
    
    { provide: REST_API_URL, useValue: 'http://localhost:4200/api' }
  ]
})
</code></pre>
<p>From this moment we can use the same token to import registered value in the service or a component like in the example below:</p>
<pre><code class="language-ts">// ...

import { REST_API_URL } from './../tokens';

@Injectable({ providedIn: 'root' })
export class LogService {

  constructor(@Inject(REST_API_URL) restApiUrl: string) {
    console.log(restApiUrl);
  }

  // ...
}
</code></pre>
<p>At runtime, you should see the actual value of the <code>REST_API_URL</code> provider in the browser console: <code>http://localhost:4200/api</code>.</p>
<p>As mentioned earlier, you can also use interfaces or classes with the <code>InjectionToken&lt;T&gt;</code>.
That does not affect the process of dependency injection but gives you an opportunity for static compile-time checks
and auto completion if your code editor supports TypeScript.</p>
<p>Let's create a token for the <code>LoggerConfig</code> interface we set up in this chapter earlier:</p>
<pre><code class="language-ts">export interface LoggerConfig {
  logLevel?: string;
  prefix?: string;
}

export const LOGGER_CONFIG = new InjectionToken&lt;LoggerConfig&gt;('logger.config');
</code></pre>
<p>You can now define a type-safe configuration object and register it with the dependency injection system using main application module:</p>
<pre><code class="language-ts">const loggerConfig: LoggerConfig = {
  logLevel: 'warn',
  prefix: 'warning:'
};

@NgModule({
  // ...,
  
  providers: [
    // ...,
    
    { provide: LOGGER_CONFIG, useValue: loggerConfig }
  ]
})
</code></pre>
<p>Finally, you can use that token to inject configuration into the LogService and use it to setup the service accordingly:</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class LogService {

  constructor(@Inject(LOGGER_CONFIG) config: LoggerConfig) {
    console.log(config);
  }

  // ...
}
</code></pre>
<h2 id="injecting-multiple-instances"><a class="header" href="#injecting-multiple-instances">Injecting Multiple Instances</a></h2>
<p>Previously we have been working with injectables backed by the singletons.
That means any components, directives or other services are typically referencing the same instance created only once on the very first request.</p>
<p>There are cases, however, when you may want to have multiple service instances injected at runtime utilizing a single injection token.</p>
<p>An excellent example is plugin systems and plugins support.
Typically you are going to require a special contract or interface that every external plugin must implement.
The service, component or an application layer need to rely on only the common and shared API,
and it makes sense injecting an entire collection of the plugin instances without knowing exact types.</p>
<p>Let's build a logging service that supports external plugins and injects them as a single collection.</p>
<p>First, create a <code>LogPlugin</code> interface for external plugin implementation,
and a basic <code>CompositeLogService</code> scaffold for our service.</p>
<p>We are going to get back to it shortly.</p>
<pre><code class="language-ts">// src/app/services/composite-log.service.ts

export interface LogPlugin {
  name: string;
  level: string;
  log(message: string);
}

@Injectable({ providedIn: 'root' })
export class CompositeLogService {

  constructor() { }

}
</code></pre>
<p>The <code>LogPlugin</code> interface contains a bare minimum of APIs, at this point we need a <code>name</code> for demo and debugging purposes,
alongside the level of the messages our plugin supports and the method to write a log message.</p>
<p>Next, create an injection token <code>LOGGER_PLUGIN</code> backed by the interface we have just created above.</p>
<pre><code class="language-ts">// src/app/tokens.ts

import { LogPlugin } from './services/composite-log.service';

export const LOGGER_PLUGIN = new InjectionToken&lt;LogPlugin&gt;('logger.plugin');
</code></pre>
<p>We are going to use that token to register various logger plugins, and also inject existing plugin instances for the <code>CompositeLogService</code>.</p>
<p>After that let's create a couple of Loggers that implement the <code>LogPlugin</code> interface.
There is going to be one class for error messages and one for warnings.</p>
<pre><code class="language-ts">import { LogPlugin } from './composite-log.service';

export class ErrorLogPlugin implements LogPlugin {

    name = 'Error Log Plugin';
    level = 'error';

    log(message: string) {
      console.error(message);
    }
}

export class WarningLogPlugin implements LogPlugin {

  name = 'Warning Log Plugin';
  level = 'warn';

  log(message: string) {
    console.warn(message);
  }
}
</code></pre>
<p>Now you are ready to register the service and its plugins with the main application module like in the following example:</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { LOGGER_PLUGIN } from './tokens';
import { ErrorLogPlugin, WarningLogPlugin } from './services/loggers';


@NgModule({
  providers: [
    CompositeLogService,
    { provide: LOGGER_PLUGIN, useClass: ErrorLogPlugin, multi: true },
    { provide: LOGGER_PLUGIN, useClass: WarningLogPlugin, multi: true }
  ]
})
</code></pre>
<p>Please note that the most important part that enables multiple injections is the <code>multi</code> attribute we set to <code>true</code> when registering a provider.</p>
<p>Now let's get back to our <code>CompositeLogService</code> and inject instances of all previously registered plugins using the following format:</p>
<pre><code class="language-ts">constructor(@Inject(LOGGER_PLUGIN) plugins: LogPlugin[])
</code></pre>
<p>To demonstrate the instances, we are going to enumerate the injected collection and log all plugin names to the browser console:</p>
<pre><code class="language-ts">// src/app/services/composite-log.service.ts

import { Injectable, Inject } from '@angular/core';
import { LOGGER_PLUGIN } from './../tokens';

export interface LogPlugin {
  name: string;
  level: string;
  log(message: string);
}

@Injectable({ providedIn: 'root' })
export class CompositeLogService {

  constructor(@Inject(LOGGER_PLUGIN) plugins: LogPlugin[]) {
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      for (const plugin of plugins) {
        console.log(`Loading plugin: ${plugin.name} (level: ${plugin.level})`);
      }
    }
  }

}
</code></pre>
<p>The service is ready for testing. The only thing we have left is to inject it somewhere.
The main application component is the best place to test all the newly introduced code quickly.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { CompositeLogService } from './services/composite-log.service';

@Component({/*...*/})
export class AppComponent {
  
  constructor(private logService: CompositeLogService) {
  }
  
}
</code></pre>
<p>Now if you run the application the console log is going to contain the following output:</p>
<pre><code class="language-text">Loading plugin: Error Log Plugin (level: error)
Loading plugin: Warning Log Plugin (level: warn)
</code></pre>
<p>In the real-life scenario, you would most probably want the log service to use different types of plugins for certain purposes.
Let's now extend our service and introduce a <code>log</code> method redirects logging calls to the plugins that support the corresponding levels.</p>
<pre><code class="language-ts">// src/app/services/composite-log.service.ts

@Injectable({ providedIn: 'root' })
export class CompositeLogService {
  // ...

  log(level: string, message: string) {
    const logger = this.plugins.find(p =&gt; p.level === level);
    if (logger) {
      logger.log(message);
    }
  }
  
}
</code></pre>
<p>To test how it works you can even use the <code>log</code> method within the service itself.
Update the constructor to send a message once all the external plugins are enumerated:</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class CompositeLogService {
  
  constructor(@Inject(LOGGER_PLUGIN) private plugins: LogPlugin[]) {
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      for (const plugin of plugins) {
        console.log(`Loading plugin: ${plugin.name} (level: ${plugin.level})`);
      }
      this.log('warn', 'All plugins loaded');
    }
  }
  
}
</code></pre>
<p>For the sake of simplicity, we are going to use the <code>warn</code> level because we got only <code>warn</code> and <code>error</code> loggers registered.
Feel free to extend the collection of the loggers with the <code>info</code> or <code>debug</code> one as an exercise.</p>
<p>Once you run the web application, the main component should provide the following output to the browser console:</p>
<pre><code class="language-text">Loading plugin: Error Log Plugin (level: error)
Loading plugin: Warning Log Plugin (level: warn)
All plugins loaded
</code></pre>
<p>Now you are ready to deal with multiple instances injected as collections and got a basic scenario working in practice.</p>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional Dependencies</a></h2>
<p>Previously, we have successfully created a <code>CompositeLogService</code> service
based on multiple plugins injected with the same custom token.</p>
<p>However, what happens when there are no logger plugins registered within the application?
Let's comment out the plugin registration section in the app module providers to see what happens at runtime.</p>
<pre><code class="language-ts">@NgModule({
  providers: [
    CompositeLogService // ,
    // { provide: LOGGER_PLUGIN, useClass: ErrorLogPlugin, multi: true },
    // { provide: LOGGER_PLUGIN, useClass: WarningLogPlugin, multi: true }
  ]
})
</code></pre>
<p>Now if you rebuild and run your application it is going to crash with the following error in the browser console:</p>
<pre><code class="language-text">Error: No provider for InjectionToken logger.plugin!
</code></pre>
<p>The error above is an expected behavior.</p>
<p>Essentially, when you declare a dependency within the constructor parameters,
you instruct the Angular framework to ensure the corresponding dependency indeed exists, and injection can happen.</p>
<p>There are scenarios when having an instance is not mandatory, and application can function without it,
like in our case with logger plugins - the log service can have default fallback behaviour in case no plugins are present.</p>
<p>For those kinds of scenarios, the Angular framework provides us with the &quot;@Optional&quot; decorator
that allows making particular injections &quot;optional&quot; rather than &quot;mandatory&quot; during dependency injection phase.</p>
<pre><code class="language-ts">import { /*...,*/ Optional } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CompositeLogService {

  constructor((@Optional() @Inject(LOGGER_PLUGIN) private plugins: LogPlugin[]) {
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      // ...
    } else {
      console.log('No logger plugins found.');
    }
  }

 // ...
}
</code></pre>
<p>As you can see from the code above, we now have a possibility to check whether any plugins are available,
and perform the fallback behavior if needed.
Just for the demo purposes, we log the information message to the console:</p>
<pre><code class="language-text">No logger plugins found.
</code></pre>
<p>The <code>@Optional</code> decorator is a handy mechanism that helps you to prevent the runtime errors
when some content is missing or is not registered correctly.</p>
<h2 id="manual-injection"><a class="header" href="#manual-injection">Manual Injection</a></h2>
<p>You are not limited to automatic dependency injection mechanism.
The Angular provides you with a low-level APIs that allow you to resolve and create instances manually from code.</p>
<p>The DI utility class is called <code>ReflectiveInjector</code>, and you can import it from the <code>@angular/core</code> namespace.
It helps to create the <code>injectors</code> filled with resolved and created instances of the providers,
similar to those we used with the application modules.</p>
<pre><code class="language-ts">import { ReflectiveInjector } from '@angular/core';

@Component({/*...*/})
export class AppComponent {
  
  constructor() {
    const injector = ReflectiveInjector.resolveAndCreate([ LogService ]);
    const logService: LogService = injector.get(LogService);
    logService.info('hello world');
  }

}
</code></pre>
<p>Typically you are going to use this API only for concrete scenarios like unit testing or dynamic content creation.</p>
<blockquote>
<p>You can get more detailed information including code examples in the following article: <a href="https://angular.io/api/core/ReflectiveInjector">Reflective Injector</a>.</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We have covered the main scenarios for service and provider registration and tested them in action.</p>
<p>You can also refer to the <a href="https://angular.io/guide/dependency-injection#dependency-injection">Dependency Injection</a> article
for even more detailed information on how dependency injection works in Angular.</p>
<h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>There are three main event cases we are going to review in this chapter.
With Angular, you can raise Component events, DOM events and Service events.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/events">angular/events</a></strong> folder.</p>
</blockquote>
<p>To address all three scenarios let's create a simple <code>Panel</code> component that consists of the <code>Body</code>, <code>Header</code> and <code>Footer</code>.
The Header and Footer are going to be separate components.</p>
<p>First, generate a new Angular application using the Angular CLI tool.
Then execute the following commands to generate the prerequisites:</p>
<pre><code class="language-sh">ng g component panel
ng g component panel-header
ng g component panel-footer
</code></pre>
<p>Next, update the <code>Panel</code> component template like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/panel/panel.component.html --&gt;

&lt;app-panel-header&gt;&lt;/app-panel-header&gt;

&lt;p&gt;
  panel works!
&lt;/p&gt;

&lt;app-panel-footer&gt;&lt;/app-panel-footer&gt;
</code></pre>
<p>Finally, we can replace the default auto-generated content of the main application template
with the <code>Panel</code> we have just created above:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-panel&gt;
&lt;/app-panel&gt;
</code></pre>
<p>If you make a pause at this point and run the <code>ng serve --open</code> command you should see the following output on the main page:</p>
<pre><code class="language-text">panel-header works!

panel works!

panel-footer works!
</code></pre>
<p>At this point, we got all the basic prerequisites for testing the events.</p>
<h2 id="component-events"><a class="header" href="#component-events">Component Events</a></h2>
<p>It is now time to improve our <code>Header</code> component.</p>
<p>Let's provide a way to set the content text for the component to display when rendered,
and a simple click event <code>contentClick</code> that gets emitted every time user clicks the content.</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

import { /*...,*/ Input, Output, EventEmitter } from '@angular/core';

@Component({...})
export class PanelHeaderComponent {

  @Input()
  content = 'Panel header';

  @Output()
  contentClick = new EventEmitter();

  onContentClicked() {
    console.log('panel header clicked');
    this.contentClick.next();
  }

}
</code></pre>
<p>From the earlier chapters, you already know that we use <code>@Input</code> decorator
for the class properties we want to set or bind from the outside.
We also need to use the <code>@Output</code> decorator to mark our events.</p>
<blockquote>
<p><strong>Output Events</strong></p>
<p>You can get more details on the component events in the <a href="ch07-01-component-events.html#output-events">Output Events</a> section of the Components chapter.</p>
</blockquote>
<p>Also, note that in the example above we also add the <code>onContentClicked</code> method that is going to raise our <code>contentClick</code> event.</p>
<p>Below is an example of a minimal <code>Header</code> component template we can use to display a <code>content</code> value:</p>
<pre><code class="language-html">&lt;!-- src/app/panel-header/panel-header.component.html --&gt;

&lt;p (click)=&quot;onContentClicked()&quot;&gt;
    {{ content }}
&lt;/p&gt;
</code></pre>
<p>As you can see, we link the <code>click</code> event of the enclosed <code>p</code> element with the <code>onContentClicked</code> handler
that temporarily sends a message to the console log for testing/debugging purposes
and also invokes the <code>contentClicked</code> event that other components can use.</p>
<p>Also, we set a default value for the <code>content</code> property to the &quot;Panel header&quot; string.
So at the runtime, the content or application main page is going to look similar to the following:</p>
<pre><code class="language-text">Panel header

panel works!

panel-footer works!
</code></pre>
<p>However, we are not going to use the <code>Header</code> component directly.
It is the <code>Panel</code> component that needs it.
So we should allow our <code>Panel</code> component to control the header content, and also react on header click events.
Let's toggle the panel content as an example.</p>
<p>Edit the panel component class and add the <code>header</code> input property to hold the text for the <code>Header</code>,
and <code>displayBody</code> property to serve as a flag for showing and hiding the main panel content,
like in the example below:</p>
<pre><code class="language-ts">// src/app/panel/panel.component.ts

import { /*...,*/ Input } from '@angular/core';

@Component({...})
export class PanelComponent {

  @Input()
  header = 'My panel header';

  displayBody = true;
}
</code></pre>
<p>For the next step, let's update the panel component template
to link the <code>Header</code> properties with the newly introduced class members:</p>
<pre><code class="language-html">&lt;!-- src/app/panel/panel.component.html --&gt;

&lt;app-panel-header
  [content]=&quot;header&quot;
  (contentClick)=&quot;displayBody = !displayBody&quot;&gt;
&lt;/app-panel-header&gt;

&lt;ng-container *ngIf=&quot;displayBody&quot;&gt;
  &lt;p&gt;
    panel works!
  &lt;/p&gt;
&lt;/ng-container&gt;

&lt;app-panel-footer&gt;&lt;/app-panel-footer&gt;
</code></pre>
<p>You can now run the application and test your components by clicking the panel header text multiple times.
The panel should toggle its body content every time a header gets clicked.</p>
<p>Below is how the panel should look like by default, in the expanded state:</p>
<pre><code class="language-text">My panel header

panel works!

panel-footer works!
</code></pre>
<p>Also, the next example shows how the panel looks like in the <code>collapsed</code> state:</p>
<pre><code class="language-text">My panel header

panel-footer works!
</code></pre>
<p>Congratulations, you just got the component events working, and tested them in practice.
Now feel free to extend the <code>PanelFooterComponent</code> and add similar <code>content</code> and <code>contentClick</code> implementations.</p>
<h3 id="bubbling-up-child-events"><a class="header" href="#bubbling-up-child-events">Bubbling Up Child Events</a></h3>
<p>We have created a <code>PanelHeader</code> component earlier in this chapter.
Also, we introduced a <code>click</code> event for the component and made the <code>Panel</code> component host it within its template,
and toggle panel body content every time the <code>Panel Header</code> is clicked.</p>
<p>Imagine that the <code>&lt;app-panel&gt;</code> is a redistributable component, and you would like developers to have access to header clicks as well.
The <code>&lt;app-panel-header&gt;</code> however, is a child element, and developers do not have direct access to its instance when working with the <code>Panel</code>.
In this case, you would probably want your main <code>Panel</code> component re-throwing its child events.</p>
<p>We already got the <code>header</code> and the <code>footer</code> input properties that hold the values for the <code>&lt;app-panel-header</code> and <code>&lt;app-panel-footer&gt;</code> elements.
Let's now introduce two new output events and call them <code>headerClick</code> and <code>footerClick</code>.</p>
<pre><code class="language-ts">// src/app/panel/panel.component.ts

export class PanelComponent {

  displayBody = true;

  @Input()
  header = 'My panel header';

  @Input()
  footer = 'My panel footer';

  @Output()
  headerClick = new EventEmitter();

  @Output()
  footerClick = new EventEmitter();

  onHeaderClicked() {
    this.displayBody = !this.displayBody;
    this.headerClick.next();
  }

  onFooterClicked() {
    this.footerClick.next();
  }

}
</code></pre>
<p>As you can see from the code above, we also get two methods to raise our events.
The <code>onHeaderClicked</code> method is still toggling the panel body before raising the <code>headerClick</code> event.</p>
<p>Next, our <code>&lt;app-panel&gt;</code> component is going to watch the <code>contentClick</code> events of the child elements, and emit events for developers.
Update the HTML template and subscribe to the header and footer events like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/panel/panel.component.html --&gt;

&lt;app-panel-header
  [content]=&quot;header&quot;
  (contentClick)=&quot;onHeaderClicked()&quot;&gt;
&lt;/app-panel-header&gt;

&lt;ng-container *ngIf=&quot;displayBody&quot;&gt;
    &lt;p&gt;
        panel works!
    &lt;/p&gt;
&lt;/ng-container&gt;

&lt;app-panel-footer
  [content]=&quot;footer&quot;
  (contentClick)=&quot;onFooterClicked()&quot;&gt;
&lt;/app-panel-footer&gt;
</code></pre>
<p>Finally, let's test our panel events in action.
Update your main application template and subscribe to our newly introduced events for header and footer clicks:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-panel
  (headerClick)=&quot;onHeaderClicked()&quot;
  (footerClick)=&quot;onFooterClicked()&quot;&gt;
&lt;/app-panel&gt;
</code></pre>
<p>For the sake of simplicity we are going to log messages to browser console similar to the following:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {

  onHeaderClicked() {
    console.log('App component: Panel header clicked');
  }

  onFooterClicked() {
    console.log('App component: Panel footer clicked');
  }

}
</code></pre>
<p>If you compile and run your web application with the <code>ng serve --open</code> command,
you should be able to see messages in the console every time a header or footer elements of the panel get clicked.</p>
<h2 id="dom-events"><a class="header" href="#dom-events">DOM Events</a></h2>
<p>With multiple levels of nesting, the re-raising of child events quickly turns into a challenging and time-consuming process.
Like with our previous Panel example, to wrap it with another Angular component
developers may have to watch for panel events and raise them for the own implementation.
That is where native DOM events with bubbling support come to the rescue.</p>
<p>If set to bubble, a DOM event gets raised for every element up against the parent hierarchy.
Developers get an opportunity reacting on events that occur in deeply nested components.</p>
<blockquote>
<p><strong>Creating and triggering events</strong></p>
<p>You can get more details and examples on how to build and dispatch DOM events in the following article:
<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events">Creating and triggering events</a></p>
</blockquote>
<p>First, to raise a custom DOM event we need to get access to a native element of the component.
You can achieve that by injecting an <code>ElementRef</code> instance in the component constructor,
and saving as a private property called <code>elementRef</code>.</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

import { /*...,*/ ElementRef } from '@angular/core';

@Component({/*...*/})
export class PanelHeaderComponent {

    // ...

    constructor(private elementRef: ElementRef) {
    }

}
</code></pre>
<p>Next, we need updating the <code>onContentClicked</code> handler to raise an additional event.
You can leave the code to raise the <code>contentClick</code> event, so that component supports raising two types of the events at the same time.</p>
<p>Let's introduce a new <code>header-click</code> custom event that is set to bubble and contains clicked content in the <code>details</code> section.</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

@Component({/*...*/})
export class PanelHeaderComponent {

  // ...

  onContentClicked() {
    this.contentClick.next();

    this.elementRef.nativeElement.dispatchEvent(
      new CustomEvent('header-click', {
        detail: {
          content: this.content
        },
        bubbles: true
      })
    );
  }

}
</code></pre>
<p>We are now ready to see the newly introduced event in practice.</p>
<p>Let's update the main application component template with a top-most <code>div</code> element that is going to listen to the <code>header-click</code> event.
That is a good case to test event handling and see how event bubbles up to non-Angular elements.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div (header-click)=&quot;onDomHeaderClick($event)&quot;&gt;
  &lt;app-panel
    (headerClick)=&quot;onHeaderClicked()&quot;
    (footerClick)=&quot;onFooterClicked()&quot;&gt;
  &lt;/app-panel&gt;
&lt;/div&gt;
</code></pre>
<p>For testing purposes, we are going just to log the event details to the browser console.</p>
<pre><code class="language-ts">@Component({/*...*/})
export class AppComponent {

  // ...

  onDomHeaderClick(event) {
    console.log(event);
  }

}
</code></pre>
<p>Finally, if you run your web application at this point, and click the panel header content,
the following content should appear in the browser console output:</p>
<p><img src="images/ng-events-dom-01.png" alt="" /></p>
<p>As you can see from the picture above you can access all data in the custom event
including the &quot;detail&quot; object we have created earlier, and that contains our component-specific information.</p>
<p>Dispatching the custom DOM events is an excellent option if you want to allow developers to wrap your components,
or you are using composite components and trying to avoid re-throwing multiple events.</p>
<h2 id="service-events"><a class="header" href="#service-events">Service Events</a></h2>
<p>When working with events in Angular, you can achieve a significant level of flexibility
by utilizing the application services and service events.</p>
<p>Service-based events allow multiple components to communicate with each other
regardless of the component and DOM structure using the publish/subscribe approach.</p>
<p>Before we dive into details let's use Angular CLI and generate a new service using the following command:</p>
<pre><code class="language-sh">ng g service panel
</code></pre>
<p>You need to manually register the newly generated service within one of your modules.
For now, let's add the <code>PanelService</code> to the main application module in the <code>app.module.ts</code> file:</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { PanelService } from './panel.service';

@NgModule({
  providers: [
    PanelService
  ]
})
export class AppModule { }
</code></pre>
<p>Next, extend the service with a couple of events for header and footer clicks:</p>
<pre><code class="language-ts">// src/app/panel.service.ts

import { Injectable } from '@angular/core';
import { Subject } from 'rxjs/Rx';

import { PanelHeaderComponent } from './panel-header/panel-header.component';
import { PanelFooterComponent } from './panel-footer/panel-footer.component';

@Injectable({ providedIn: 'root' })
export class PanelService {

  headerClicked = new Subject&lt;PanelHeaderComponent&gt;();
  footerClicked = new Subject&lt;PanelFooterComponent&gt;();

}
</code></pre>
<p>In the example above, we are using generic <code>Subject&lt;T&gt;</code> to allow both emitting and subscribing to the same event.
We are going to pass either <code>PanelHeaderComponent</code> or <code>PanelFooterComponent</code> instance as the event argument.</p>
<p>Let's update the <code>PanelHeaderComponent</code> class and emit the <code>headerClicked</code> event like in the following example:</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

import { PanelService } from '../panel.service';

@Component({/*...*/})
export class PanelHeaderComponent {

  constructor(
    private panelService: PanelService,
    private elementRef: ElementRef) {
  }

  onContentClicked() {
    // ...
    
    // raise service event
    this.panelService.headerClicked.next(this);
  }
}
</code></pre>
<p>As you can see, the component now injects the <code>PanelService</code> instance
and saves a reference to the private <code>panelService</code> property so that click handler can use to emit the corresponding event.</p>
<p>Subscribing to the event is also simple.
The component, in our case main application one, injects the <code>PanelService</code>
and uses <code>headerClicked.subscribe</code> to wire the event handler code:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { PanelHeaderComponent } from './panel-header/panel-header.component';
import { PanelService } from './panel.service';

@Component({/*...*/})
export class AppComponent {

  constructor(panelService: PanelService) {
    panelService.headerClicked.subscribe(
      (header: PanelHeaderComponent) =&gt; {
        console.log(`Header clicked: ${header.content}`);
      }
    );
  }
}
</code></pre>
<p>Now if you run your web application and click the header you should see the following output in the browser console:</p>
<pre><code class="language-text">Header clicked: My panel header
</code></pre>
<p>Congratulations, you have just established a basic communication channel between header
and footer components with the rest of the application content.</p>
<p>Many other components and services now can subscribe and react to click events.
Of course, we got over-simplified examples; you can imagine more complex scenarios involving different events in your application.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/events">angular/events</a></strong> folder.</p>
</blockquote>
<h1 id="directives"><a class="header" href="#directives">Directives</a></h1>
<p>A directive is one of the core building blocks in Angular.</p>
<p>It allows easy manipulation of the DOM structure of HTML elements, change their appearance and layout,
or even extend the behavior if needed.</p>
<h2 id="introduction-to-directives"><a class="header" href="#introduction-to-directives">Introduction to Directives</a></h2>
<p>There are three types of directives in Angular you are going to work with:</p>
<ul>
<li><strong>Components</strong> - also known as <code>Directives with Templates</code>, see <strong><a href="ch05-01-components.html">Components</a></strong> chapter for a detailed overview;</li>
<li><strong>Attribute Directives</strong> - extend elements, change the look and feel of the host elements;</li>
<li><strong>Structural Directives</strong> - change elements, manipulate DOM layout, add or remove elements or completely change underlying view;</li>
</ul>
<p>Let's start with a new project to host various kinds of directives we are going to experiment with:</p>
<pre><code class="language-sh">ng new directive-example
cd directive-example
ng serve --open
</code></pre>
<h2 id="attribute-directives"><a class="header" href="#attribute-directives">Attribute Directives</a></h2>
<p>Attribute directives change appearance or behavior of a host DOM element.
Usually, they look like regular HTML element attributes.</p>
<p>Let's create a simple clickable directive and call it <code>Clickme</code>.</p>
<pre><code class="language-sh">ng g directive directives/clickme
</code></pre>
<p>Angular CLI generates directive with unit test and updates main application module:</p>
<pre><code class="language-sh">installing directive
  create src/app/directives/clickme.directive.spec.ts
  create src/app/directives/clickme.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>Initial implementation should look like the following one:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appClickme]'
})
export class ClickmeDirective {

  constructor() { }

}
</code></pre>
<p>Directives can interact with the host by listening to events and setting properties of the target element.</p>
<h3 id="handling-host-events"><a class="header" href="#handling-host-events">Handling host events</a></h3>
<p>Your newly created directive can listen to events with the help of the <code>HostListener</code> decorator.
Angular invokes decorated method when the host element emits a corresponding event.</p>
<p>The format of the <code>HostListener</code> decorator and metadata is as following:</p>
<pre><code class="language-ts">interface HostListener {

  eventName : string
  args : string[]

}
</code></pre>
<p>You can use it to decorate class methods like shown below:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

@HostListener('domEvent', ['$event'])
onEvent(event) {
  // ...
}
</code></pre>
<p>Angular should be listening for the 'domEvent' event (if supported by host element)
and invoke <code>onEvent</code> method of the directive controller.</p>
<p>The event handler is also going to get a reference to the original DOM event,
as we instruct Angular to map specific <code>$event</code> argument to the <code>event</code> parameter.
That means directive can inspect properties of the original event
and even prevent default behavior or event bubbling if necessary.</p>
<p>The easiest way to demonstrate <code>HostListener</code> in action is by wiring a standard <code>click</code> event.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

import { /*...,*/ HostListener } from '@angular/core';

...
export class ClickmeDirective {
    // ...
    
    @HostListener('click', ['$event'])
    onClicked(e: Event) {
        console.log(e);
        alert('Clicked');
    }
}
</code></pre>
<p>Next put a <code>div</code> element to the <code>app.component.html</code> and decorate it with your <code>appHighlight</code> directive:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;div class=&quot;click-area&quot; appClickme&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>You also need to have some space to click on; this is what we are going to use <code>highlight-area</code> CSS class for:</p>
<pre><code class="language-css">/* src/app/app.component.css */

.click-area {
  width: 100px;
  height: 100px;
  background-color: beige;
}
</code></pre>
<p>Below is how the main page looks like after your changes:</p>
<p><img src="images/directives-clickme-01.png" alt="" /></p>
<p>You get the default 'app works!' label generated by the Angular CLI, and coloured <code>div</code> element.
Now if you click anywhere on the beige area the browser should display an alert: </p>
<p><img src="images/directives-clickme-02.png" alt="" /></p>
<p>So as you can see in the example above, with the help of <code>HostListener</code>, you can listen to any event emitted by host element.
We have added <code>appClickme</code> directive as an attribute of the <code>div</code>, 
and every click on the <code>div</code> automatically triggers <code>onClicked</code> method in the <code>ClickmeDirective</code>.</p>
<p>You can use any target for the directive, for example:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;button appClickme&gt;Click me&lt;/button&gt;
&lt;span appClickme&gt;Click me&lt;/span&gt;
&lt;input type=&quot;text&quot; appClickme&gt;
</code></pre>
<h3 id="host-members-binding"><a class="header" href="#host-members-binding">Host members binding</a></h3>
<p>Angular also provides a way for a directive to change host properties by using a <code>HostBinding</code> decorator.</p>
<p>During change detection cycle Angular checks all property bindings and updates host element of the directive if bound value changes.</p>
<p>The format of the HostBinding decorator and metadata is as following:</p>
<pre><code class="language-ts">interface HostBinding {

  hostPropertyName : string

}
</code></pre>
<p>You can use this decorator to change:</p>
<ul>
<li>
<p>attributes (applies to all elements)</p>
<p><code>@HostBinding('attr.text)</code></p>
</li>
<li>
<p>properties (corresponding properties must exist)</p>
<p><code>@HostBinding('title')</code></p>
</li>
<li>
<p>style values (applies to all elements)</p>
<p><code>@HostBinding('style.background-color')</code></p>
</li>
<li>
<p>class names (applies to all elements)</p>
<p><code>@HostBinding('class.some-class-name')</code></p>
</li>
</ul>
<h4 id="binding-element-attributes"><a class="header" href="#binding-element-attributes">Binding element attributes</a></h4>
<p>If you want your directive to change element attributes, you can use this decorator with class methods like below:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

export class ClickmeDirective {

    @HostBinding('attr.propertyName')
    myProperty: string = 'hello world';

}
</code></pre>
<p>For example, if you apply directive to a <code>div</code> element, the property binding should cause the following attributes rendering at run time:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; propertyName=&quot;hello world&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Please note that if host property name parameter is not defined, then a class property name should be taken as a fallback value.</p>
<pre><code class="language-ts">@HostBinding()
title: string = 'element title';
</code></pre>
<p>This time, if you apply the directive to the <code>input</code> element, for instance, you should see the <code>title</code> property name as an attribute of the host:</p>
<pre><code class="language-ts">&lt;input appclickme=&quot;&quot; type=&quot;text&quot; title=&quot;element title&quot;&gt;
</code></pre>
<h4 id="binding-element-properties"><a class="header" href="#binding-element-properties">Binding element properties</a></h4>
<p>Keep in mind that in this case, the property should exist for a given element.
Angular should throw an error if you try to bind a missing property.</p>
<p>Let's try to bind a <code>value</code> property to demonstrate this behavior.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...
export class ClickmeDirective {

  @HostBinding()
  value: string = 'input value';

  // ...
}
</code></pre>
<p>You may still have a click area example on the main page, or you can do it once again:</p>
<pre><code class="language-html">&lt;div class=&quot;click-area&quot; appClickme&gt;
</code></pre>
<p>Angular should produce an error when page compiles and reloads:</p>
<pre><code class="language-text">Error: Uncaught (in promise): Error: Template parse errors:
Can't bind to 'value' since it isn't a known property of 'div'.

[ERROR -&gt;]&lt;div class=&quot;click-area&quot; appClickme&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>However, if you replace <code>div</code> with an <code>input</code> element that natively supports <code>value</code> property, you should get it rendered properly:</p>
<p><img src="images/directives-input-01.png" alt="" /> </p>
<p>You can, however, fix the issue and provide compatibility with all HTML elements by utilizing <code>attr.value</code> instead of <code>value</code> for the property binding:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...
export class ClickmeDirective {

  @HostBinding('attr.value')
  value: string = 'input value';

  // ...
}
</code></pre>
<p>In this case you are going to get the following HTML when both <code>&lt;input&gt;</code> and <code>&lt;div&gt;</code> are present on the page:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; class=&quot;click-area&quot; value=&quot;input value&quot;&gt;
  Click me
&lt;/div&gt;

&lt;input appclickme=&quot;&quot; type=&quot;text&quot; value=&quot;input value&quot;&gt;
</code></pre>
<p>Your main application component page should now render without errors.</p>
<p><img src="images/directives-input-02.png" alt="" /></p>
<h4 id="binding-style-attributes"><a class="header" href="#binding-style-attributes">Binding style attributes</a></h4>
<p>You bind single style attribute values using <code>@HostBinding('style.&lt;attribute&gt;)</code> format,
where <code>&lt;attribute&gt;</code> is a valid name of the CSS style attribute.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...
export class ClickmeDirective {
    // ...
    
    @HostBinding('style.background-color')
    background: string = 'lightblue';
}
</code></pre>
<p>Now the directive is painting its host element's background into light-blue.</p>
<p><img src="images/directives-input-03.png" alt="" /></p>
<p>This is how the rendered HTML looks like:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; class=&quot;click-area&quot; value=&quot;input value&quot; 
     style=&quot;background-color: rgb(173, 216, 230);&quot;&gt;
  Click me
&lt;/div&gt;
</code></pre>
<h4 id="binding-class-names"><a class="header" href="#binding-class-names">Binding Class Names</a></h4>
<p>Instead of binding single style attributes, you may want to operate CSS class names,
to be able providing external themes, or separating presentation layer from directive implementation.
It can be achieved by utilizing <code>@HostBinding('class.&lt;class-name&gt;')</code> where <code>&lt;class-name&gt;</code> is the name of the CSS class.</p>
<p>Note that having corresponding CSS class implementation is optional if you directive is not enforcing styles directly.
Developers can choose whether to implement or override the class, or leave defaults.</p>
<p>You can bind class names to the <code>boolean</code> values or expressions.
Angular appends provided CSS class name to the host element if the resulting value is <code>true</code>, and automatically removes it if value changes back to <code>false</code>.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...

export class ClickmeDirective {
    // ...

    @HostBinding('class.is-selected')
    isSelected: boolean = true;
}
</code></pre>
<p>This is the initial template we have been using:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div class=&quot;click-area&quot; appClickme&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>So this is how Angular renders component at run time.
Note the <code>class</code> value now has both <code>click-area</code> we defined manually, and <code>is-selected</code> class provided by the directive controller.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; class=&quot;click-area is-selected&quot; value=&quot;input value&quot; 
     style=&quot;background-color: rgb(173, 216, 230);&quot;&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>Typically you are going to apply or change CSS classes of the host element as a response to the host events wired by <code>HostBinding</code> decorators.</p>
<p>For example, the directive can listen to mouse events and toggle <code>hovered</code> styles:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...

export class ClickmeDirective { 
    // ...

    @HostBinding('class.is-hovered')
    isHovered: boolean = false;

    @HostListener('mouseenter')
    onMouseEnter() {
        this.isHovered = true;
        // other code if needed
    }

    @HostListener('mouseleave')
    onMouseLeave() {
        this.isHovered = false;
        // other code if needed
    }
}
</code></pre>
<p>Our directive toggles the <code>isHovered</code> property value upon mouse enter and leave,
but it does not directly change the way its host element looks.
Instead, you or developers that use your directive can optionally add a custom <code>is-hovered</code> CSS class
to alter how the element looks and behaves on mouse interaction.</p>
<p>The example below adds a thin dashed border to the element when a user hovers it:</p>
<pre><code class="language-css">/* src/app/app.component.css */

.is-hovered {
  border: 1px dashed darkblue;
}
</code></pre>
<p>You can now run the application and move the mouse cursor in and out of the click area.</p>
<p><img src="images/directives-hover-01.png" alt="" /></p>
<p>Of course, you can control hover styles in pure CSS.
The code above is more a simple demonstration of capabilities to give you more ideas
on what is possible with <code>HostListener</code> and <code>HostBinding</code> combined.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/directive-example">angular/directives/directive-example</a></strong> folder.</p>
</blockquote>
<h3 id="built-in-attribute-directives"><a class="header" href="#built-in-attribute-directives">Built-in Attribute Directives</a></h3>
<p>Angular comes with the following ready-to-use attribute directives:</p>
<ul>
<li><a href="ch08-02-attribute-directives.html#ngstyle">NgStyle</a>, updates an HTML element styles</li>
<li><a href="ch08-02-attribute-directives.html#ngclass">NgClass</a>, adds and removes CSS classes on an HTML element</li>
<li><strong>NgModel</strong>, provides two-way binding to Form elements, see <strong>Forms</strong> chapter for more details</li>
<li><a href="ch08-02-attribute-directives.html#ngnonbindable">NgNonBindable</a>, prevents content from being evaluated and compiled in templates</li>
</ul>
<h4 id="ngstyle"><a class="header" href="#ngstyle">NgStyle</a></h4>
<p>The <code>NgStyle</code> directive is used to modify CSS style attributes of the host element or component.</p>
<pre><code class="language-html">&lt;element [ngStyle]=&quot;OPTIONS&quot;&gt;
    ...
&lt;/element&gt;
</code></pre>
<p>Where <code>OPTIONS</code> is an object literal <code>NgStyle</code> that binds and maps properties to style attributes.
Object keys should represent style names with an optional <code>.&lt;unit&gt;</code> suffix, for example, <code>width.px</code>, <code>font-style.em</code>.</p>
<pre><code class="language-html">&lt;button [ngStyle]=&quot;{ 'border-width': '1px' }&quot;&gt;button 1&lt;/button&gt;
&lt;button [ngStyle]=&quot;{ 'border-width.px': '1' }&quot;&gt;button 2&lt;/button&gt;
&lt;button [ngStyle]=&quot;{
  'background-color': 'white',
  'border': '1px blue solid'
}&quot;&gt;button 3&lt;/button&gt;
</code></pre>
<p>You should see three buttons with custom styles once you run the application:</p>
<p><img src="images/directives-ngstyle-01.png" alt="" /></p>
<p>It is also possible to bind <code>ngStyle</code> to the component property.</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; value=&quot;hello world&quot; [ngStyle]=&quot;inputStyle&quot;&gt;
</code></pre>
<p>In this case, you declare object literal within the component class implementation, for example:</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...

export class AppComponent {
    // ...
    
    inputStyle = {
        'border': '1px green solid',
        'background-color': 'white',
        'color': 'blue'
    };
}
</code></pre>
<p>That allows you to compose styles based on some other conditions dynamically.</p>
<p><img src="images/directives-ngstyle-02.png" alt="Directives with NgStyle" /></p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/attribute-directives">angular/directives/attribute-directives</a></strong> folder.</p>
</blockquote>
<h4 id="ngclass"><a class="header" href="#ngclass">NgClass</a></h4>
<p>The <code>NgClass</code> directive allows binding CSS class names on an HTML element.</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;OPTIONS&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<p>Where the <code>OPTIONS</code> value can take one of the following formats:</p>
<ul>
<li>string expression (single or <code>space</code> delimited)</li>
<li>object literal</li>
<li>array</li>
</ul>
<h5 id="binding-to-string-expression-single"><a class="header" href="#binding-to-string-expression-single">Binding to String Expression (single)</a></h5>
<p>With this format you specify a string expression that corresponds to a CSS class name:</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;'class1'&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<h5 id="binding-to-string-expression-space-delimited"><a class="header" href="#binding-to-string-expression-space-delimited">Binding to String Expression (space delimited)</a></h5>
<p>You can also provide multiple class names per single <code>space</code> delimited string expression:</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;'class1 class2 class3'&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<h5 id="binding-to-object-literal"><a class="header" href="#binding-to-object-literal">Binding to Object Literal</a></h5>
<p>This format is very similar to that of <code>NgStyle</code> one.
All object keys are CSS class names and get added to host element only if value evaluates to a truthy value.
In a case of a non-truthy value, Angular removes class names from the host.</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;{
    'class1': true,
    'class2': false,
    'class3': true }&quot;&gt;
    &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<h5 id="binding-to-array"><a class="header" href="#binding-to-array">Binding to Array</a></h5>
<p>Finally you can bind the <code>NgClass</code> directive to an array of class names:</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;['class1', 'class2', 'class3']&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<p>In all the cases described above you can also bind directive options to underlying controller properties or methods:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;element [ngClass]=&quot;currentClass&quot;&gt;&lt;!-- ... --&gt;&lt;/element&gt;
&lt;element [ngClass]=&quot;getClassObj()&quot;&gt;&lt;!-- ... --&gt;&lt;/element&gt;
&lt;element [ngClass]=&quot;getClassArr()&quot;&gt;&lt;!-- ... --&gt;&lt;/element&gt;
</code></pre>
<pre><code class="language-ts">// src/app/app.component.ts

export class MyComponent {

    currentClass: string = 'class1';

    getClassObj(): any {
      return {
        'class2': true,
        'class3': true
      };
    }

    getClassArr(): string[] {
      return [
        'class4',
        'class5'
      ];
    }
}
</code></pre>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/attribute-directives">angular/directives/attribute-directives</a></strong> folder.</p>
</blockquote>
<h4 id="ngnonbindable"><a class="header" href="#ngnonbindable">NgNonBindable</a></h4>
<p>You use <code>NgNonBindable</code> directive to switch off Angular evaluating code or binding values for a particular element and its content.</p>
<p>For example if you want displaying source code:</p>
<pre><code class="language-html">&lt;h2&gt;NgNonBindable&lt;/h2&gt;
&lt;pre&gt;
  You can bind &lt;strong&gt;title&lt;/strong&gt; property like following:
  &lt;code ngNonBindable&gt;
    &amp;lt;div&amp;gt;{{title}}&amp;lt;/div&amp;gt;
  &lt;/code&gt;
&lt;/pre&gt;
</code></pre>
<p>Which renders to the following if you run the application:</p>
<p><img src="images/directives-non-bindable.png" alt="" /></p>
<p>Please note that the <code>NgNonBindable</code> is a very specific directive, and typically you are not going to use it often, if at all.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/attribute-directives">angular/directives/attribute-directives</a>&quot; folder.</p>
</blockquote>
<h2 id="structural-directives"><a class="header" href="#structural-directives">Structural Directives</a></h2>
<p>Structural directives allow you to control how element renders at run time.</p>
<h3 id="built-in-structural-directives"><a class="header" href="#built-in-structural-directives">Built-in structural directives</a></h3>
<p>Angular provides a few built-in directives you are going to use very often:</p>
<ul>
<li>NgIf</li>
<li>NgFor</li>
<li>NgSwitch</li>
</ul>
<h4 id="ngif"><a class="header" href="#ngif">NgIf</a></h4>
<p>You are going to use <code>NgIf</code> directive when you want to display or hide decorated element based on condition.</p>
<p>The most common usage format for this directive is</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;&lt;condition&gt;&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<p>where <code>&lt;condition&gt;</code> is a valid JavaScript expression.</p>
<p>Let's build an example demonstrating conditional inclusion of the template.
Add a boolean property <code>extraContent</code> to your <code>AppComponent</code> component controller class implementation:</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
  extraContent = false;
}
</code></pre>
<p>Next, put a <code>&lt;button&gt;</code> element to the component template, this button should toggle the <code>extraContent</code> value on each click.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;button (click)=&quot;extraContent = !extraContent&quot;&gt;
  Toggle extra content
&lt;/button&gt;
</code></pre>
<p>Finally, let's add some content that should be displayed only when <code>extraContent</code> property value gets set to <code>true</code></p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div *ngIf=&quot;extraContent&quot;&gt;
  &lt;h2&gt;Extra content comes here (ngIf)&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<p>Now if you run the application you should be able to toggle additional content by clicking the button multiple times.</p>
<p><img src="images/directives-ngif-01.png" alt="" /></p>
<p>Very often you may need two different templates within the component based on the condition evaluation.
Traditionally developers are using separate <code>NgIf</code> directives assigned to <code>truthy</code> and <code>falsy</code> results of the same expression:</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;condition&quot;&gt;main content&lt;/element&gt;
&lt;element *ngIf=&quot;!condition&quot;&gt;alternative content&lt;/element&gt;
</code></pre>
<p>The NgIf directive also supports <code>else</code> blocks for showing alternative content when the condition expression evaluates to a falsy value.
In this case, you need to provide a reference to a separate <code>ng-template</code>:</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;condition; else alternative&quot;&gt;
  Main template (condition is truthy)
&lt;/element&gt;

&lt;ng-template #alternative&gt;
  Alternative template (condition is falsy)
&lt;/ng-template&gt;
</code></pre>
<p>To see that on practice return to the project created earlier and add the additional template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ng-template #emptyView&gt;
  &lt;h3&gt;No extra content available&lt;/h3&gt;
&lt;/ng-template&gt;
</code></pre>
<p>Template above can be referenced by <code>emptyView</code> id.
Now update the main element to utilize the newly created template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div *ngIf=&quot;extraContent; else emptyView&quot;&gt;
  &lt;h2&gt;Extra content comes here (ngIf)&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<p>If you run the application right now and click the <code>Toggle extra content</code> button, you should see the content of the <code>emptyView</code> template.</p>
<p><img src="images/directives-ngif-02.png" alt="" /></p>
<p>It is possible to store both templates as external references.
By default, Angular treats inline template as a <code>then</code> block, but you can define it explicitly using the following syntax:</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;condition; then thenBlock else elseBlock&quot;&gt;&lt;/element&gt;
</code></pre>
<p>Now if updated our example can look like the following:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;button (click)=&quot;extraContent = !extraContent&quot;&gt;
  Toggle extra content
&lt;/button&gt;
&lt;div *ngIf=&quot;extraContent; then mainView else emptyView&quot;&gt;&lt;/div&gt;

&lt;ng-template #mainView&gt;
  &lt;h2&gt;Extra content comes here (ngIf)&lt;/h2&gt;
&lt;/ng-template&gt;

&lt;ng-template #emptyView&gt;
  &lt;h3&gt;No extra content available&lt;/h3&gt;
&lt;/ng-template&gt;
</code></pre>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/structural-directives">angular/directives/structural-directives</a></strong> folder.</p>
</blockquote>
<h4 id="ngfor"><a class="header" href="#ngfor">NgFor</a></h4>
<p>The main purpose of <code>NgFor</code> directive is to display iterable collections by utilizing a custom HTML template for each entry.</p>
<h5 id="binding-to-arrays"><a class="header" href="#binding-to-arrays">Binding to arrays</a></h5>
<p>Let's start with a simple example that best demonstrates <code>NgFor</code> directive in action.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let num of [1,2,3,4,5]&quot;&gt;
        &lt;span&gt;{{num}}&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>In the example above we are using <code>NgFor</code> directive with a collection of five numbers to render an unordered (bulleted) list.
Angular treats the content of the list item as a template and repeatedly applies to each array entry.</p>
<p>You should see the following HTML once application compiles and restarts:</p>
<p><img src="images/directives-ngfor-01.png" alt="" /></p>
<p>If you inspect the source code of the page you should see the structure similar to the one below:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;
        &lt;span&gt;1&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;2&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;3&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;4&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;5&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h5 id="binding-to-class-properties-or-functions"><a class="header" href="#binding-to-class-properties-or-functions">Binding to class properties or functions</a></h5>
<p>It is also possible to bind <code>NgFor</code> to class properties or functions.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
    // ...

    users = [
        {
            id: 10,
            firstName: 'John',
            lastName: 'Doe'
        },
        {
            id: 20,
            firstName: 'Joan',
            lastName: 'Doe'
        }
    ];
}
</code></pre>
<p>We are going to have two objects in the <code>users</code> collection.
The list entry template should now look like the next one:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users&quot;&gt;
        &lt;div&gt;{{user.firstName + ' ' + user.lastName}}&lt;/div&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Once your project and compiled and reloaded you should see a list of full user names:</p>
<p><img src="images/directives-ngfor-02.png" alt="" /></p>
<h5 id="using-exported-variables"><a class="header" href="#using-exported-variables">Using exported variables</a></h5>
<p>The <code>NgFor</code>directives exports several values that you can map to the the local template variables:</p>
<ul>
<li><code>index: number</code> holds the numeric position of the current array item</li>
<li><code>first: boolean</code> indicates whether the current array item is the first one</li>
<li><code>last: boolean</code> indicates whether the current array item is the last one</li>
<li><code>even: boolean</code> indicates whether current array item's position index is even</li>
<li><code>odd: boolean</code> indicates whether current array item's position index is odd</li>
</ul>
<p>You can use these additional values to improve the user interface.
For example, let's add row numbers to the user list:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users; let i = index&quot;&gt;
        &lt;div&gt;
            &lt;span&gt;{{i + 1}}: &lt;/span&gt;
            &lt;span&gt;{{user.firstName + ' ' + user.lastName}}&lt;/span&gt;
        &lt;/div&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Note the use of <code>let i = index</code>, this is where you bind <code>index</code> property to a local template variable <code>i</code>.
That allows you displaying it via <code>&lt;span&gt;{{i + 1}}: &lt;/span&gt;</code></p>
<p><img src="images/directives-ngfor-03.png" alt="" /></p>
<p>You can use all local variables for conditional styling and layout.
For example, you may want drawing a table or a list with stripes based on <code>even</code> and <code>odd</code> value,
rendering some header or footer for the <code>first</code> and <code>last</code> items.</p>
<p>It is possible to use all variables at the same time separating them by semicolons:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users; let isFirst = first; let isLast = last;&quot;&gt;
        &lt;span&gt;{{user.firstName + ' ' + user.lastName}}&lt;/span&gt;
        &lt;span *ngIf=&quot;isFirst&quot;&gt;(this is the first item)&lt;/span&gt;
        &lt;span *ngIf=&quot;isLast&quot;&gt;(this is the last item)&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>When running the application, you should notice that first and last items in the list get different text appended to them based on the condition expression.</p>
<p><img src="images/directives-ngfor-04.png" alt="" /></p>
<h5 id="improving-performance-with-trackby"><a class="header" href="#improving-performance-with-trackby">Improving performance with <code>trackBy</code></a></h5>
<p>Every time a collection changes Angular drops existing DOM elements and the renders entire set of new ones.
That is fine when you are dealing with static collections.
However, you may see significant performance drops when using frequently changed arrays,
for example when using dynamic editing or populating collections from the server.
The complexity of item templates can also slow down rendering and affect overall application performance.</p>
<p>Angular provides a special <code>trackBy</code> feature that allows you to track underlying objects by unique <code>id</code> values
and to rebuild DOM elements only for the entries that change.
For many scenarios that often ends up with a huge performance boosts as large portions of the DOM remain unchanged.</p>
<p>The <code>trackBy</code> value should go after the main <code>ngFor</code> expression and must be separated by a semicolon:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users; trackBy: trackByUserId&quot;&gt;
        &lt;span&gt;{{user.firstName + ' ' + user.lastName}}&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The <code>trackBy</code> always binds to a component method having a numeric <code>index</code> and a current collection object as parameters:</p>
<pre><code class="language-ts">// src/app/app.component.ts

trackByUserId(index: number, user: any) {
  return user.id;
}
</code></pre>
<p>In the example above we tell Angular to keep track of users in the list based on the <code>id</code> property value
so that it can better detect what item has been added or removed.</p>
<h4 id="ngswitch"><a class="header" href="#ngswitch">NgSwitch</a></h4>
<p>The <code>NgSwitch</code> directive is used for conditional rendering of element templates depending on the expression value.
You can treat it as an advanced <code>NgIf</code> directive with multiple <code>else</code> clauses.</p>
<p>You need three separate directives to make <code>NgSwitch</code> work:</p>
<ul>
<li><code>NgSwitch</code>: an attribute directive holding main expression body</li>
<li><code>NgSwitchCase</code>: a structural directive, renders corresponding template if its condition matches that of the <code>NgSwitch</code> one</li>
<li><code>NgSwitchDefault</code>: a structural directive, works like a fallback mechanism and renders a template if none of the <code>NgSwitchCase</code> values matches the <code>NgSwitch</code> one</li>
</ul>
<p>Here's the basic example of the <code>NgSwitch</code> format:</p>
<pre><code class="language-html">&lt;element [ngSwitch]=&quot;expression&quot;&gt;
    &lt;element *ngSwitchCase=&quot;condition1&quot;&gt;...&lt;/element&gt;
    &lt;element *ngSwitchCase=&quot;condition2&quot;&gt;...&lt;/element&gt;
    &lt;element *ngSwitchDefault&gt;...&lt;/element&gt;
&lt;/element&gt;
</code></pre>
<p>To check how <code>NgSwitch</code> operates in practice let's build a simple component that displays different UI layouts based on the selected role of the user.
Open the <code>app.component.ts</code> and add the <code>roles</code> and <code>selectedRole</code> properties like below:</p>
<pre><code class="language-ts">// src/app/app.component.ts

roles = [
    { id: 0, name: 'empty' },
    { id: 1, name: 'unknown' },
    { id: 2, name: 'user' },
    { id: 3, name: 'guest' },
    { id: 4, name: 'administrator' }
];

selectedRole = 'empty';
</code></pre>
<p>Next place a <code>&lt;select&gt;</code> element to be able to select a role from the dropdown list:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;select [(ngModel)]=&quot;selectedRole&quot;&gt;
    &lt;option *ngFor=&quot;let role of roles&quot;&gt;{{role.name}}&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>Finally we are going to build our simple role template selector:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div [ngSwitch]=&quot;selectedRole&quot;&gt;

    &lt;div *ngSwitchCase=&quot;'administrator'&quot;&gt;
        Special layout for the &lt;strong&gt;administrator&lt;/strong&gt; role
    &lt;/div&gt;

    &lt;div *ngSwitchCase=&quot;'guest'&quot;&gt;
        Special layout for the &lt;strong&gt;guest&lt;/strong&gt; role
    &lt;/div&gt;

    &lt;div *ngSwitchDefault&gt;
        General UI for the roles
    &lt;/div&gt;

&lt;/div&gt;
</code></pre>
<p>As a result, we are going to use dedicated UI templates for <code>administrator</code> and <code>guest</code> roles:</p>
<p><img src="images/directives-ngswitch-01.png" alt="" /></p>
<p>The rest of the roles should receive a generic template.</p>
<p><img src="images/directives-ngswitch-02.png" alt="" /></p>
<p>As you can see from the examples above, the <code>NgSwitch</code> directive is a powerful and flexible way for conditional element rendering in Angular.</p>
<h3 id="creating-a-structural-directive"><a class="header" href="#creating-a-structural-directive">Creating a Structural Directive</a></h3>
<p>Let's create a simple structural directive called <code>RepeatDirective</code> that is going to repeat specified HTML template certain number of times.
You can use Angular CLI to generate a working directive skeleton quickly.</p>
<pre><code class="language-sh">ng g directive repeat
</code></pre>
<p>The command above gives you a basic <code>RepeatDirective</code> implementation and a simple unit test.
It also modifies the main application module <code>app.module.ts</code> to register new directive within module declarations.</p>
<pre><code class="language-text">installing directive
  create src/app/repeat.directive.spec.ts
  create src/app/repeat.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>Here's the content of the <code>repeat.directive.ts</code> we are going to work with:</p>
<pre><code class="language-ts">// src/app/repeat.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appRepeat]'
})
export class RangeDirective {

  constructor() { }

}
</code></pre>
<p>Note that Angular CLI automatically prepends default <code>app</code> prefix to the directive selector value.
This helps us to avoid name conflicts with the existing directives from either standard Angular or third party libraries.</p>
<p>You can use your new directive with any HTML element like the following:</p>
<pre><code class="language-html">&lt;element *appRepeat&gt;...&lt;/element&gt;
</code></pre>
<p>It is also possible to use the plain format without Angular syntactic sugar:</p>
<pre><code class="language-html">&lt;ng-template [appRepeat]&gt;&lt;!--...--&gt;&lt;/ng-template&gt;
</code></pre>
<p>Now let's update our directive to repeat the content.</p>
<pre><code class="language-ts">// src/app/repeat.directive.ts

import { Directive, TemplateRef, ViewContainerRef, Input } from '@angular/core';

@Directive({
  selector: '[appRepeat]'
})
export class RepeatDirective {

  constructor(private templateRef: TemplateRef&lt;any&gt;,
              private viewContainer: ViewContainerRef) { }

  @Input()
  set appRepeat(times: number) {
    for (let i = 0; i &lt; times; i++) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    }
  }

}
</code></pre>
<p>First of all, you get access to the underlying template by injecting <code>TemplateRef</code> instance and using it as a local reference.
You also save a reference to the <code>ViewContainerRef</code> instance as you need it to turn the template reference to a real HTML element.</p>
<p>As a second step, we define an <code>appRepeat</code> setter that is going to receive configuration settings from the directive value.
Note that to map an attribute value to a function parameter the directive setter must have the same name as the HTML selector value.
In our case, it is <code>appRepeat</code> one. That gives you the possibility using the <code>*directive=&quot;expression&quot;</code> format similar to the one below:</p>
<pre><code class="language-html">&lt;element *appRepeat=&quot;5&quot;&gt;...&lt;/element&gt;
</code></pre>
<p>The child content of the decorated element gets treated as a template. 
With the help of <code>ViewContainer</code> and <code>Template</code> references we turn it into the HTML DOM multiple times:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; times; i++) {
  this.viewContainer.createEmbeddedView(this.templateRef);
}
</code></pre>
<p>You can test the directive with the following layout:</p>
<pre><code class="language-html">&lt;div *appRepeat=&quot;5&quot;&gt;
    &lt;div&gt;Hello&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>It is going to render the following output once the application runs:</p>
<pre><code class="language-html">Hello
Hello
Hello
Hello
Hello
</code></pre>
<p>The <code>Hello</code> template is rendered 5 times as we expect it.
However, rendering HTML elements without data context is not very useful.
Let's extend our directive with a custom context set to the position index of the element:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; times; i++) {
  this.viewContainer.createEmbeddedView(this.templateRef, {
    $implicit: i
  });
}
</code></pre>
<p>Now you can define a local variable for your template bound to the data context:</p>
<pre><code class="language-html">&lt;div *appRepeat=&quot;5; let idx&quot;&gt;
  &lt;div&gt;Hello {{idx}}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>You can also change example able to be like the next one:</p>
<pre><code class="language-html">&lt;ng-template [appRepeat]=&quot;5&quot; let-idx&gt;
  &lt;div&gt;Hello {{idx}}&lt;/div&gt;
&lt;/ng-template&gt;
</code></pre>
<p>This time the application output when using any of these formats is going to be as following:</p>
<pre><code class="language-html">Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
</code></pre>
<p>Let's get back to the data context again. Any local variable that has no value defined is going to point to the default <code>$implicit</code> value.
You can define as many variables as needed within your directive implementation.
For example, try to expose <code>first</code> and <code>last</code> variables similar to those of the <code>NgFor</code> directive:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; times; i++) {
    this.viewContainer.createEmbeddedView(this.templateRef, {
        $implicit: i,
        first: i === 0,
        last: i === times - 1
    });
}
</code></pre>
<p>Next you can wire newly created local variables and reuse them within the template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div *appRepeat=&quot;5; let idx; let isFirst = first; let isLast = last;&quot;&gt;
    &lt;div&gt;
      Hello {{idx}}
      &lt;span *ngIf=&quot;isFirst&quot;&gt;(first)&lt;/span&gt;
      &lt;span *ngIf=&quot;isLast&quot;&gt;(last)&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Once the application compiles and runs you should see the following result:</p>
<pre><code class="language-html">Hello 0 (first)
Hello 1
Hello 2
Hello 3
Hello 4 (last)
</code></pre>
<p>You can keep enhancing your directive with more complex layout and behavior.</p>
<h2 id="modifying-host-element-layout"><a class="header" href="#modifying-host-element-layout">Modifying Host Element Layout</a></h2>
<p>Directives can extend or modify host element layout at run time.
Let's create an <code>AttachDirective</code> directive that invokes an open file dialogue, once the user clicks the host element.</p>
<p>Due to security reasons, modern browsers do not allow invoking file dialogues from code,
unless caused by a user action, like clicking a button or hyperlink.
Traditionally developers use a hidden <code>&lt;input type=&quot;file&quot;&gt;</code> element to trigger its native behavior programmatically.
So as part of its implementation, our directive is going to create an additional <code>&lt;input&gt;</code> element and interact with it from code.</p>
<p>Using Angular CLI create a new project to develop and test the directive.</p>
<pre><code class="language-sh">ng new app-attach-directive
cd app-attach-directive/
ng g directive attach
</code></pre>
<p>The commands above result in a new <code>app-attach-directive</code> project containing <code>attach.directive.ts</code>
and <code>attach.directive.spec.ts</code> in the <code>src/app</code> folder.
You can see the content of the new <code>AttachDirective</code> below:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appAttach]'
})
export class AttachDirective {

  constructor() { }

}
</code></pre>
<p>Angular CLI automatically prepended the name with the default <code>app</code> prefix to avoid naming conflicts,
so you are going to use <code>appAttach</code> in HTML.</p>
<p>Before implementing the directive let's prepare the testing environment.
We are going to use main application component to see all the changes in action.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
  title = 'Attach directive';
}
</code></pre>
<p>Add the following block to the application component's template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appAttach class=&quot;attach-area&quot;&gt;
    &lt;div&gt;
        Click me to upload files
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>For demonstration and testing purposes we also provide some basic styling via <code>attach-area</code> CSS class.
The light blue box on the page shows the 'clickable' area wired with the <code>appAttach</code> directive.</p>
<pre><code class="language-css">/* src/app/app.component.css */

.attach-area {
  width: 200px;
  height: 50px;
  background-color: lightblue;
  cursor: pointer;
}
</code></pre>
<p>Now you can run the app with</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>The application compiles and runs inside your default browser.</p>
<p><img src="images/app-attach-directive-01.png" alt="" /></p>
<p>You can leave the terminal running in the background.
Angular CLI keeps watching for files and automatically recompiles and reloads application upon any changes.</p>
<p>Now provide the initial directive implementation like the following:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

import { Directive, OnInit, ElementRef, Renderer, HostListener } from '@angular/core';

@Directive({
  selector: '[appAttach]'
})
export class AttachDirective implements OnInit {
    private upload: HTMLInputElement;

    constructor(
        private el: ElementRef, 
        private renderer: Renderer) {
    }

    ngOnInit(): void {
        this.upload = this.renderer.createElement(
            this.el.nativeElement.parentNode, 'input') 
            as HTMLInputElement;

        this.upload.type = 'file';
        this.upload.style.display = 'none';
    }
}
</code></pre>
<p>First of all, you reserve a private property <code>upload</code> to store reference on the original <code>&lt;input&gt;</code> element.
The directive also needs a reference to its host element and an instance of the <code>Renderer</code> class, to modify HTML layout.
We inject both in the constructor and store as private properties <code>el</code> and <code>renderer</code>.</p>
<p>Once directive gets initialized it creates a new hidden <code>&lt;input type=&quot;file&quot;&gt;</code> HTML element next to the host one.
You can invoke its methods from the code, for example, a <code>click</code> event that causes a file dialogue to appear.
Let's listen to the host's <code>click</code> event and redirect it to the hidden input element like below:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

@HostListener('click', ['$event'])
onClick(event: Event) {
    if (this.upload) {
        event.preventDefault();
        this.upload.click();
    }
}
</code></pre>
<p>Once the user selects a file in the dialogue, our directive should know about that.
We can achieve that by listening to the <code>change</code> event of the input element and accessing the file list as soon as the event occur.</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

ngOnInit(): void {
    // ...
    this.upload.addEventListener('change', e =&gt; this.onAttachFiles(e));
}

private onAttachFiles(e: Event): void {
    const input = (&lt;HTMLInputElement&gt;e.currentTarget);
    const files = this.getFiles(input.files);
    this.raiseEvent(files);
}
</code></pre>
<p>Inside the handler, you extract the list of File objects from the event using the <code>getFiles</code> method with the following implementation:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

private getFiles(fileList: FileList): File[] {
    const result: File[] = [];

    if (fileList &amp;&amp; fileList.length &gt; 0) {
        for (let i = 0; i &lt; fileList.length; i++) {
            result.push(fileList[i]);
        }
    }
    
    return result;
}
</code></pre>
<p>Typically you may want to create an array of Model classes based on the File instances, or wrapping files into some other components.
For the sake of simplicity let's just return File objects as they are.</p>
<p>There can be multiple approaches to handling file uploads.
The directive might be doing all the upload work itself, it could be triggering some application service,
or it can raise DOM events for other components react on them.
We are going to take the latter approach and raise a custom <code>attach-files</code> event.</p>
<p>The <code>raiseEvent</code> method receives an array of <code>File</code> instances and raises <code>attach-files</code> event like below:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

private raiseEvent(files: File[]): void {
    if (files.length &gt; 0) {
        const event = new CustomEvent('attach-files', {
            detail: {
                sender: this,
                files: files
            },
            bubbles: true
        });

        this.el.nativeElement.dispatchEvent(event);
    }
}
</code></pre>
<p>You can now handle this custom event from either host element or any other HTML element up against the parent hierarchy.
Let's create a list of files the user attaches using our directive.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div class=&quot;attach-area&quot; appAttach 
    (attach-files)=&quot;onAttachFiles($event)&quot;&gt;
    &lt;div&gt;
        Click me to upload files
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;Files attached&lt;/h3&gt;
&lt;ul&gt;
    &lt;li *ngFor=&quot;let file of files&quot;&gt;
        {{file.name}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>As you can see from the layout above, we wire <code>attach-files</code> event with the <code>onAttachFiles</code>
method of main application component class and are going to store attached files in the <code>files</code> collection.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
    title = 'Attach directive';

    files: File[];

    onAttachFiles(e: CustomEvent) {
        this.files = e.detail.files || [];
    }
}
</code></pre>
<p>Once application recompiles and reloads you can to test new behavior by attaching a file to see its name appear in the list:</p>
<p><img src="images/app-attach-directive-02.png" alt="" /></p>
<p>Another feature you may want to add to the directive is the ability to toggle single and multiple file selection support.
The standard <code>&lt;input type=&quot;file&quot;&gt;</code> element allows this via the <code>multiple</code> HTML attribute.</p>
<p>We can introduce the same property for the directive and propagate its value to the enclosed <code>upload</code> element like this:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts
// ...

export class AttachDirective implements OnInit {
    // ...

    @Input()
    multiple: boolean;

    ngOnInit(): void {
        // ...
        
        if (this.multiple) {
            this.upload.setAttribute('multiple', '');
        }
    }
}
</code></pre>
<p>That allows us binding to or setting <code>[multiple]</code> property value on an HTML element alongside <code>appAttach</code> directive.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div class=&quot;attach-area&quot; appAttach [multiple]=&quot;true&quot; 
    (attach-files)=&quot;onAttachFiles($event)&quot;&gt;
    &lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<p>Now if you run the application you should be able to select multiple files in the file dialogue.
The list at the bottom should display names for all of them.</p>
<p><img src="images/app-attach-directive-03.png" alt="" /></p>
<p>So we got a directive that attaches to an HTML element, alters its behavior
and even redirects user events to an additional hidden content.
You can keep extending the implementation if needed, for example adding new properties,
or controlling the types of files to be selected.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/app-attach-directive">angular/directives/app-attach-directive</a></strong> folder.</p>
</blockquote>
<h2 id="walkthrough-upload-directive"><a class="header" href="#walkthrough-upload-directive">Walkthrough: Upload Directive</a></h2>
<p>In this walkthrough, we are going to create a directive that turns its host element into a drop target for files.</p>
<p>Our directive itself does not upload files to a server, but instead,
it is going to be responsible for detecting dropped Files and raising special DOM events.
Other parts of the application (components, directives, services) can then react on those events
and perform additional actions if needed.</p>
<p>Let's start by generating a new application and calling it <code>app-upload-directive</code>:</p>
<pre><code class="language-sh">ng new app-upload-directive
cd app-upload-directive/
</code></pre>
<p>You can test application was created successfully by running it with the default browser:</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>Now let's create an <code>upload</code> directive from the Angular CLI blueprint:</p>
<pre><code class="language-sh">ng g directive directives/upload
</code></pre>
<p>The <code>ng</code> tool should put the code and unit tests into the <code>src/app/directives</code> folder,
and should also update main application module.</p>
<pre><code class="language-text">installing directive
  create src/app/directives/upload.directive.spec.ts
  create src/app/directives/upload.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>Angular CLI generates the following code for the new directive:</p>
<pre><code class="language-ts">// upload.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appUpload]'
})
export class UploadDirective {

  constructor() { }

}
</code></pre>
<p>All application and directive tests should be working properly</p>
<pre><code class="language-sh">ng test
</code></pre>
<p>There should be an additional test for UploadDirective class: <code>should create an instance</code>.
This test is a good starting point for unit testing your future directive.</p>
<p><img src="images/upload-directive-initial-test.png" alt="Initial Test" /></p>
<p>We are going to decorate a simple <code>&lt;div&gt;</code> element and turn it into a file drop area.</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;div class=&quot;my-drop-area&quot;&gt;
  &lt;span&gt;Drop your files here...&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>As it is a <code>&lt;div&gt;</code> element let's add some style to be able distinguishing it.
Setting fixed size and background colour should be more than enough for now.</p>
<pre><code class="language-css">/* app.component.css */

.my-drop-area {
  width: 150px;
  height: 50px;
  background-color: lightgray;
}
</code></pre>
<p>The main application page now should look like the following:</p>
<p><img src="images/upload-directive-drop-area.png" alt="Drag and Drop Area" /></p>
<pre><code class="language-ts">// upload.directive.ts

import { /*...,*/ HostBinding, HostListener } from '@angular/core';

export class UploadDirective {

    @HostBinding('class.app-upload__dragover')
    isDragOver: boolean;    

}
</code></pre>
<p>Every time <code>isDragOver</code> becomes <code>true</code> the host element gets a CSS class <code>app-upload__dragover</code> applied to it.
Once it is set back to <code>false</code> the CSS class is automatically removed.</p>
<p>Now add the following code to the directive implementation:</p>
<pre><code class="language-ts">// upload.directive.ts

@HostListener('dragenter')
onDragEnter() {
  this.isDragOver = true;
}

@HostListener('dragover', ['$event'])
onDragOver(event: Event) {
  if (event) {
    event.preventDefault();
  }
  this.isDragOver = true;
}

@HostListener('dragleave')
onDragLeave() {
  this.isDragOver = false;
}
</code></pre>
<p>The code above performs a simple drag management to update <code>isDragOver</code> state and so host element style.
For <code>dragenter</code> and <code>dragover</code> events we are going to enable additional styles, and disable on <code>dragleave</code>.</p>
<p>In order to turn host element into a drop zone you also need handling <code>drop</code> event:</p>
<pre><code class="language-ts">// upload.directive.ts

@HostListener('drop', ['$event'])
onDrop(event: DragEvent) {
  event.preventDefault();
  event.stopPropagation();
  this.isDragOver = false;
}
</code></pre>
<p>Keep in mind that directive only adds <code>app-upload__dragover</code> class to the host element,
it does not modify element's style attributes directly.
Developers that are using your directive should be able to define look and feel of the decorated element at the application level.</p>
<p>Traditionally file drop areas use dashed borders when being dragged over,
let's make our element draw a thin blue border and also change background colour:</p>
<pre><code class="language-css">/* app.component.css */

.app-upload__dragover {
  border: 1px dashed blue;
  background-color: white;
}
</code></pre>
<p>And you need decorating <code>div</code> element with the directive to see it in action:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;div class=&quot;my-drop-area&quot; appUpload&gt;
  &lt;span&gt;Drop your files here...&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>The element should be changing the style when you drag a file over its area:</p>
<p><img src="images/upload-directive-drag-over.png" alt="Drag Over" /></p>
<p>Now that we have <code>drag</code> events wired with element styles, it is time to implement <code>drop</code> handling.
Find the <code>onDrop</code> method we have introduced earlier and replace with the following code:</p>
<pre><code class="language-ts">// upload.directive.ts

@HostListener('drop', ['$event'])
onDrop(event: DragEvent) {
  event.preventDefault();
  event.stopPropagation();
  this.isDragOver = false;

  const files = this.collectFiles(event.dataTransfer);
  console.log(files);
  this.onFilesDropped(files);
}
</code></pre>
<p>Once user drops files on the host element, the directive is going extract information on files from the DataTransfer instance (<code>collectFiles</code>),
and pass discovered files to the <code>onFilesDropped</code> method to raise corresponding DOM events.</p>
<blockquote>
<p><strong>DataTransfer</strong></p>
<p>The DataTransfer object is used to hold the data that is being dragged during a drag and drop operation.
It may hold one or more data items, each of one or more data types.</p>
<p>For more information see <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer">DataTransfer</a> article.</p>
</blockquote>
<p>Essentially we need to extract <code>File</code> objects into a separate collection in a safe manner:</p>
<pre><code class="language-ts">// upload.directive.ts

private collectFiles(dataTransfer: DataTransfer): File[] {
    const result: File[] = [];

    if (dataTransfer) {
      const items: FileList = dataTransfer.files;

      if (items &amp;&amp; items.length &gt; 0) {
        for (let i = 0; i &lt; items.length; i++) {
          result.push(items[i]);
        }
      }
    }

    return result;
}
</code></pre>
<p>Finally, we need to raise an <code>upload-files</code> event to allow other components handling it.
We are going to create an instance of the <code>CustomEvent</code> for that purpose.</p>
<blockquote>
<p><strong>CustomEvent</strong></p>
<p>The CustomEvent interface represents events initialized by an application for any purpose.</p>
<p>For more information see <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">CustomEvent</a> article.</p>
</blockquote>
<p>The directive also needs access to the native DOM element of the host to raise a custom event,
so importing <code>ElementRef</code> instance for the constructor is required.
Reference to the native HTML element should be injected as a constructor parameter and used as private property <code>el</code>.</p>
<pre><code class="language-ts">// upload.directive.ts

import { /*...,*/ ElementRef } from '@angular/core';

export class UploadDirective {
    // ...

    constructor(private el: ElementRef) {}

    // ...
}
</code></pre>
<p>You need using <code>Element.dispatchEvent()</code> to raise the <code>upload-files</code> event.
As part of the <code>CustomEvent</code> interface, we can define custom <code>detail</code> value,
so that external event handlers can get additional information.</p>
<p>We are going to provide an object containing a list of files (<code>files</code>) the user has dropped on the host element,
and reference to the directive (<code>sender</code>) instance that raised the event.</p>
<pre><code class="language-ts">// upload.directive.ts
private onFilesDropped(files: File[]) {
    if (files &amp;&amp; files.length &gt; 0) {
        this.el.nativeElement.dispatchEvent(
            new CustomEvent('upload-files', {
                detail: {
                    sender: this,
                    files: files
                },
                bubbles: true
            })
        );
    }
}
</code></pre>
<p>Note the <code>bubbles</code> property being set to <code>true</code> to enable event bubbling.
It indicates whether the given event bubbles up through the DOM or not.
In our case we allow any HTML element up the visual tree handle this event or stop its propagation.</p>
<p>You can get more details on custom events in the article <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events">Creating and triggering events</a>.</p>
<p>Now it is time to handle <code>upload-files</code> event at the application level.
Open the <code>app.component.html</code> file and add <code>onUploadFiles</code> event handler like shown below:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;div class=&quot;my-drop-area&quot; appUpload (upload-files)=&quot;onUploadFiles($event)&quot;&gt;
  &lt;span&gt;Drop your files here...&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>Given that our event supports bubbling any element in the parent hierarchy can handle it.
You could also define the handler as following:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;div (upload-files)=&quot;onUploadFiles($event)&quot;&gt;
  &lt;div class=&quot;my-drop-area&quot; appUpload&gt;
    &lt;span&gt;Drop your files here...&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>To see the content of the event, we are going to put the <code>console.log</code> for now:</p>
<pre><code class="language-ts">// app.component.ts

onUploadFiles(event: CustomEvent) {
  console.log(event);
}
</code></pre>
<p>Now if you compile and run the web application, and drop one or multiple files on the drop are,
the console output should be similar to the following one:</p>
<p><img src="images/upload-directive-event.png" alt="" /></p>
<p>As you may see from the picture above, the handler is getting <code>CustomEvent</code> that holds <code>details</code> value
with a <code>File</code> collection, reference to the directive instance, and several standard properties.</p>
<p>Let's try adding some visualization and display a list of previously uploaded files on the main page.
Append the following HTML to the <code>app.component.html</code> file content:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;div&gt;
    &lt;h3&gt;Uploaded files:&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let file of uploadedFiles&quot;&gt;
        {{file}}
      &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>List element binds to the <code>uploadedFiles</code> collection holding uploaded file names.
The <code>upload-files</code> event handler just collects the file names and fills the collection.</p>
<pre><code class="language-ts">// app.component.ts

export class AppComponent {
    // ...
    uploadedFiles: string[] = [];

    onUploadFiles(event: CustomEvent) {
        console.log(event);
        const files: File[] = event.detail.files;
        if (files) {
            for (const file of files) {
                this.uploadedFiles.push(file.name);
            }
        }
    }
}
</code></pre>
<p>Now run your web application or switch to the browser if running the live development server,
and try dropping one or multiple files several times.
You should see file names appear in the list below the drop area like shown on the picture below:</p>
<p><img src="images/upload-directive-file-list.png" alt="" /></p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/app-upload-directive">angular/directives/app-upload-directive</a></strong> folder.</p>
</blockquote>
<p>When working on your Angular web application, you may want some other component or service handle the <code>upload-files</code> event
and perform actual uploading to a backend server, preferably by utilizing the injectable service.</p>
<p>It is always a good practice splitting functionality into small interchangeable building blocks, each doing one thing at a time.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-23X2CQXZ48', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
