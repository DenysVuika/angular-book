<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Angular Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Angular Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="ch01-02-vscode.html"><strong aria-hidden="true">1.2.</strong> Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-es6.html"><strong aria-hidden="true">2.</strong> ES6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-classes.html"><strong aria-hidden="true">2.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch02-02-inheritance.html"><strong aria-hidden="true">2.2.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="ch02-03-arrow-functions.html"><strong aria-hidden="true">2.3.</strong> Arrow Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-template-literals.html"><strong aria-hidden="true">2.4.</strong> Template Literals</a></li><li class="chapter-item expanded "><a href="ch02-05-extended-parameters.html"><strong aria-hidden="true">2.5.</strong> Extended Parameter Handling</a></li><li class="chapter-item expanded "><a href="ch02-06-destructuring.html"><strong aria-hidden="true">2.6.</strong> Destructuring Assignment</a></li><li class="chapter-item expanded "><a href="ch02-07-modules.html"><strong aria-hidden="true">2.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch02-08-see-also.html"><strong aria-hidden="true">2.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-typescript.html"><strong aria-hidden="true">3.</strong> TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch03-02-features.html"><strong aria-hidden="true">3.2.</strong> TypeScript Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-03-types.html"><strong aria-hidden="true">3.2.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="ch03-04-classes.html"><strong aria-hidden="true">3.2.2.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch03-05-interfaces.html"><strong aria-hidden="true">3.2.3.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch03-06-abstract-classes.html"><strong aria-hidden="true">3.2.4.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="ch03-07-modules.html"><strong aria-hidden="true">3.2.5.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch03-08-decorators.html"><strong aria-hidden="true">3.2.6.</strong> Decorators</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-angular-cli.html"><strong aria-hidden="true">4.</strong> Angular CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-installing.html"><strong aria-hidden="true">4.1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="ch04-02-first-application.html"><strong aria-hidden="true">4.2.</strong> Your First Application</a></li><li class="chapter-item expanded "><a href="ch04-03-running-application.html"><strong aria-hidden="true">4.3.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="ch04-04-linting.html"><strong aria-hidden="true">4.4.</strong> Code Linting</a></li><li class="chapter-item expanded "><a href="ch04-05-testing.html"><strong aria-hidden="true">4.5.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="ch04-06-coverage.html"><strong aria-hidden="true">4.6.</strong> Code Coverage</a></li><li class="chapter-item expanded "><a href="ch04-07-development-and-production-builds.html"><strong aria-hidden="true">4.7.</strong> Development and Production Builds</a></li><li class="chapter-item expanded "><a href="ch04-08-using-blueprints.html"><strong aria-hidden="true">4.8.</strong> Using Blueprints</a></li><li class="chapter-item expanded "><a href="ch04-09-creating-modules.html"><strong aria-hidden="true">4.9.</strong> Creating Modules</a></li><li class="chapter-item expanded "><a href="ch04-10-routing-support.html"><strong aria-hidden="true">4.10.</strong> Routing Support</a></li><li class="chapter-item expanded "><a href="ch04-11-generating-standalone-scripts.html"><strong aria-hidden="true">4.11.</strong> Generating Standalone Scripts</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-components.html"><strong aria-hidden="true">5.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-creating-a-simple-component.html"><strong aria-hidden="true">5.1.</strong> Creating a Simple Component</a></li><li class="chapter-item expanded "><a href="ch05-02-generating-components-with-angular-cli.html"><strong aria-hidden="true">5.2.</strong> Generating Components with Angular CLI</a></li><li class="chapter-item expanded "><a href="ch05-03-component-metadata.html"><strong aria-hidden="true">5.3.</strong> Component Metadata</a></li><li class="chapter-item expanded "><a href="ch05-04-templates.html"><strong aria-hidden="true">5.4.</strong> Templates</a></li><li class="chapter-item expanded "><a href="ch05-05-styles.html"><strong aria-hidden="true">5.5.</strong> Styles</a></li><li class="chapter-item expanded "><a href="ch05-06-input-properties.html"><strong aria-hidden="true">5.6.</strong> Input Properties</a></li><li class="chapter-item expanded "><a href="ch05-07-output-events.html"><strong aria-hidden="true">5.7.</strong> Output Events</a></li><li class="chapter-item expanded "><a href="ch05-08-providers.html"><strong aria-hidden="true">5.8.</strong> Providers</a></li><li class="chapter-item expanded "><a href="ch05-09-host.html"><strong aria-hidden="true">5.9.</strong> Host</a></li><li class="chapter-item expanded "><a href="ch05-10-queries.html"><strong aria-hidden="true">5.10.</strong> Queries</a></li><li class="chapter-item expanded "><a href="ch05-12-component-lifecycle.html"><strong aria-hidden="true">5.11.</strong> Component Lifecycle</a></li><li class="chapter-item expanded "><a href="ch05-13-content-projection.html"><strong aria-hidden="true">5.12.</strong> Content Projection</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-dependency-injection.html"><strong aria-hidden="true">6.</strong> Dependency Injection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-preparing-a-project.html"><strong aria-hidden="true">6.1.</strong> Preparing a Project</a></li><li class="chapter-item expanded "><a href="ch06-02-services.html"><strong aria-hidden="true">6.2.</strong> Services</a></li><li class="chapter-item expanded "><a href="ch06-03-providers.html"><strong aria-hidden="true">6.3.</strong> Providers</a></li><li class="chapter-item expanded "><a href="ch06-04-injection-tokens.html"><strong aria-hidden="true">6.4.</strong> Injection Tokens</a></li><li class="chapter-item expanded "><a href="ch06-05-injecting-multiple-instances.html"><strong aria-hidden="true">6.5.</strong> Injecting Multiple Instances</a></li><li class="chapter-item expanded "><a href="ch06-06-optional-dependencies.html"><strong aria-hidden="true">6.6.</strong> Optional Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-07-manual-injection.html"><strong aria-hidden="true">6.7.</strong> Manual Injection</a></li><li class="chapter-item expanded "><a href="ch06-08-summary.html"><strong aria-hidden="true">6.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-events.html"><strong aria-hidden="true">7.</strong> Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-component-events.html"><strong aria-hidden="true">7.1.</strong> Component Events</a></li><li class="chapter-item expanded "><a href="ch07-02-dom-events.html"><strong aria-hidden="true">7.2.</strong> DOM Events</a></li><li class="chapter-item expanded "><a href="ch07-03-service-events.html"><strong aria-hidden="true">7.3.</strong> Service Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-directives.html"><strong aria-hidden="true">8.</strong> Directives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-introduction-to-directives.html"><strong aria-hidden="true">8.1.</strong> Introduction to Directives</a></li><li class="chapter-item expanded "><a href="ch08-02-attribute-directives.html"><strong aria-hidden="true">8.2.</strong> Attribute Directives</a></li><li class="chapter-item expanded "><a href="ch08-03-structural-directives.html"><strong aria-hidden="true">8.3.</strong> Structural Directives</a></li><li class="chapter-item expanded "><a href="ch08-04-modifying-host-layout.html"><strong aria-hidden="true">8.4.</strong> Modifying Host Element Layout</a></li><li class="chapter-item expanded "><a href="ch08-05-walkthrough-upload-directive.html"><strong aria-hidden="true">8.5.</strong> Walkthrough: Upload Directive</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-pipes.html"><strong aria-hidden="true">9.</strong> Pipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-pipes-with-parameters.html"><strong aria-hidden="true">9.1.</strong> Pipes with Parameters</a></li><li class="chapter-item expanded "><a href="ch09-02-chaining-pipes.html"><strong aria-hidden="true">9.2.</strong> Chaining Pipes</a></li><li class="chapter-item expanded "><a href="ch09-03-built-in-pipes.html"><strong aria-hidden="true">9.3.</strong> Built-in Pipes</a></li><li class="chapter-item expanded "><a href="ch09-04-custom-pipes.html"><strong aria-hidden="true">9.4.</strong> Custom Pipes</a></li><li class="chapter-item expanded "><a href="ch09-05-pure-and-impure-pipes.html"><strong aria-hidden="true">9.5.</strong> Pure And Impure Pipes</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-global-application-configuration.html"><strong aria-hidden="true">10.</strong> Global Application Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-preparing-configuration-file.html"><strong aria-hidden="true">10.1.</strong> Preparing the Configuration File</a></li><li class="chapter-item expanded "><a href="ch10-02-creating-configuration-service.html"><strong aria-hidden="true">10.2.</strong> Creating the Configuration Service</a></li><li class="chapter-item expanded "><a href="ch10-03-loading-configuration-file.html"><strong aria-hidden="true">10.3.</strong> Loading Server-Side Configuration File</a></li><li class="chapter-item expanded "><a href="ch10-04-registering-configuration-service.html"><strong aria-hidden="true">10.4.</strong> Registering Configuration Service</a></li><li class="chapter-item expanded "><a href="ch10-05-using-configuration-settings.html"><strong aria-hidden="true">10.5.</strong> Using Configuration Settings</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-i18n.html"><strong aria-hidden="true">11.</strong> Internationalization (i18n)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-creating-translate-service.html"><strong aria-hidden="true">11.1.</strong> Creating Translate Service</a></li><li class="chapter-item expanded "><a href="ch11-02-creating-translate-pipe.html"><strong aria-hidden="true">11.2.</strong> Creating Translate Pipe</a></li><li class="chapter-item expanded "><a href="ch11-03-using-translate-pipe.html"><strong aria-hidden="true">11.3.</strong> Using Translate Pipe</a></li><li class="chapter-item expanded "><a href="ch11-04-switching-languages.html"><strong aria-hidden="true">11.4.</strong> Switching Languages</a></li><li class="chapter-item expanded "><a href="ch11-05-summary.html"><strong aria-hidden="true">11.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-reusable-component-libraries.html"><strong aria-hidden="true">12.</strong> Reusable Component Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-creating-new-application.html"><strong aria-hidden="true">12.1.</strong> Creating New Application</a></li><li class="chapter-item expanded "><a href="ch12-02-creating-component-libraries.html"><strong aria-hidden="true">12.2.</strong> Creating Component Libraries</a></li><li class="chapter-item expanded "><a href="ch12-03-building-the-packages.html"><strong aria-hidden="true">12.3.</strong> Building the Packages</a></li><li class="chapter-item expanded "><a href="ch12-04-publishing-to-npm.html"><strong aria-hidden="true">12.4.</strong> Publishing to NPM</a></li><li class="chapter-item expanded "><a href="ch12-05-see-also.html"><strong aria-hidden="true">12.5.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-dynamic-content.html"><strong aria-hidden="true">13.</strong> Dynamic Content</a></li><li class="chapter-item expanded "><a href="ch14-00-plugins.html"><strong aria-hidden="true">14.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="ch15-00-docker.html"><strong aria-hidden="true">15.</strong> Using with Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-preparing-new-project.html"><strong aria-hidden="true">15.1.</strong> Preparing New Project</a></li><li class="chapter-item expanded "><a href="ch15-02-creating-dockerfile.html"><strong aria-hidden="true">15.2.</strong> Creating Dockerfile</a></li><li class="chapter-item expanded "><a href="ch15-03-testing-in-a-container.html"><strong aria-hidden="true">15.3.</strong> Testing in a Container</a></li><li class="chapter-item expanded "><a href="ch15-04-docker-compose.html"><strong aria-hidden="true">15.4.</strong> Docker Compose</a></li><li class="chapter-item expanded "><a href="ch15-05-publishing-to-docker-hub.html"><strong aria-hidden="true">15.5.</strong> Publishing to Docker Hub</a></li><li class="chapter-item expanded "><a href="ch15-06-consuming-from-docker-hub.html"><strong aria-hidden="true">15.6.</strong> Consuming from Docker Hub</a></li><li class="chapter-item expanded "><a href="ch15-07-automating-with-travis.html"><strong aria-hidden="true">15.7.</strong> Automating with Travis</a></li><li class="chapter-item expanded "><a href="ch15-08-see-also.html"><strong aria-hidden="true">15.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Webpack</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">16.1.</strong> Initial project structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.2.</strong> Typescript configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.3.</strong> Basic webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.4.</strong> Advanced webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.5.</strong> Unit testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Building a Mobile App with Cordova and Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">17.1.</strong> Installing command-line tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.2.</strong> Generating a new Angular App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.3.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.4.</strong> Summary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Angular Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/DenysVuika/angular-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-angular-book"><a class="header" href="#the-angular-book">The Angular Book</a></h1>
<p><em>by Denys Vuika, with contributions from the Angular Community</em></p>
<p>This is the second and online edition of the <a href="https://leanpub.com/developing-with-angular">Developing with Angular</a> book.</p>
<blockquote>
<p>Note: this book is still in progress.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In the first few chapters, we are going to dwell on the basics you may need to understand Angular development better later on.</p>
<p>We are going to start with the main ES6 (ECMAScript 2015) features you should come across frequently when using TypeScript.</p>
<p>Next, the most remarkable TypeScript features you should get familiar before starting the Angular development.</p>
<p>After that, we are covering the Angular framework and supplemental toolings, like Angular CLI (Command Line Interface) and Webpack.</p>
<p>Finally, you should expect many practical topics that are addressing specific application requirements and scenarios,
including those coming from the community requests.</p>
<h2 id="book-progress"><a class="header" href="#book-progress">Book progress</a></h2>
<p>You can see the progress of the writing on this <a href="https://github.com/DenysVuika/angular-book/projects/1">GitHub board</a>.
Be sure to check the board if you want to see what's coming next or what is in progress right now.</p>
<h2 id="code-examples"><a class="header" href="#code-examples">Code examples</a></h2>
<p>You can find all code examples in this GitHub repository: <a href="https://github.com/DenysVuika/angular-book">angular-book</a>.
The source code gets frequently revisited and updated.</p>
<h2 id="feedback-bug-reports-and-suggestions"><a class="header" href="#feedback-bug-reports-and-suggestions">Feedback, Bug Reports and Suggestions</a></h2>
<p>If you have noticed a typo in the text or a bug in the code examples,
please don't hesitate and contact me using the next email address:
<a href="mailto:denys.vuika@gmail.com?subject=angular-book%20feedback">denys.vuika@gmail.com</a></p>
<p>You are also invited to raise issues for the source code and examples using corresponding <a href="https://github.com/DenysVuika/angular-book/issues">issue tracker</a> at GitHub.</p>
<p>Feel free to raise feature requests and suggestions on what you would like to see next.</p>
<h2 id="other-publications"><a class="header" href="#other-publications">Other publications</a></h2>
<p>You can find many other interesting publications at my <a href="https://denys.dev/">Blog</a>.</p>
<h2 id="testimonials"><a class="header" href="#testimonials">Testimonials</a></h2>
<p>Your feedback on the book content is very appreciated.
I would love to publish your photo and testimonial on the web page of the book.
Email me at: <a href="mailto:denys.vuika@gmail.com?subject=angular-book%20testimonial">denys.vuika@gmail.com</a>.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>In this chapter, we are going to configure the following applications and libraries:</p>
<ul>
<li>Node.js</li>
<li>Visual Studio Code</li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<p>Node.js is a JavaScript runtime built on <a href="https://developers.google.com/v8/">Chrome's V8 JavaScript engine</a>.
Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
Node.js' package ecosystem, <a href="https://www.npmjs.com/">npm</a>, is the largest ecosystem of open source libraries in the world.</p>
<p>Navigate to the <a href="https://nodejs.org/en/">main page</a>, download installer for your platform and follow setup instructions.</p>
<p>You can use the following commands to test current versions of the Node and NPM on your machine:</p>
<pre><code class="language-sh">node -v
# v14.16.0

npm -v
# 6.14.11
</code></pre>
<p>Please note that the actual versions may differ.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS.
It includes support for debugging, embedded Git control, syntax highlighting,
intelligent code completion, snippets, and code refactoring.</p>
<p><img src="images/vscode-mac-lg-2x.png" alt="vs code" /></p>
<h3 id="recommended-extensions"><a class="header" href="#recommended-extensions">Recommended extensions</a></h3>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint">TSLint</a></strong></p>
<p>Integrates the tslint linter for the TypeScript language into VS Code.</p>
<p>Launch VS Code Quick Open (âŒ˜+P), paste the following command, and press enter.</p>
<pre><code class="language-sh">ext install tslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></strong></p>
<p>Integrates ESLint into VS Code. See <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">project page</a> for more details.</p>
<pre><code class="language-sh">ext install vscode-eslint
</code></pre>
<p><strong><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig</a></strong></p>
<p>EditorConfig Support for Visual Studio Code</p>
<pre><code class="language-sh">ext install EditorConfig
</code></pre>
<h3 id="hiding-files"><a class="header" href="#hiding-files">Hiding files</a></h3>
<p>This step is optional.
In the code go to the <code>Preferences</code> -&gt; <code>Workspace Settings</code> and paste the following settings into the opened file:</p>
<pre><code class="language-json">{
    &quot;files.exclude&quot;: {
        &quot;**/.git&quot;: true,
        &quot;**/.DS_Store&quot;: true
    }
}
</code></pre>
<p>You can extend the list with the files, extensions or directories based on your preferences.</p>
<h1 id="es6"><a class="header" href="#es6">ES6</a></h1>
<p>ECMAScript 2015 (also known as ES6 and often referred to as <code>Harmony</code>) is the 6th major release of the ECMAScript language specification.</p>
<p>I am going to cover the most important features here to get you started with ES6 and then be able moving to TypeScript and Angular faster.</p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>The <code>class</code> syntax in JavaScript is not a new object-oriented inheritance model
but simply a syntactical sugar on top of the existing prototype-based inheritance.</p>
<p>Traditionally we have been using standard Objects and Prototypes like shown below:</p>
<pre><code class="language-js">var Widget = function(id, x, y) {
    this.id = id;
    this.setPosition(x, y);
}
Widget.prototype.setPosition = function(x, y) {
    this.x = x;
    this.y = y;
}
</code></pre>
<p>With class syntax developers get more natural and boilerplate-free result:</p>
<pre><code class="language-js">class Widget {
    constructor(id, x, y) {
        this.id = id;
        this.setPosition(x, y);
    }

    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
<p>The <code>constructor</code> function is automatically called when you create a new instance of <code>Widget</code>:</p>
<pre><code class="language-js">const myWidget = new Widget(1, 10, 20);
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>The <code>extends</code> keyword is used to define a class as a child of another class.
The following example demonstrates inheritance in practice:</p>
<pre><code class="language-js">class TextBox extends Widget {
    constructor (id, x, y, text) {
        super(id, x, y);
        this.text = text;
    }
}
</code></pre>
<p>We created a new <code>TextBox</code> class that is based on the <code>Widget</code> and adds additional <code>text</code> property.</p>
<p>Note that a base Widget constructor must also be called when a child class instantiated.
It must be the very first line of the child constructor implementation.</p>
<p>Here's another example:</p>
<pre><code class="language-js">class ImageBox extends Widget {
    constructor (id, x, y, width, height) {
        super(id, x, y);
        this.setSize(width, height);
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
    }

    reset() {
        this.setPosition(0, 0);
        this.setSize(0, 0);
    }
}
</code></pre>
<p><code>ImageBox</code> also inherits <code>Widget</code> class and adds size-related information alongside position.</p>
<p>Access to both classes is demonstrated with the <code>reset</code> function that calls <code>Widget.setPosition</code> and <code>ImageBox.setSize</code> functions.</p>
<h2 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h2>
<p>ES6 offers a shorter syntax for a <strong>function expression</strong> called <strong>arrow function</strong>, also known as <strong>fat arrow function</strong>.</p>
<p>Arrow functions provide more expressive closure syntax, simplify function scoping and change the way <code>this</code> is handled.</p>
<h3 id="expression-bodies"><a class="header" href="#expression-bodies">Expression Bodies</a></h3>
<p>When used as expressions bodies arrow functions work much like anonymous one-line <strong>lambdas</strong> that you can meet in many programming languages.</p>
<p>Let's filter a book collection to find something to read using both ES5 and ES6 to see the difference:</p>
<pre><code class="language-js">var books = [
    { name: 'Book 1', read: true },
    { name: 'Book 2' , read: false },
    { name: 'Book 3', read: true }
];

// ES5
var booksToRead = books.filter(function (b) { return !b.read });

// ES6
var booksToRead = books.filter(b =&gt; !b.read);
</code></pre>
<p>Curly brackets and <code>return</code> statement are not required if only one expression is present.</p>
<p>You could write the same example like following:</p>
<pre><code class="language-js">// ES6
let booksToRead = books.filter(b =&gt; { return !b.read; });
</code></pre>
<h3 id="statement-bodies"><a class="header" href="#statement-bodies">Statement Bodies</a></h3>
<p>Arrow functions provide more expressive closure syntax.</p>
<pre><code class="language-js">// ES6
// list the books I've read
books.forEach(book =&gt; {
  if (book.read) {
    console.log(book.name);
  }
});
</code></pre>
<p>And another example using DOM:</p>
<pre><code class="language-js">// ES6
let button = document.getElementById('submit-button');

button.addEventListener('click' () =&gt; {
    this.onButtonClicked();
});
</code></pre>
<p>Parameterless arrow functions are much easier to read</p>
<pre><code class="language-js">// ES6
setTimeout(_ =&gt; {
    console.log('First callback');
    setTimeout(_ =&gt; {
        console.log('Second callback');
    }, 1);
}, 1);
</code></pre>
<h3 id="lexical-this"><a class="header" href="#lexical-this">Lexical <em>this</em></a></h3>
<p>One of the best features of arrow functions in ES6 is the more intuitive handling of current object context.
These function expressions do not bind their variables:</p>
<ul>
<li>arguments</li>
<li>super</li>
<li>this</li>
<li>new.target</li>
</ul>
<pre><code class="language-js">// ES6
this.books.forEach(b =&gt; {
    if (!b.read) {
        this.booksToRead.push(b);
    }
});
</code></pre>
<p>There are multiple ways of doing the same with ECMAScript 5, and all of them involve manual context management</p>
<pre><code class="language-js">// ES5: using 'bind()'
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}).bind(this);

// ES5: referencing 'this' via variables
var self = this;

this.books.forEach(function(b) {
  if (!b.read) {
    self.booksToRead.push(b);
  }
});

// ES5: passing context if supported
this.books.forEach(function(b) {
  if (!b.read) {
    this.booksToRead.push(b);
  }
}, this);
</code></pre>
<p>As arrow functions do not create and bind their own <code>this</code> context the following code is concise and works as expected:</p>
<pre><code class="language-js">// ES6
function ProgressBar() {
  this.progress = 0;

  setInterval(() =&gt; {
    this.progress++;
  }, 1000);
}

const p = new ProgressBar();
</code></pre>
<p>In the example above <code>this</code> properly refers to the <code>ProgressBar</code> object.
Before ES6 you would most probably additional variables like <code>self</code>, <code>that</code>, and other.</p>
<pre><code class="language-js">// ES5
function ProgressBar() {
  var self = this;
  self.progress = 0;

  setInterval(function () {
    self.progress++;
  }, 1000);
}
</code></pre>
<h2 id="template-literals"><a class="header" href="#template-literals">Template Literals</a></h2>
<p>Template Literals (formerly called &quot;template strings&quot; in prior drafts of the ECMAScript 6 language specification) are string literals providing intuitive expression interpolation for single-line and multiline strings. </p>
<p>You use backticks to enclose a string literal and ${} to interpolate JavaScript variables or arbitrary expressions</p>
<pre><code class="language-js">// ES6
let point = { x: 10, y: 20 };

console.log(`Position is ${point.x}:${point.y}`);
// output: Position is 10:10
</code></pre>
<p>With ES5 you have to concatenate strings when dealing with multiple lines:</p>
<pre><code class="language-js">// ES5
var title = 'Title'
var component = {
  template: '' + 
    '&lt;h1&gt;' + title + '&lt;h1&gt;\n' +
    '&lt;div class=&quot;grid&quot;&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '   &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;\n' +
    '&lt;/div&gt;'
}
</code></pre>
<p>Multi-line string creation with template literals becomes very clean and readable:</p>
<pre><code class="language-js">// ES6
let title = 'Title';
let component = {
  template: `
    &lt;h1&gt;${title}&lt;/h1&gt;
    &lt;div class=&quot;grid&quot;&gt;
      &lt;div class=&quot;col-6&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;col-6&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
}
</code></pre>
<h2 id="extended-parameter-handling"><a class="header" href="#extended-parameter-handling">Extended Parameter Handling</a></h2>
<p>ES6 brings improvements to parameter handling by introducing <code>default values</code>, <code>rest parameter</code> and <code>spread operator</code>.</p>
<h3 id="default-parameter-values"><a class="header" href="#default-parameter-values">Default Parameter Values</a></h3>
<p>Simple and intuitive default values for function parameters.</p>
<pre><code class="language-js">// ES6
function playSound(file, volume = 50) {
  console.log(`Playing '${file}' with volume ${volume}.`);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>With ES5 you have to check every parameter to be <code>undefined</code> and setting defaults manually if needed.</p>
<pre><code class="language-js">// ES5
function playSound(file, volume) {
    if (volume === undefined) {
        volume = 50;
    }
    console.log(&quot;Playing '&quot; + file + &quot;' with volume &quot; + volume);
}
playSound('test.mp3'); 
// Playing 'test.mp3' with volume 50.

playSound('test.mp3', 70);
// Playing 'test.mp3' with volume 70.
</code></pre>
<p>So support for <code>default parameter values</code> is a huge step forward and real time saver.</p>
<h3 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h3>
<p>In ES5, if you want your function to handle an indefinite or an arbitrary number of arguments,
you must use special <code>arguments</code> variable:</p>
<pre><code class="language-js">// ES5
function logMessages() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i]);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Which produces:</p>
<pre><code class="language-text">Hello,
world!
</code></pre>
<p>In ES6, you can aggregate all remaining arguments into a single function parameter</p>
<pre><code class="language-js">// ES6
function logMessages(...messages) {
  for (const message of messages) {
    console.log(message);
  }
}

logMessages('Hello,', 'world!');
</code></pre>
<p>Also, that gives the same console output as before:</p>
<pre><code class="language-text">Hello, 
world!
</code></pre>
<p>Rest parameters become even more valuable when you have one or more required parameters followed by an arbitrary number of additional parameters.</p>
<p>In the next example, the rest parameter is used to collect arguments from the second one to the end of the array.</p>
<pre><code class="language-js">// ES6
function greet(message, ...friends) {
  for (const friend of friends) {
    console.log(`${message}, ${friend}!`);
  }
}

greet('Hello', 'John', 'Joan', 'Bob')
</code></pre>
<p>The function above allows you to set the greeting message as the first parameter and array of friend names to generate messages.
The console output, in this case, should be:</p>
<pre><code class="language-text">Hello, John!
Hello, Joan!
Hello, Bob!
</code></pre>
<h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<p>Spread operator is used to expand an iterable collection into multiple arguments.</p>
<pre><code class="language-js">// ES6
let positive = [ 1, 2, 3 ];
let negative = [ -1, -2, -3 ]

let numbers = [...negative, 0, ...positive];

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<p>You can use spread operator even with strings:</p>
<pre><code class="language-js">// ES6
let message = 'Hello, world';
let chars = [...message];

console.log(chars);
// [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;,&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]
</code></pre>
<p>Spread operator easily becomes an alternative to the <code>Array.prototype.concat()</code> method.
With ES5 the example above will look like the following:</p>
<pre><code class="language-js">// ES5
var positive = [ 1, 2, 3 ];
var negative = [ -1, -2, -3 ];
var zero = [0];

var numbers = negative.concat(zero, positive);

console.log(numbers);
// [-1, -2, -3, 0, 1, 2, 3]
</code></pre>
<h2 id="destructuring-assignment"><a class="header" href="#destructuring-assignment">Destructuring Assignment</a></h2>
<p>ES6 provides a way to extract values out of the objects or collections into the separate variables to access them easier in the code.
That is often called &quot;value unpacking&quot; or &quot;destructuring&quot;.</p>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic example</a></h3>
<p>As an example, you can extract a subset of values from the collection using the following format:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's create an array of words and extract the first couple of them into separate variables &quot;first&quot; and &quot;second&quot; like in the code below:</p>
<pre><code class="language-js">// ES6

let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second ] = words;

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<p>As you can see from the example above, you can extract a subset of an array and split it into multiple variables.</p>
<p>Without destructuring your code might look like the following:</p>
<pre><code class="language-js">// ES5

var words = [ 'this', 'is', 'hello', 'world', 'example' ];
var first = words[0];
var second = words[1];

console.log(first);  // 'this'
console.log(second); // 'is'
</code></pre>
<h3 id="array-destructuring"><a class="header" href="#array-destructuring">Array destructuring</a></h3>
<p>You have already seen some of the array destructuring examples earlier in the section.
We enclose variables in square brackets using the following syntax:</p>
<pre><code class="language-text">let [ &lt;var1&gt;, &lt;var2&gt; ] = &lt;array&gt;
</code></pre>
<p>Please note that you can also apply the same destructuring technique to the function call results:</p>
<pre><code class="language-js">// ES6

function getWords() {
    return [ 'this', 'is', 'hello', 'world', 'example' ];
}

let [ first, second ] = getWords();
console.log(`${first} ${second}`); // 'this is'
</code></pre>
<p>In addition to basic unpacking and variable assignment, several other things bring much value and reduce the code.</p>
<h4 id="value-assignment"><a class="header" href="#value-assignment">Value assignment</a></h4>
<p>The destructuring syntax can be used to assign values to variables instead of extracting them.
Take a look at the following example: </p>
<pre><code class="language-js">// ES6

let first, second;

[ first, second ] = [ 'hello', 'world' ];

console.log(first);  // 'hello'
console.log(second); // 'world'
</code></pre>
<h4 id="default-values"><a class="header" href="#default-values">Default values</a></h4>
<p>Another great feature of the array destructuring is default values.
There might be cases when the array has no values, and you want to provide some reasonable defaults.</p>
<p>The format of the syntax, in this case, is as follows:</p>
<pre><code class="language-text">let [ &lt;variable&gt; = &lt;value&gt; ] = &lt;array&gt;
</code></pre>
<p>Let's see this feature in action:</p>
<pre><code class="language-js">// ES6

let words = [ 'hello' ];
let [ first = 'hey', second = 'there' ] = words;

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<p>The array we got initially does not contain two words.
We are trying to extract first two variables from it, and set 'hey' as the default value for the first word, and 'there' as a default for the second one.
At the runtime however only second variable stays with the default value.</p>
<p>Default value assignment is a compelling feature that helps you reduce the code for variable initialization and safety checks.
Below is how the same code could look like in ES5:</p>
<pre><code class="language-js">// ES5

var words = ['hello'];

var first = words[0];
if (!first) {
    first = 'hey';
}

var second = words[1];
if (!second) {
    second = 'there'
}

console.log(first);  // 'hello'
console.log(second); // 'there'
</code></pre>
<h4 id="swapping-values"><a class="header" href="#swapping-values">Swapping values</a></h4>
<p>Traditionally to swap two variables, developers need a third temporary one to hold the value of either first or second variable.</p>
<pre><code class="language-js">// ES5

var first = 'world';
var second = 'hello';

var temp = first;
first = second;
second = temp;

console.log(first + ' ' + second); // 'hello world'
</code></pre>
<p>With ES6 you can now reduce the code by using destructuring assignment syntax to swap variables in a single line like in the next example:</p>
<pre><code class="language-js">// ES6

let first = 'world';
let second = 'hello';

[ first, second ] = [ second, first ];

console.log(`${first} ${second}`); // 'hello world'
</code></pre>
<p>This feature may be a great time saver when it comes to sorting functions.</p>
<h4 id="skipping-values"><a class="header" href="#skipping-values">Skipping values</a></h4>
<p>We have been using examples that take the beginning of the array so far.<br />
The ES6 does not restrict you to that only scenario; it is also possible skipping values when unpacking or destructuring arrays.</p>
<pre><code class="language-text">let [ &lt;variable-1&gt;, , , , &lt;variable-X&gt; ] = &lt;array&gt;
</code></pre>
<p>You can just put the commas instead of variables like in the example below:</p>
<pre><code class="language-js">let words = [ 'this', 'is', 'hello', 'world', 'example' ];
let [ first, second, , , last ] = words;

console.log(`${first} ${second} ${last}`); // 'this is example'
</code></pre>
<h4 id="grouping-tail-values-into-a-single-variable"><a class="header" href="#grouping-tail-values-into-a-single-variable">Grouping tail values into a single variable</a></h4>
<p>As you see, the ES6 allows you to unpack the head of the array into separate variables.
Sometimes you may want to access the tail of the array as a single variable as well.</p>
<p>For this particular case, there's a special syntax that utilizes ES6 &quot;rest&quot; parameters.</p>
<pre><code class="language-text">let [ &lt;variable1&gt;, &lt;variable2&gt;, ...&lt;restVariable&gt; ] = &lt;array&gt;
</code></pre>
<p>We use &quot;rest parameter&quot; to define a variable to hold the tail of the array and below is an example of how to achieve this behavior:</p>
<pre><code class="language-js">let command = [ 'greet', 'user1', 'user2', 'user3' ];
let [ action, ...users ] = command;

console.log(action); // 'greet'
console.log(users);  // [ 'user1', 'user2', 'user3' ] 
</code></pre>
<h3 id="object-destructuring"><a class="header" href="#object-destructuring">Object destructuring</a></h3>
<p>Besides arrays and collections, you can use destructuring assignment syntax with the object instances as well.</p>
<p>We enclose variables in curly brackets using the following syntax:</p>
<pre><code class="language-text">let { &lt;var1&gt;, &lt;var2&gt; } = &lt;object&gt;
</code></pre>
<h4 id="unpacking-properties"><a class="header" href="#unpacking-properties">Unpacking properties</a></h4>
<p>ES6 allows you to extract properties by their names similar to how to unpack arrays.</p>
<p>Let's try to unpack a couple of properties from a user object:</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id, username } = obj;

console.log(id);        // '1'
console.log(username);  // 'jdoe'
</code></pre>
<h4 id="renaming-properties"><a class="header" href="#renaming-properties">Renaming properties</a></h4>
<p>You can also give destructured property an alias if you want to use it as a variable with a different name.</p>
<p>The syntax, in this case, is going to be as follows:</p>
<pre><code class="language-text">let { &lt;property&gt; : &lt;alias&gt; } = &lt;object&gt;;
</code></pre>
<p>Let's now rewrite our previous example to use custom property names.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id: uid, username: login } = obj;

console.log(uid);    // '1'
console.log(login);  // 'jdoe'
</code></pre>
<p>We are using &quot;uid&quot; and &quot;login&quot; instead of &quot;id&quot; and &quot;username&quot; properties this time.</p>
<h4 id="default-values-1"><a class="header" href="#default-values-1">Default values</a></h4>
<p>When applying property destructuring to the object properties, you can provide default values for missing properties.
That saves time for property checks and reduces coding efforts.</p>
<pre><code class="language-text">let { &lt;variable&gt; : &lt;value&gt; } = &lt;object&gt;
</code></pre>
<p>For example, let's provide a default value for the &quot;id&quot; property and also unpack the property &quot;role&quot;
that does not exist for the given object, and set it to be &quot;guest&quot; by default.</p>
<pre><code class="language-js">let obj = {
  id: 1,
  username: 'jdoe',
  firstName: 'John',
  lastName: 'Doe'
};

let { id = 0, role = 'guest' } = obj;

console.log(id);    // '1'
console.log(role);  // 'guest'
</code></pre>
<h4 id="unpacking-methods"><a class="header" href="#unpacking-methods">Unpacking methods</a></h4>
<p>You can extract object methods into separate variables and use them as shortcuts:</p>
<pre><code class="language-js">let { log } = console;
log('hello world');
</code></pre>
<p>The example above demonstrates a &quot;console.log&quot; method being extracted into the &quot;log&quot; variable and used separately.</p>
<p>We utilise the following syntax:</p>
<pre><code class="language-text">let { &lt;method&gt; } = &lt;object&gt;
</code></pre>
<p>Next, let's create a custom class and export multiple methods:</p>
<pre><code class="language-js">// ES6

class MyClass {

  sayHello(message) {
    console.log(`Hello, ${message}`);
  }

  sayBye(message) {
    console.log(`Bye, ${message}`);
  }

}

let myClass = new MyClass();
let { sayHello, sayBye } = myClass;

sayHello('how are you?');  // 'Hello, how are you?'
sayBye('see you soon.');   // 'Bye, see you soon'
</code></pre>
<h4 id="renaming-methods"><a class="header" href="#renaming-methods">Renaming methods</a></h4>
<p>You can also rename destructured methods if needed. The following syntax should be used to give the unpacked method a custom name:</p>
<pre><code class="language-text">let { &lt;method&gt; : &lt;alias&gt; } = &lt;object&gt;
</code></pre>
<p>Let's update the &quot;MyClass&quot; we used earlier and rename &quot;sayHello&quot; and &quot;sayBye&quot; methods to just &quot;hello&quot; and &quot;bye&quot;:</p>
<pre><code class="language-js">let myClass = new MyClass();
let { sayHello: hello, sayBye: bye } = myClass;

hello('how are you?');  // Hello, how are you?
bye('see you soon');    // Bye, see you soon
</code></pre>
<h3 id="using-with-function-parameters"><a class="header" href="#using-with-function-parameters">Using with function parameters</a></h3>
<p>The best scenario for using destructuring with objects and functions is default parameter values and options.</p>
<p>First, let's reproduce the most common use case for the &quot;options&quot; parameter passed to a function or object member:</p>
<pre><code class="language-js">// ES5

function showDialog(options) {
  options = options || {};
  var message = options.message || 'Unknown message';
  var size = options.size || { width: 400, height: 400 };
  var position = options.position || { x: 200, y: 300 };

  console.log('message: ' + message);
  console.log('size: ' + size.width + ':' + size.height);
  console.log('position: ' + position.x + ':' + position.y);
}
</code></pre>
<p>Above is the simplified version of the custom options management that has been very popular for years.
We provide a JavaScript object as an &quot;options&quot; parameter, and function does parsing and detecting missing properties to initialize default values if needed.</p>
<p>Depending on the size of the options object there might be many checks just to set the default values for them.
Especially if there are nested objects with own properties, like &quot;size&quot; and &quot;position&quot; in our case.</p>
<p>Now, if you call the &quot;showDialog&quot; function with no parameters except the &quot;message&quot; value, the output should be similar to the following one:</p>
<pre><code class="language-js">showDialog({ 
    message: 'hello world' 
});

// message: hello world
// size: 400:400
// position: 200:300
</code></pre>
<p>Next, try to call the same function with a partial set of options, for instance, the &quot;size&quot; settings:</p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<p>Now you can rewrite the &quot;showDialog&quot; implementation to use destructuring with default values like in the next example:</p>
<pre><code class="language-js">// ES6

function showDialog({ 
  message = 'Message', 
  size = { width: 400, height: 400 },
  position = { x: 200, y: 300 } }) {

  console.log(`message: ${message}`);
  console.log(`size: ${size.width}:${size.height}`);
  console.log(`position: ${position.x}:${position.y}`);
}
</code></pre>
<p>Notice how we use the destructuring assignment syntax to declare a function parameter. </p>
<pre><code class="language-js">showDialog({
  message: 'hey there',
  size: { width: 200, height: 100 }
});

// message: hey there
// size: 200:100
// position: 200:300
</code></pre>
<h4 id="ide-support"><a class="header" href="#ide-support">IDE support</a></h4>
<p>Many modern IDEs already provide support for destructuring syntax within function or method parameters. <a href="https://code.visualstudio.com/">VS Code</a>, for instance, provides auto-completion both for function calls and for nested properties.</p>
<p><img src="images/es6-desctructuring-01.png" alt="" /></p>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Before ES6 developers traditionally were using <code>Revealing Module</code> pattern to emulate modules in JavaScript.</p>
<p>The basic concept of a Revealing Module is that you use <code>closures</code> (self-invoking functions)
with an <code>Object</code> which encapsulates its data and behavior.</p>
<pre><code class="language-js">// ES5
var Module = (function() {
    var privateMethod = function() {
        // do something 
        console.log('private method called');
    };

    return {
        x: 10,
        name: 'some name',
        publicMethod: function() {
            // do something
            console.log('public method called');
            privateMethod();
        }
    };
})();

Module.publicMethod()
</code></pre>
<p>You should get the following output to browser console:</p>
<pre><code class="language-text">public method called
private method called
</code></pre>
<p>I recommend also reading an excellent article &quot;<a href="https://toddmotto.com/mastering-the-module-pattern/">Mastering the Module Pattern</a>&quot; by Todd Motto to get deep coverage of <strong>Revealing Module</strong> pattern in JavaScript.</p>
<p>The rise of module systems based on either AMD or CommonJS syntax has mostly replaced revealing modules and other hand-written solutions in ES5.</p>
<h3 id="exporting-and-importing-values"><a class="header" href="#exporting-and-importing-values">Exporting and Importing Values</a></h3>
<p>ECMAScript 6 provides a long-needed support for exporting and importing values from/to modules without global namespace pollution.</p>
<pre><code class="language-js">// ES6

// module lib/logger.js
export function log (message) { console.log(message); };
export var defaultErrorMessage = 'Aw, Snap!';

//  myApp.js
import * as logger from &quot;lib/logger&quot;;
logger.log(logger.defaultErrorMessage);

//  anotherApp.js
import { log, defaultErrorMessage } from &quot;lib/logger&quot;;
log(defaultErrorMessage);
</code></pre>
<p>Here's how the same approach would look like if written with ECMAScript 5:</p>
<pre><code class="language-js">// ES5

// lib/logger.js
LoggerLib = {};
LoggerLib.log = function(message) { console.log(message); };
LoggerLib.defaultErrorMessage = 'Aw, Snap!';

// myApp.js
var logger = LoggerLib;
logger.log(logger.defaultErrorMessage);

// anotherApp.js
var log = LoggerLib.log;
var defaultErrorMessage = LoggerLib.defaultErrorMessage;
log(defaultErrorMessage);
</code></pre>
<h3 id="default-values-2"><a class="header" href="#default-values-2">Default Values</a></h3>
<p>You can make your ES6 module exporting some value as <code>default</code> one.</p>
<pre><code class="language-js">// ES6

// lib/logger.js
export default (message) =&gt; console.log(message);

// app.js
import output from 'lib/logger';
output('hello world');
</code></pre>
<h3 id="wildcard-export"><a class="header" href="#wildcard-export">Wildcard Export</a></h3>
<p>Another great feature of ES6 modules is support for wildcard-based export of values.
That becomes handy if you are creating a composite module that re-exports values from other modules.</p>
<pre><code class="language-js">// ES6

// lib/complex-module.js
export * from 'lib/logger';
export * from 'lib/http';
export * from 'lib/utils';

// app.js
import { logger, httpClient, stringUtils } from 'lib/complex-module';
logger.log('hello from logger');
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="http://es6-features.org/">ECMAScript 6 â€” New Features: Overview &amp; Comparison</a></li>
</ul>
<h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h2 id="getting-started-with-typescript"><a class="header" href="#getting-started-with-typescript">Getting Started with TypeScript</a></h2>
<h3 id="installing-typescript"><a class="header" href="#installing-typescript">Installing TypeScript</a></h3>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<h3 id="using-tsc"><a class="header" href="#using-tsc">Using tsc</a></h3>
<p>In your code editor create a file <code>logger.ts</code> with the following content:</p>
<pre><code class="language-js">function log(message) {
    console.log(message);
}

log('Hello, world!');
</code></pre>
<p>Now you can use a command line to compile your source code to ES5 with <code>tsc</code> tool and run it with <code>node.js</code>:</p>
<pre><code class="language-sh">tsc logger.ts
node logger.js
</code></pre>
<p>TypeScript compiler takes <code>logger.ts</code> file, processes it and produces a JavaScript output to <code>logger.js</code>.
At this point, the <code>.js</code> file is ready to be used with an HTML page or executed by node.js.</p>
<p>You should see the following output in the command line:</p>
<pre><code class="language-text">Hello, world!
</code></pre>
<p>Now let's see how type validation works.
Add <code>string</code> type annotation for the <code>log</code> function and call it with a <code>number</code>.</p>
<pre><code class="language-ts">function log(message: string) {
    console.log(message);
}

log(0);
</code></pre>
<p>If you compile <code>logger.ts</code> once again <code>tsc</code> should produce an error:</p>
<pre><code class="language-sh">tsc logger.ts
&gt; logger.ts(5,5): error TS2345: Argument of type '0' is not assignable to parameter
of type 'string'.
</code></pre>
<h3 id="typings"><a class="header" href="#typings">Typings</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h3 id="linting"><a class="header" href="#linting">Linting</a></h3>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h4 id="tslint"><a class="header" href="#tslint">TSLint</a></h4>
<blockquote>
<p>TSLint checks your TypeScript code for readability, maintainability, and functionality errors.</p>
</blockquote>
<pre><code class="language-sh">npm install -g tslint
</code></pre>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/3">todo: needs content</a></em></p>
<h2 id="typescript-features"><a class="header" href="#typescript-features">TypeScript Features</a></h2>
<p><em><a href="https://github.com/DenysVuika/angular-book/issues/4">todo: Needs introduction</a></em></p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>TypeScript supports all the types used in JavaScript:</p>
<ul>
<li><strong>boolean</strong></li>
<li><strong>number</strong></li>
<li><strong>string</strong></li>
<li><strong>arrays</strong></li>
</ul>
<p>TypeScript also adds the following types:</p>
<ul>
<li><strong>enum</strong></li>
<li><strong>any</strong></li>
<li><strong>void</strong></li>
</ul>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<h4 id="boolean"><a class="header" href="#boolean">Boolean</a></h4>
<p>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a boolean value.</p>
<pre><code class="language-ts">let isEnabled: boolean = true;
</code></pre>
<p>Assigning non-Boolean value to the variable will produce an error.</p>
<pre><code class="language-ts">isEnabled = 'YES';
// logger.ts(2,1): error TS2322: Type '&quot;YES&quot;' is not assignable to type 'boolean'.
</code></pre>
<p>It is also possible annotating function or method return types.</p>
<pre><code class="language-ts">function isEmpty(str: string): boolean {
    return !str;
}
</code></pre>
<h4 id="number"><a class="header" href="#number">Number</a></h4>
<p>TypeScript maps all JavaScript numbers to the <code>number</code> type:</p>
<ul>
<li>floating point numbers (default JavaScript type for all numbers)</li>
<li>decimal numbers</li>
<li>hexadecimal numbers</li>
<li>binary literals (ES6)</li>
<li>octal literals (ES6)</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-ts">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>Typescript supports ES6 <strong>template literals</strong> (formerly known as <strong>template strings</strong>).</p>
<p>As in ECMAScript 6, you use backticks (`) to enclose a string literal and <strong>${}</strong> to interpolate JavaScript variables or arbitrary expressions.</p>
<p>Either double quotes (&quot;) or single quotes (') can be used to surround string data.</p>
<pre><code class="language-ts">let firstName: string = &quot;Joan&quot;;
let lastName: string = 'Doe';
let fullName: string = `${firstName} ${lastName}`;
let template: string = `
    &lt;h1&gt;Title&lt;h1&gt;
    &lt;p&gt;Hello, ${fullName}&lt;/p&gt;
`;
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>There are two main ways you can provide type definition for arrays of values in TypeScript:</p>
<pre><code class="language-ts">let arr1: string[] = [];
let arr2: Array&lt;string&gt; = new Array();
</code></pre>
<p>You can also initialize arrays upon declaring them:</p>
<pre><code class="language-ts">let arr1: string[] = ['hello', 'world'];
let arr2: Array&lt;string&gt; = ['hello', 'world'];

let flags1: boolean[] = [true, false, true, false];
let flags2: boolean[] = new Array(false, true);
</code></pre>
<p>As in JavaScript arrays, you can <strong>push</strong> elements and access them by <strong>index</strong></p>
<pre><code class="language-ts">let users: string[] = [];

users.push('user1');

console.log(`First user: ${users[0]}`);
</code></pre>
<p>The sample above demonstrates array element access together with string interpolation.
When executed it should produce:</p>
<pre><code class="language-text">First user: user1
</code></pre>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<p>TypeScript provides support for an <strong>enumerated type</strong> known in many languages (Swift, C#, Java, C, and others).
This data type consists of a set of named values mapped to numbers.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

let s: Suit = Suit.Spade;
</code></pre>
<p>By default numbering of enum members starts with 0 and increments by one.
You have full control of the values if needed.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };
enum Suit { Club = 1, Diamond = 2, Heart = 4, Spade = 8 }
</code></pre>
<p>Another valuable feature is accessing by a numeric value.</p>
<pre><code class="language-ts">enum Suit { Club, Diamond, Heart, Spade };

console.log(Suit[0]); // Club
</code></pre>
<p>It must be noted however that you access names by the numeric values, not by an array index as it may seem.</p>
<pre><code class="language-ts">enum Suit { Club = 1, Diamond, Heart, Spade };

console.log(Suit[0]); // undefined
console.log(Suit[1]); // Club
</code></pre>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p>A special <strong>any</strong> type is used to opt-out of the TypeScript type-checking process and addresses the following cases:</p>
<ul>
<li>dynamic content (objects created on the fly)</li>
<li>3rd party libraries (having no TypeScript support via definition files)</li>
</ul>
<pre><code class="language-ts">let obj: any = {
    log(message) {
        console.log(message);
    }
};
obj.log('hello world');
</code></pre>
<p>Please note that by opting-out of the type-checking process you take full responsibility for safety checks,
as now TypeScript compiler is not able to verify the code at compile time.</p>
<p>The following example shows valid TypeScript code:</p>
<pre><code class="language-ts">obj.log('hello world'); 
obj.helloWorld('log');
</code></pre>
<p>However, at runtime the second line causes a TypeError exception:</p>
<pre><code class="language-text">hello world
TypeError: obj.helloWorld is not a function
</code></pre>
<p>So it is recommended using <strong>any</strong> type only where necessary.</p>
<h3 id="void"><a class="header" href="#void">Void</a></h3>
<p>The <strong>void</strong> type is used to declare a function does not return any value explicitly.</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
        return true;
    }

}
</code></pre>
<p>If you try compiling the code above you should get an error:</p>
<pre><code class="language-text">error TS2322: Type 'true' is not assignable to type 'void'.
</code></pre>
<p>You can fix the type-check error by removing <strong>return</strong> statement from the <strong>log</strong> method:</p>
<pre><code class="language-ts">class Logger {

    log(message: string): void {
        console.log(message);
    }

}
</code></pre>
<p>You might also be using <strong>void</strong> types as function parameters or with <strong>Interfaces</strong>:</p>
<pre><code class="language-ts">function fn(x: () =&gt; void) {
  x();
}

interface Logger {

  log(message: string): void;
  warn(message: string): void;
  error(message: string): void;

}
</code></pre>
<p><em>You will get more information on <strong>Interfaces</strong> later in this book.</em></p>
<h2 id="classes-1"><a class="header" href="#classes-1">Classes</a></h2>
<p>TypeScript provides support for classes introduced with ES6 (ECMAScript 2015) and adds a set of features to improve object-oriented development.</p>
<pre><code class="language-ts">class Widget {

    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        console.log(`Rendering widget &quot;${this.id}&quot;`);
    }

}

let widget = new Widget('text1');
widget.render();
</code></pre>
<p>You should get the following output when executed:</p>
<pre><code class="language-text">Rendering widget &quot;text1&quot;
</code></pre>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>With ES6 you define class properties from with the class constructor:</p>
<pre><code class="language-js">// ES6
class Widget {

    constructor(id) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }

}
</code></pre>
<p>If you try compiling example above with <code>tsc</code> utility (TypeScript compiler) you should get the following errors:</p>
<pre><code class="language-text">error TS2339: Property 'id' does not exist on type 'Widget'.
error TS2339: Property 'x' does not exist on type 'Widget'.
error TS2339: Property 'y' does not exist on type 'Widget'.
</code></pre>
<p>The errors are raised because TypeScript requires you to define properties separately.
It is needed to enable many other features TypeScript provides.</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number;
    x: number;

    constructor(id: string) {
        this.id = id;
        this.x = 0;
        this.y = 0;
    }
}
</code></pre>
<p>Properties in TypeScript can have default values:</p>
<pre><code class="language-ts">class Widget {

    id: string;
    x: number = 0;
    x: number = 0;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<h3 id="setters-and-getters"><a class="header" href="#setters-and-getters">Setters and Getters</a></h3>
<p>TypeScript supports <em>computed properties</em>, which do not store a value.
Instead, they provide <em>getters</em> and <em>setters</em> to retrieve and assign values in a controlled way.</p>
<p><strong>TBD</strong>: describe get/set format</p>
<p>One of the common cases for a <em>getter</em> is computing a return value based on other property values:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}

let user = new User('Joan', 'Doe');
console.log(`User full name is: ${user.fullName}`);
</code></pre>
<p>If you save this example to file <code>script.ts</code>, compile it and run like shown below:</p>
<pre><code class="language-sh">tsc --target ES6 script.ts
node script.js
</code></pre>
<p>You should see the output with the full username as expected:</p>
<pre><code class="language-text">User full name is: Joan Doe
</code></pre>
<p>Now let's introduce a simple <em>setter</em> for the <code>firstName</code> property.</p>
<p>Every time a new property value is set we are going to remove leading and trailing white space.
Such values as &quot; Joan&quot; and &quot;Joan  &quot; are automatically converted to &quot;Joan&quot;.</p>
<pre><code class="language-ts">class User {

    private _firstName: string;

    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        if (value) {
            this._firstName = value.trim();
        }
    }
}

let user = new User();
user.firstName = '  Joan   ';
console.log(`The first name is &quot;${user.firstName}&quot;.`);
</code></pre>
<p>The console output, in this case, should be:</p>
<pre><code class="language-text">The first name is &quot;Joan&quot;.
</code></pre>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>Methods are functions that operate on a class object and are bound to an instance of that object.
You can use <code>this</code> keyword to access properties and call other methods like in the example below:</p>
<pre><code class="language-ts">class Sprite {

    x: number;
    y: number;

    render() {
        console.log(`rendering widget at ${this.x}:${this.y}`);
    }
    
    moveTo(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.render();
    }

}

let sprite = new Sprite();
sprite.moveTo(5, 10);
// rendering widget at 5:10
</code></pre>
<h4 id="return-values"><a class="header" href="#return-values">Return values</a></h4>
<pre><code class="language-ts">class NumberWidget {

    getId(): string {
        return 'number1';
    }

    getValue(): number {
        return 10;
    }

}
</code></pre>
<p>You can use a <code>void</code> type if the method does not return any value.</p>
<pre><code class="language-ts">class TextWidget {

    text: string;

    reset(): void {
        this.text = '';
    }

}
</code></pre>
<h4 id="method-parameters"><a class="header" href="#method-parameters">Method parameters</a></h4>
<p>You can add types to each parameter of the method.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level: number) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>TypeScript will automatically perform type checking at compile time.
Let's try providing a string value for the <code>level</code> parameter:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 'not a number');
</code></pre>
<p>You should get a compile error with the following message:</p>
<pre><code class="language-text">error TS2345: Argument of type '&quot;string&quot;' is not assignable to parameter of type 'number'.
</code></pre>
<p>Now let's change <code>level</code> parameter to a number to fix compilation</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('test', 2);
</code></pre>
<p>Now we should get the expected output:</p>
<pre><code class="language-text">(2): test
</code></pre>
<h4 id="optional-parameters"><a class="header" href="#optional-parameters">Optional parameters</a></h4>
<p>By default, all method/function parameters in TypeScript are <code>required</code>.
However, it is possible making parameters optional by appending <strong>?</strong> (question mark) symbol to the parameter name.</p>
<p>Let's update our <code>Logger</code> class and make <code>level</code> parameter optional.</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string, level?: number) {
        if (level === undefined) {
            level = 1;
        }
        console.log(`(${level}): ${message}`);
    }

}

let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The <code>log</code> method provides default value automatically if <code>level</code> is omitted.</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<p>Please note that optional parameters must always follow required ones.</p>
<h4 id="default-parameters"><a class="header" href="#default-parameters">Default parameters</a></h4>
<p>TypeScript also supports default values for parameters.
Instead of checking every parameter for <code>undefined</code> value you can provide defaults directly within the method declaration:</p>
<pre><code class="language-ts">class Logger {
    
    log(message: string = 'Unknown error', level: number = 1) {
        console.log(`(${level}): ${message}`);
    }

}
</code></pre>
<p>Let's try calling <code>log</code> without any parameters:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.log('Application error');
</code></pre>
<p>The output, in this case, should be:</p>
<pre><code class="language-text">(1): Application error
</code></pre>
<h4 id="rest-parameters-and-spread-operator"><a class="header" href="#rest-parameters-and-spread-operator">Rest Parameters and Spread Operator</a></h4>
<p>In TypeScript, you can gather multiple arguments into a single variable known as <em>rest parameter</em>.
Rest parameters were introduced as part of ES6, and TypesScripts extends them with type checking support.</p>
<pre><code class="language-ts">class Logger {

    showErrors(...errors: string[]) {
        for (let err of errors) {
            console.error(err);
        }
    }

}
</code></pre>
<p>Now you can provide an arbitrary number of arguments for <code>showErrors</code> method:</p>
<pre><code class="language-ts">let logger = new Logger();
logger.showErrors('Something', 'went', 'wrong');
</code></pre>
<p>That should produce three errors as an output:</p>
<pre><code class="language-text">Something
went
wrong
</code></pre>
<p><em>Rest parameters</em> in TypeScript work great with <em>Spread Operator</em> allowing you to expand a collection into multiple arguments.
It is also possible mixing regular parameters with <em>spread</em> ones:</p>
<pre><code class="language-ts">let logger = new Logger();
let messages = ['something', 'went', 'wrong'];

logger.showErrors('Error', ...messages, '!');
</code></pre>
<p>In the example above we compose a collection of arguments from arbitrary parameters and content of the <code>messages</code> array in the middle.</p>
<p>The <code>showErrors</code> method should handle all entries correctly and produce the following output:</p>
<pre><code class="language-text">Error
something
went
wrong
!
</code></pre>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Constructors in TypeScript got same features as methods.
You can have default and optional parameters, use rest parameters and spread operators with class constructor functions.</p>
<p>Besides, TypeScript provides support for automatic property creation based on constructor parameters.
Let's create a typical <code>User</code> class implementation:</p>
<pre><code class="language-ts">class User {

    firstName: string;
    lastName: string;

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

}
</code></pre>
<p>Instead of assigning parameter values to the corresponding properties we can instruct TypeScript to perform an automatic assignment instead.
You can do that by putting one of the access modifiers <strong>public</strong>, <strong>private</strong> or <strong>protected</strong> before the parameter name.</p>
<p>You are going to get more details on <em>access modifiers</em> later in this book.
For now, let's see the updated <code>User</code> class using automatic property assignment:</p>
<pre><code class="language-ts">class User {

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`.trim();
    }

    constructor(public firstName: string, public lastName: string) {
    }

}

let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<p>TypeScript creates <code>firstName</code> and <code>lastName</code> properties when generating JavaScript output.
You need targeting at least ES5 to use this feature.</p>
<p>Save example above to file <code>script.ts</code> then compile and run with <code>node</code>:</p>
<pre><code class="language-sh">tsc script.ts --target ES5
node script.js
</code></pre>
<p>The output should be as following:</p>
<pre><code class="language-text">Full name is: Joan Doe
</code></pre>
<p>You have not defined properties explicitly, but <code>fullName</code> getter was still able accessing them via <code>this</code>.
If you take a look at the emitted JavaScript you should see the properties are defined there as expected:</p>
<pre><code class="language-js">// ES5
var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    Object.defineProperty(User.prototype, &quot;fullName&quot;, {
        get: function () {
            return (this.firstName + &quot; &quot; + this.lastName).trim();
        },
        enumerable: true,
        configurable: true
    });
    return User;
}());
var user = new User('Joan', 'Doe');
console.log(&quot;Full name is: &quot; + user.fullName);
</code></pre>
<p>Now you can also switch to ES6 target to see how TypeScript assigns properties:</p>
<pre><code class="language-sh">tsc script.ts --target ES6
</code></pre>
<p>The generated JavaScript, in this case, is even smaller and cleaner:</p>
<pre><code class="language-js">// ES6
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName() {
        return `${this.firstName} ${this.lastName}`.trim();
    }
}
let user = new User('Joan', 'Doe');
console.log(`Full name is: ${user.fullName}`);
</code></pre>
<h3 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h3>
<p>One of the important TypeScript features is the class inheritance that enables OOP patterns for developers.
Under the hood TypeScript is using the same <code>extends</code> syntactic sugar when targeting ES6 JavaScript,
and prototypical inheritance wrappers when generating output in ES5.</p>
<p>We can refer to animals as a classic example of class-based programming and inheritance.</p>
<pre><code class="language-ts">class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    makeSound() {
        console.log('Unknown sound');
    }
}
</code></pre>
<p>You have created a basic <code>Animal</code> class that contains a <code>name</code> property and <code>makeSound</code> method.
That translates to ES5 as following:</p>
<pre><code class="language-js">// ES5
var Animal = (function () {
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.makeSound = function () {
        console.log('Unknown sound');
    };
    return Animal;
}());
</code></pre>
<p>Now you can create a <code>Dog</code> implementation that provides a right sound:</p>
<pre><code class="language-ts">class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Woof-woof');
    }
}
</code></pre>
<p>Please note that if you have a constructor in the base class, then you must call it from all derived classes.
Otherwise, TypeScript should raise a compile-time error:</p>
<pre><code class="language-text">error TS2377: Constructors for derived classes must contain a 'super' call.
</code></pre>
<p>Here's how a <code>Dog</code> gets converted to ES5:</p>
<pre><code class="language-ts">var Dog = (function (_super) {
    __extends(Dog, _super);
    function Dog(name) {
        return _super.call(this, name) || this;
    }
    Dog.prototype.makeSound = function () {
        console.log('Woof-woof');
    };
    return Dog;
}(Animal));
</code></pre>
<p>Now let's add a <code>Cat</code> implementation with its sound and test both classes:</p>
<pre><code class="language-ts">class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }
    makeSound() {
        console.log('Meow');
    }
}

let dog = new Dog('Spot');
let cat = new Cat('Tom');

dog.makeSound();
cat.makeSound();
</code></pre>
<p>Once the code compiles and executes you should get the following output:</p>
<pre><code class="language-text">Woof-woof
Meow
</code></pre>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>TypeScript supports <code>public</code>, <code>private</code> and <code>protected</code> modifiers for defining accessibility of the class members.</p>
<h4 id="public"><a class="header" href="#public">Public</a></h4>
<p>By default, each member of the class is <code>public</code> so that you can omit it.
However, nothing stops you from declaring <code>public</code> modifier explicitly if needed:</p>
<pre><code class="language-ts">class User {
    public firstName: string;
    public lastName: string;

    public speak() {
        console.log('Hello');
    }

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre>
<p>Now if you compile example above to JavaScript you should see the following:</p>
<pre><code class="language-js">var User = (function () {
    function User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    User.prototype.speak = function () {
        console.log('Hello');
    };
    return User;
}());
</code></pre>
<h4 id="private"><a class="header" href="#private">Private</a></h4>
<p>You mark a member as <code>private</code> when it should never be accessed from outside of its containing class.
One of the most common scenarios is creating private fields to hold values for properties.
For example:</p>
<pre><code class="language-ts">class User {
    private _firstName: string;
    private _lastName: string;

    get firstName() {
        return this._firstName;
    }

    get lastName() {
        return this._lastName;
    }

    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
}
</code></pre>
<p>The class we have created above allows setting user's first and last name only from within the constructor.</p>
<p>If you try changing name properties from outside the class, TypeScript will raise an error at compile time:</p>
<pre><code class="language-ts">let user = new User('John', 'Doe');
user.firstName = 'Rob';
// error TS2540: Cannot assign to 'firstName' because it is a constant or a read-only property.
</code></pre>
<h4 id="protected"><a class="header" href="#protected">Protected</a></h4>
<p>The <code>protected</code> modifier restricts member visibility from outside of the containing class but provides access from the derived classes.</p>
<p>Let's start with base <code>Page</code> class implementation:</p>
<pre><code class="language-ts">class Page {

    protected renderHeader()    { /* ... */ }
    protected renderContent()   { /* ... */ }
    protected renderFooter()    { /* ... */ }

    render() {
        this.renderHeader();
        this.renderContent();        
        this.renderFooter();
    }
}
</code></pre>
<p>We created a <code>Page</code> class that has public method <code>render</code>.
Internally <code>render</code> calls three separate methods to render header, content and footer of the page.
These methods are not available from the outside the the class.</p>
<p>Now we are going to create a simple derived <code>AboutPage</code> class:</p>
<pre><code class="language-ts">class AboutPage extends Page {

    private renderAboutContent() { /* ... */ }

    render() {
        this.renderHeader();
        this.renderAboutContent();
        this.renderFooter();
    }

}
</code></pre>
<p>As you can see the <code>AboutPage</code> defines its <code>render</code> method that calls
<code>renderHeader</code> and <code>renderFooter</code> in parent class but puts custom content in the middle.</p>
<p>You can also use <code>protected</code> modifier with class constructors.
In this case, the class can be instantiated only by the derived classes that extend it.
That becomes handy when you want to have properties and methods available for multiple classes as a base implementation,
but don't want a base class to be instantiated outside its containing class.</p>
<p>For example</p>
<pre><code class="language-ts">class Page {
    protected constructor(id: string) {
        // ...
    }

    render() { /* base render */ }
}

class MainPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render main page */ }
}

class AboutPage extends Page {
    constructor(id: string) {
        super(id);
    }

    render() { /* render about page */ }
}

let main = new MainPage('main');
let about = new AboutPage('about');
</code></pre>
<p>You can create instances of <code>MainPage</code> and <code>AboutPage</code> both having access to protected members of the <code>Page</code> class.
However, you are not able creating an instance of the <code>Page</code> class directly.</p>
<pre><code class="language-ts">let page = new Page(); 
// error TS2674: Constructor of class 'Page' is protected and only accessible within the class declaration.
</code></pre>
<h3 id="readonly-modifier"><a class="header" href="#readonly-modifier">Readonly modifier</a></h3>
<p>One of the common ways to create a read-only property in many object-oriented programming languages
is by having a private local variable with a <code>getter</code> only.</p>
<pre><code class="language-ts">class Widget {

    private _id: string;

    get id(): string {
        return this._id;
    }

    constructor(id: string) {
        this._id = id;
    }
}

let widget = new Widget('textBox');
console.log(`Widget id: ${widget.id}`);
// Widget id: textBox
</code></pre>
<p>You can also make properties read-only by using the <code>readonly</code> keyword.
That reduces repetitive typing when dealing with many read-only properties, and greatly improves overall code readability.</p>
<p>Let's update the previous example to use <code>readonly</code>:</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;

    constructor(id: string) {
        this.id = id;
    }
}
</code></pre>
<p>If you try changing the value of the property outside of the constructor TypeScript will raise an error:</p>
<pre><code class="language-ts">let widget = new Widget('text');
widget.id = 'newId';
// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p>You can provide default values for read-only properties only in two places: property declaration and constructor.</p>
<pre><code class="language-ts">class Widget {
    readonly id: string;
    readonly minWidth: number = 200;
    readonly minHeight: number = 100;

    constructor(id: string) {
        this.id = id;
    }
}

let widget = new Widget('text');
widget.minWidth = 1000;
// error TS2540: Cannot assign to 'minWidth' because it is a constant or a read-only property.
</code></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>An <em>interface</em> is a description of the actions that an object can do.</p>
<p>You might already be familiar with <em>interfaces</em> in other programming languages like C# and Java,
or <em>contracts</em> in Swift.</p>
<p>Interfaces are not part of the ECMAScript.
It is a level of abstraction supported by TypeScript to improve the type-checking process, and not converted to JavaScript code.</p>
<p>Here's an example of an interface describing generic <strong>Text</strong> component:</p>
<pre><code class="language-ts">interface TextComponent {

    text: string;
    render(): void;

}
</code></pre>
<p>Now you can use the interface above to describe the requirement of having the <strong>text</strong> property that is a string and a <strong>render</strong> method:</p>
<pre><code class="language-ts">class PlainTextComponent implements TextComponent {

    text: string;

    render() {
        console.log('rendering plain text component');
    }

}
</code></pre>
<p>We are using <code>implements</code> keyword to wire class with a particular interface.
It is not important in what order class members are defined as long as all properties and methods the interface requires
are present and have required types.</p>
<p>Let's create another class that implements <code>TextComponent</code> interface partially:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent {
    text: string;
}
</code></pre>
<p>Upon compilation TypeScript will produce the following error:</p>
<pre><code class="language-text">error TS2420: Class 'RichTextComponent' incorrectly implements interface 'TextComponent'.
Property 'render' is missing in type 'RichTextComponent'.
</code></pre>
<p>You can use multiple interfaces delimited by a comma:</p>
<pre><code class="language-ts">class RichTextComponent implements TextComponent, OnInit, OnDestroy {
    // ...
}
</code></pre>
<p>The example above shows a class that must implement three different interfaces to compile.</p>
<h2 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h2>
<p>Interfaces describe only requirements for classes; you cannot create an instance of the interface.
You need <code>abstract</code> classes un order to provide implementation details.</p>
<pre><code class="language-ts">abstract class PageComponent {

    abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Same as with interfaces you cannot create instances of abstract classes directly, only other classes derived from an abstract one.
Also, it is possible marking class methods as <code>abstract</code>.
Abstract methods do not contain implementation, and similar to <code>interface</code> methods provide requirements for derived classes.</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Note how <code>HomePageComponent</code> implements abstract <code>renderContent</code> that has access to <code>renderHeader</code> and <code>renderFooter</code> methods carried out in the parent class.</p>
<p>You can also use access modifiers with abstract methods.
The most frequent scenario is when methods need to be accessible only from within the child classes, and invisible from the outside:</p>
<p>For example:</p>
<pre><code class="language-ts">abstract class PageComponent {

    protected abstract renderContent(): void;

    renderHeader() {
        // ...
    }

    renderFooter() {
        // ...
    }
}
</code></pre>
<p>Now <code>HomePageComponent</code> can make <code>renderContent</code> protected like shown below:</p>
<pre><code class="language-ts">class HomePageComponent extends PageComponent {

    constructor() {
        super();
        this.renderContent();
    }

    protected renderContent() {
        this.renderHeader();
        console.log('rendering home page');
        this.renderFooter();
    }

}
</code></pre>
<p>Any additional class that inherits (extends) <code>HomePageComponent</code> will still be able calling or redefining <code>renderContent</code> method.
But if you try accessing <code>renderContent</code> from outside the TypeScript should raise the following error:</p>
<pre><code class="language-ts">let homePage = new HomePageComponent();
homePage.renderContent();
// error TS2445: Property 'renderContent' is protected and only 
// accessible within class 'HomePageComponent' and its subclasses.
</code></pre>
<p>Abstract classes is a great way consolidating common functionality in a single place.</p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<p>TypeScript supports the concept of modules introduced in ES6.
Modules allow isolating code and data and help splitting functionality into logical groups.</p>
<p>One of the major features of ES6 (and TypeScript) modules is their file scope.
The code inside the module (classes, variables, functions, and other) does not pollute global scope
and is not accessible from the outside unless <code>exported</code> explicitly.</p>
<p>To share the code of the module with the outside world, you use <code>export</code> keyword:</p>
<pre><code class="language-ts">// module1.ts
export class TextBoxComponent {
  constructor(public text: string) {}
    
  render() {
    console.log(`Rendering '${this.text}' value.`);
  }
}
</code></pre>
<p>To use this code in your main application file or another module, you must import it first.
You import the <code>TextBoxComponent</code> class using <code>import</code> keyword:</p>
<pre><code class="language-ts">// app.ts
import { TextBoxComponent } from './module1'

let textBox = new TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="module-loaders"><a class="header" href="#module-loaders">Module Loaders</a></h3>
<p>ES6 and TypeScript rely on <code>module loaders</code> to locate files, resolve external dependencies and execute module files.</p>
<p>The most popular module loaders are:</p>
<ul>
<li>Server side
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used by Node.js)</li>
</ul>
</li>
<li>Client side
<ul>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li><a href="https://webpack.js.org/">Webpack</a></li>
</ul>
</li>
</ul>
<p>TypeScript supports different formats of generated JavaScript output.
You can instruct compiler to generate code adopted for multiple module loading systems using formats such as</p>
<ul>
<li><a href="http://www.commonjs.org/">CommonJs</a> (used in Node.js)</li>
<li><a href="https://requirejs.org/">RequireJS</a></li>
<li>UMD (Universal Module Definition)</li>
<li><a href="https://github.com/systemjs/systemjs">SystemJS</a></li>
<li>ES6 (or ECMAScript 2015)</li>
</ul>
<h3 id="running-at-server-side"><a class="header" href="#running-at-server-side">Running at server side</a></h3>
<p>You can test <code>TextBoxComponent</code> we have created earlier with node.js using <code>commonjs</code> module target:</p>
<pre><code class="language-sh">tsc app.ts --module commonjs
node app.js
</code></pre>
<p>When executed it produces the following output:</p>
<pre><code class="language-text">Rendering 'hello world' value.
</code></pre>
<p>TypeScript automatically compiles referenced modules.
It starts with <code>app.ts</code>, resolves and compiles <code>module1</code> as <code>module1.ts</code> file,
and produces two JavaScript files <code>app.js</code> and <code>module.js</code> that can be executed by node.js.</p>
<p>Here's an example of <code>app.js</code> file content:</p>
<pre><code class="language-js">&quot;use strict&quot;;
// app.ts
var module1_1 = require(&quot;./module1&quot;);
var textBox = new module1_1.TextBoxComponent('hello world');
textBox.render();
</code></pre>
<h3 id="running-in-browser"><a class="header" href="#running-in-browser">Running in browser</a></h3>
<p>In order to run module-based application in browser you can take <code>SystemJS</code> loader:</p>
<pre><code class="language-html">&lt;script src=&quot;systemjs/dist/system.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  SystemJS.import('/app/app.js');
&lt;/script&gt;
</code></pre>
<p>Let's take a look at a simple TypeScript application that references an external module.</p>
<pre><code class="language-ts">// logger.ts
export class Logger {

  output: any;

  constructor(outputId: string) {
    this.output = document.getElementById(outputId);
  }

  info(message: string) {
    this.output.innerText = `INFO: ${message}`;
  }

}
</code></pre>
<p>Our simple <code>logger</code> is going to put a message as a content of the document element provided from the outside.</p>
<pre><code class="language-ts">// app.ts
import { Logger } from './logger';

let logger = new Logger('content');
logger.info('hello world');
</code></pre>
<p>The application needs to be compiled with SystemJS support to load correctly.
You can configure TypeScript to generate compatible JavaScript code by setting module code generation setting to <code>system</code>:</p>
<pre><code class="language-sh">tsc app.ts --module system
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find source code for the examples above in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/typescript/systemjs-example">typescript/systemjs-example</a>&quot; folder.</p>
</blockquote>
<p>To install dependencies, compile and run the demo use the following commands:</p>
<pre><code class="language-sh">npm install
npm start
</code></pre>
<p>Your default browser should run example page automatically.
Once the page gets loaded you should see an expected message:</p>
<pre><code class="language-text">INFO: hello world
</code></pre>
<h2 id="decorators"><a class="header" href="#decorators">Decorators</a></h2>
<p>TypeScript introduces <code>decorators</code> feature, metadata expressions similar to Java annotation tags or C# and Swift attributes.
ECMAScript does not yet have native support for annotating classes and class members (the feature is in the <code>proposal</code> state),
so <code>decorators</code> is an experimental TypeScript feature.</p>
<p>Decorators have a traditional notation of <code>@expression</code> where <code>expression</code> is the name of the function that should be invoked at runtime.</p>
<p>This function receives <code>decorated</code> target as a parameter and can be attached to:</p>
<ul>
<li>class declaration</li>
<li>method</li>
<li>accessor</li>
<li>property</li>
<li>parameter</li>
</ul>
<h3 id="class-decorators"><a class="header" href="#class-decorators">Class Decorators</a></h3>
<p>Class decorators are attached to class declarations.
At runtime, the function that backs the decorator gets applied to the class constructor.
That allows decorators inspecting, modifying or even replacing class instances if needed.</p>
<p>Here's a simple example of the <code>LogClass</code> decorator that outputs some log information every time being invoked:</p>
<pre><code class="language-ts">function LogClass(constructor: Function) {
    console.log('LogClass decorator executed for the constructor:');
    console.log(constructor);
}
</code></pre>
<p>Now you can use newly created decorator with different classes:</p>
<pre><code class="language-ts">@LogClass
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}
</code></pre>
<p>When a new instance of <code>TextWidget</code> class is created, the <code>@LogClass</code> attribute will be automatically invoked:</p>
<pre><code class="language-ts">let widget = new TextWidget();
widget.render();
</code></pre>
<p>The class decorator should produce the following output:</p>
<pre><code class="language-text">LogClass decorator executed for the constructor:
[Function: TextWidget]
Rendering text: default text
</code></pre>
<h4 id="decorators-with-parameters"><a class="header" href="#decorators-with-parameters">Decorators with parameters</a></h4>
<p>It is also possible passing values to decorators. You can achieve this with a feature known as <code>decorator factories</code>.
A <em>decorator factory</em> is a function returning an expression that is called at runtime:</p>
<p>Let's create another simple decorator with log output that accepts additional <code>prefix</code> and <code>suffix</code> settings:</p>
<pre><code class="language-ts">function LogClassWithParams(prefix: string, suffix: string) {
    return (constructor: Function) =&gt; {
        console.log(`
            ${prefix} 
            LogClassWithParams decorator called for: 
            ${constructor} 
            ${suffix}
        `);
    };
}
</code></pre>
<p>It can now be tested with the <code>TextWidget</code> class created earlier:</p>
<pre><code class="language-ts">@LogClassWithParams('BEGIN:', ':END')
class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>You have marked <code>TextWidget</code> class with the <code>LogClassWithParams</code> decorator having a <code>prefix</code> and <code>suffix</code> properties
set to <code>BEGIN:</code> and <code>:END</code> values. The console output, in this case, should be:</p>
<pre><code class="language-text">BEGIN:
LogClassWithParams decorator called for: 
function TextWidget(text) {
    if (text === void 0) { text = 'default text'; }
        this.text = text;
    }
}
:END
</code></pre>
<h4 id="multiple-decorators"><a class="header" href="#multiple-decorators">Multiple decorators</a></h4>
<p>You are not limited to a single decorator per class.
TypeScript allows declaring as much class and member decorators as needed:</p>
<pre><code class="language-ts">@LogClass
@LogClassWithParams('BEGIN:', ':END')
@LogClassWithParams('[', ']')
class TextWidget {
    // ...
}
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
It means that first decorator that gets executed is:</p>
<pre><code class="language-ts">@LogClassWithParams('[', ']')
</code></pre>
<p>and the last decorator is going to be</p>
<pre><code class="language-ts">@LogClass
</code></pre>
<h3 id="method-decorators"><a class="header" href="#method-decorators">Method Decorators</a></h3>
<p>Method decorators are attached to class methods and can be used to inspect, modify or completely replace method definition of the class.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Let's create a decorator to inspect those parameters:</p>
<pre><code class="language-ts">function LogMethod(target: any, 
                   propertyKey: string, 
                   descriptor: PropertyDescriptor) {
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Below is an example of this decorator applied to a <code>render</code> method of <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethod
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>The console output in this case will be as following:</p>
<pre><code class="language-text">TextWidget { render: [Function] }
render
{ value: [Function],
  writable: true,
  enumerable: true,
  configurable: true }
Rendering text: default text
</code></pre>
<p>You can use <code>decorator factories</code> also with method decorators to support additional parameters.</p>
<pre><code class="language-ts">function LogMethodWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`${propertyKey}: ${message}`);
    };
}
</code></pre>
<p>This decorator can now be applied to methods. You can attach multiple decorators to a single method:</p>
<pre><code class="language-ts">class TextWidget {
    text: string;

    constructor(text: string = 'default text') {
        this.text = text;
    }

    @LogMethodWithParams('hello')
    @LogMethodWithParams('world')
    render() {
        console.log(`Rendering text: ${this.text}`);
    }
}

let widget = new TextWidget();
widget.render();
</code></pre>
<p>Note that decorators are called from right to left, or in this case from bottom to top.
If you run the code the output should be as follows:</p>
<pre><code class="language-text">render: world
render: hello
Rendering text: default text
</code></pre>
<h3 id="accessor-decorators"><a class="header" href="#accessor-decorators">Accessor Decorators</a></h3>
<p>Accessor decorators are attached to property <code>getters</code> or <code>setters</code> and can be used to inspect, modify or completely replace accessor definition of the property.
At runtime, these decorators receive following values as parameters: target instance, member name and member descriptor.</p>
<p>Note that you can attach accessor decorator to either <code>getter</code> or <code>setter</code> but not both.
This restriction exists because on the low level decorators deal with
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Property Descriptors</a>
that contain both <code>get</code> and <code>set</code> accessors.</p>
<p>Let's create a decorator to inspect parameters:</p>
<pre><code class="language-ts">function LogAccessor(target: any, 
                     propertyKey: string, 
                     descriptor: PropertyDescriptor) {
    console.log('LogAccessor decorator called');
    console.log(target);
    console.log(propertyKey);
    console.log(descriptor);
}
</code></pre>
<p>Now the decorator can be applied to the following <code>TextWidget</code> class:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessor
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>Once invoked the decorator should produce the following output:</p>
<pre><code class="language-text">LogAccessor decorator called
TextWidget { text: [Getter/Setter] }
text
{ get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true }
</code></pre>
<p>Same as with class and method decorators you can use decorator factories feature to pass parameters to your accessor decorator.</p>
<pre><code class="language-ts">function LogAccessorWithParams(message: string) {
    return (target: any, 
            propertyKey: string, 
            descriptor: PropertyDescriptor) =&gt; {
        console.log(`Message from decorator: ${message}`);
    }
}
</code></pre>
<p>TypeScript allows using more than one decorator given you attach it to the same property accessor:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    @LogAccessorWithParams('world')
    get text(): string {
        return this._text;
    }

    set text(value: string) {
        this._text = value;
    }

    constructor(text: string = 'default text') {
        this._text = text;
    }
}

let widget = new TextWidget();
</code></pre>
<p>The console output should be as shown below, note the right-to-left execution order:</p>
<pre><code class="language-text">Message from decorator: world
Message from decorator: hello
</code></pre>
<p>In case you declare decorator for both accessors TypeScript generates an error at compile time:</p>
<pre><code class="language-ts">class TextWidget {
    private _text: string;

    @LogAccessorWithParams('hello')
    get text(): string {
        return this._text;
    }
    
    @LogAccessorWithParams('world')
    set text(value: string) {
        this._text = value;
    }
}
</code></pre>
<pre><code class="language-text">error TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.
</code></pre>
<h3 id="property-decorators"><a class="header" href="#property-decorators">Property Decorators</a></h3>
<p>Property decorators are attached to class properties.
At runtime, property decorator receives the following arguments:</p>
<ul>
<li>target object</li>
<li>property name</li>
</ul>
<p>Due to technical limitations, it is not currently possible observing or modifying property initializers.
That is why property decorators do not get Property Descriptor value at runtime
and can be used mainly to observe a property with a particular name has been defined for a class.</p>
<p>Here's a simple property decorator to display parameters it gets at runtime:</p>
<pre><code class="language-ts">function LogProperty(target: any, propertyKey: string) {
    console.log('LogProperty decorator called');
    console.log(target);
    console.log(propertyKey);
}
</code></pre>
<pre><code class="language-ts">class TextWidget {

    @LogProperty
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    render() {
        // ...
    }
}

let widget = new TextWidget('text1');
</code></pre>
<p>The output in this case should be as following:</p>
<pre><code class="language-text">LogProperty decorator called
TextWidget { render: [Function] }
id
</code></pre>
<h3 id="parameter-decorators"><a class="header" href="#parameter-decorators">Parameter Decorators</a></h3>
<p>Parameter decorators are attached to function parameters.
At runtime, every parameter decorator function is called with the following arguments:</p>
<ul>
<li>target</li>
<li>parameter name</li>
<li>parameter position index</li>
</ul>
<p>Due to technical limitations, it is possible only detecting that a particular parameter has been declared on a function.</p>
<p>Let's inspect runtime arguments with this simple parameter decorator:</p>
<pre><code class="language-ts">function LogParameter(target: any, 
                      parameterName: string, 
                      parameterIndex: number) {
    console.log('LogParameter decorator called');
    console.log(target);
    console.log(parameterName);
    console.log(parameterIndex);
}
</code></pre>
<p>You can now use this decorator with a class constructor and method parameters:</p>
<pre><code class="language-ts">class TextWidget {

    render(@LogParameter positionX: number, 
           @LogParameter positionY: number) {
        // ...
    }

}
</code></pre>
<p>Parameter decorators are also executed in right-to-left order.
So you should see console outputs for <code>positionY</code> and then <code>positionX</code>:</p>
<pre><code class="language-text">LogParameter decorator called
TextWidget { render: [Function] }
render
1
LogParameter decorator called
TextWidget { render: [Function] }
render
0
</code></pre>
<h1 id="angular-cli"><a class="header" href="#angular-cli">Angular CLI</a></h1>
<p>The <a href="https://cli.angular.io">Angular CLI</a> is a command line interface for Angular.</p>
<p><img src="images/cli-logo.png" alt="Angular CLI" /></p>
<p>As you might have noticed from the previous chapters, creating a project structure for a new web app may be a non-trivial task.
Working with multiple projects or frequently creating new ones may become extremely time-consuming
as you need configuring project structure again and again.</p>
<blockquote>
<p>The Angular CLI makes it easy to create an application that already works, right out of the box.
It already follows our best practices!</p>
</blockquote>
<p>This command line tool automates and simplifies many common scenarios, including:</p>
<ul>
<li>create new project structure from scratch with most optimal configuration out of the box</li>
<li>scaffold common Angular building blocks using one of the various blueprints (components, directives, pipes, services and other)</li>
<li>serving, watching and live reload</li>
<li>code linting</li>
<li>unit testing, code coverage reports, and end-to-end testing</li>
<li>development and production builds</li>
</ul>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<pre><code class="language-sh">npm install -g @angular/cli
</code></pre>
<p>The tool installs globally and is available via <code>ng</code> command.
Angular CLI supports lots of features; you can view details on available commands with the <code>help</code> command:</p>
<pre><code class="language-sh">ng help
</code></pre>
<h2 id="your-first-application"><a class="header" href="#your-first-application">Your First Application</a></h2>
<p>To create a new application you should use <code>ng new &lt;project-name&gt;</code> command:</p>
<pre><code class="language-sh">ng new my-first-app
</code></pre>
<p>The <code>ng</code> tool should produce console output similar to the following one:</p>
<pre><code class="language-text">installing ng
  create .editorconfig
  create README.md
  create src/app/app.component.css
  create src/app/app.component.html
  create src/app/app.component.spec.ts
  create src/app/app.component.ts
  create src/app/app.module.ts
  create src/assets/.gitkeep
  create src/environments/environment.prod.ts
  create src/environments/environment.ts
  create src/favicon.ico
  create src/index.html
  create src/main.ts
  create src/polyfills.ts
  create src/styles.css
  create src/test.ts
  create src/tsconfig.app.json
  create src/tsconfig.spec.json
  create src/typings.d.ts
  create .angular-cli.json
  create e2e/app.e2e-spec.ts
  create e2e/app.po.ts
  create e2e/tsconfig.e2e.json
  create .gitignore
  create karma.conf.js
  create package.json
  create protractor.conf.js
  create tsconfig.json
  create tslint.json
Successfully initialized git.
Installing packages for tooling via npm.
Installed packages for tooling via npm.
You can `ng set --global packageManager=yarn`.
Project 'my-first-app' successfully created.
</code></pre>
<p>The <code>scripts</code> section of the <code>package.json</code> file should point to <code>ng</code> tool for all the actions:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;ng&quot;: &quot;ng&quot;,
        &quot;start&quot;: &quot;ng serve&quot;,
        &quot;build&quot;: &quot;ng build&quot;,
        &quot;test&quot;: &quot;ng test&quot;,
        &quot;lint&quot;: &quot;ng lint&quot;,
        &quot;e2e&quot;: &quot;ng e2e&quot;
    }
}
</code></pre>
<h2 id="running-application"><a class="header" href="#running-application">Running Application</a></h2>
<p>Now switch to the newly generated <code>my-first-app</code> folder and launch the app:</p>
<pre><code class="language-sh">cd my-first-app/
ng serve
</code></pre>
<p>The <code>ng serve</code> command compiles and serves entire project using <code>webpack</code> bundler with an output similar to following:</p>
<pre><code class="language-text">** NG Live Development Server is running on http://localhost:4200 **
Hash: 2c5e702e0dbbc24e055c
Time: 10564ms
chunk    {0} polyfills.bundle.js, polyfills.bundle.js.map (polyfills) 158 kB {4} [initial] [rendered]
chunk    {1} main.bundle.js, main.bundle.js.map (main) 3.62 kB {3} [initial] [rendered]
chunk    {2} styles.bundle.js, styles.bundle.js.map (styles) 9.77 kB {4} [initial] [rendered]
chunk    {3} vendor.bundle.js, vendor.bundle.js.map (vendor) 2.37 MB [initial] [rendered]
chunk    {4} inline.bundle.js, inline.bundle.js.map (inline) 0 bytes [entry] [rendered]
webpack: Compiled successfully.
</code></pre>
<p>It is important to note that with <code>ng serve</code> you are going to run your project with <code>live development server</code>.
The server is going to watch for code changes, rebuild all affected bundles and reload the browser.</p>
<p>Now if you navigate to <code>http://localhost:4200</code> you should see the following default text:</p>
<pre><code class="language-text">app works!
</code></pre>
<p>Alternatively, you can run <code>serve</code> command with the <code>--open</code> switch to automatically open system browser with the application once compilation is complete:</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>It is also possible configuring default <code>host</code> and <code>port</code> settings:</p>
<pre><code class="language-sh">ng serve --host 0.0.0.0 --port 3000
</code></pre>
<p>The command above allows accessing your application from the local machine and local network via port 3000.</p>
<p>There are plenty of options and switches that can be used with <code>ng serve</code> command; you can refer to full details by calling <code>ng help</code>.</p>
<h2 id="code-linting"><a class="header" href="#code-linting">Code Linting</a></h2>
<p>Checking code is one of the essential steps.
Angular CLI ships with the TSLint support and predefined set of rules in the <code>tsconfig.json</code> file.</p>
<pre><code class="language-sh">ng lint
</code></pre>
<p>Default auto-generated project should contain no errors. You should see the following result in the console:</p>
<pre><code class="language-text">All files pass linting.
</code></pre>
<p>Let's try to ensure TSLint works as expected by modifying the <code>/src/app/app.component.ts</code> file.
Just change single quotes with double quotes like below:</p>
<pre><code class="language-ts">export class AppComponent {
  title = &quot;app works!&quot;;
}
</code></pre>
<p>Now running <code>ng lint</code> should produce next output:</p>
<pre><code class="language-text">src/app/app.component.ts[9, 11]: &quot; should be '
Lint errors found in the listed files.
</code></pre>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>You get a predefined unit testing configuration with every generated project.
By default, you are going to use <code>Karma</code> runner with the <code>Jasmine</code> test framework.</p>
<pre><code class="language-sh">ng test
</code></pre>
<p><img src="images/unit-tests.png" alt="Unit tests" /></p>
<p>Tests run in <code>watch</code> mode, meaning they automatically re-run upon code changes.</p>
<p><em>Please note that out-of-box configuration requires Google Chrome browser to run tests,
via the <code>karma-chrome-launcher</code> plugin.</em></p>
<p>As per Angular code style guides, all the unit test files reside next to the components tested.
The Angular CLI generates three dummy tests in the <code>src/app/app.component.spec.ts</code>:</p>
<pre><code class="language-ts">it('should create the app', async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  const app = fixture.debugElement.componentInstance;
  
  expect(app).toBeTruthy();
}));

it(`should have as title 'app works!'`, async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  const app = fixture.debugElement.componentInstance;
  
  expect(app.title).toEqual('app works!');
}));

it('should render title in a h1 tag', async(() =&gt; {
  const fixture = TestBed.createComponent(AppComponent);
  fixture.detectChanges();
  
  const compiled = fixture.debugElement.nativeElement;
  expect(compiled.querySelector('h1').textContent).toContain('app works!');
}));
</code></pre>
<p>Let's check what happens when a test fails.</p>
<p>Append the following code to the end of the &quot;app.component.spec.ts&quot;:</p>
<pre><code class="language-ts">it('should fail', () =&gt; {
  expect(true).toBe(false);
});
</code></pre>
<p>Now if you run <code>ng test</code> once again you should see the following report:</p>
<p><img src="images/failed-test-details.png" alt="Failed test" /></p>
<p>There are two tabs on the page: <strong>Spec List</strong> and <strong>Failures</strong>.
You should see <strong>Failures</strong> by default but if there's more than one unit test failed you can check them on the <strong>Spec List</strong> page:</p>
<p><img src="images/failed-test-spec-list.png" alt="Spec List" /></p>
<p>If you do not plan to debug tests and just want to see a quick result of the test run just add <code>--single-run</code> switch to the <code>test</code> command:</p>
<pre><code class="language-sh">ng test --single-run
</code></pre>
<p>Developers typically use single run configurations for continuous integration (CI) scenarios.</p>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code Coverage</a></h2>
<p>You can generate a coverage report for your unit tests by adding <code>--code-coverage</code> switch to the <code>test</code> command:</p>
<pre><code class="language-sh">ng test --single-run --code-coverage
</code></pre>
<p>Under the hood the <code>ng</code> tool performs the following actions:</p>
<ul>
<li>compile the project with webpack, including TypeScript transpilation with source maps</li>
<li>use Karma runner and Jasmine to execute unit tests</li>
<li>remap code coverage report for JavaScript back to TypeScript</li>
<li>generate HTML report within <code>coverage</code> folder</li>
</ul>
<p>After testing finishes you can either open <code>coverage/index.html</code> with your favorite browser.</p>
<p>For example:</p>
<pre><code class="language-sh">open ./coverage/index.html
</code></pre>
<p>The command above should serve your coverage report and automatically launches default browser with the main page.</p>
<p><img src="images/code-coverage-main.png" alt="Code Coverage" /></p>
<p>Click the <code>src/app</code> and then <code>app.component.ts</code> to see TypeScript coverage:</p>
<p><img src="images/code-coverage-single-file.png" alt="Code Coverage for single file" /></p>
<h2 id="development-and-production-builds"><a class="header" href="#development-and-production-builds">Development and Production builds</a></h2>
<p>The Angular CLI supports producing both <code>development</code> and <code>production</code> using the <code>build</code> command:</p>
<pre><code class="language-sh">ng build
</code></pre>
<p>The format of the command is:</p>
<pre><code class="language-sh">ng build &lt;options...&gt;
</code></pre>
<p>By default it is running in <code>development</code> mode (an equivalent of <code>ng build -dev</code>) and produces output to the <code>dist/</code> folder.
You will get bundles together with source maps for better debugging:</p>
<table><thead><tr><th>File</th><th>Size</th></tr></thead><tbody>
<tr><td>favicon.ico</td><td>5430</td></tr>
<tr><td>index.html</td><td>613</td></tr>
<tr><td>inline.bundle.js</td><td>5764</td></tr>
<tr><td>inline.bundle.js.map</td><td>5824</td></tr>
<tr><td>main.bundle.js</td><td>6539</td></tr>
<tr><td>main.bundle.js.map</td><td>3817</td></tr>
<tr><td>polyfills.bundle.js</td><td>169209</td></tr>
<tr><td>polyfills.bundle.js.map</td><td>204535</td></tr>
<tr><td>styles.bundle.js</td><td>10039</td></tr>
<tr><td>styles.bundle.js.map</td><td>13372</td></tr>
<tr><td>vendor.bundle.js</td><td>2884505</td></tr>
<tr><td>vendor.bundle.js.map</td><td>3081499</td></tr>
</tbody></table>
<p>For production purposes you will want using the following command:</p>
<pre><code class="language-sh">ng build -prod
</code></pre>
<p>Which is an equivalent of the:</p>
<pre><code class="language-sh">ng build --target=production
</code></pre>
<p>This will give you much smaller output:</p>
<table><thead><tr><th>File</th><th>Size</th></tr></thead><tbody>
<tr><td>favicon.ico</td><td>5430</td></tr>
<tr><td>inline.d72284a6a83444350a39.bundle.js</td><td>1460</td></tr>
<tr><td>main.e088c8ce83e51568eb21.bundle.js</td><td>12163</td></tr>
<tr><td>polyfills.f52c146b4f7d1751829e.bundle.js</td><td>58138</td></tr>
<tr><td>styles.d41d8cd98f00b204e980.bundle.css</td><td>0</td></tr>
<tr><td>vendor.a2da17b9c49cdce7678a.bundle.js</td><td>362975</td></tr>
</tbody></table>
<p>Please note that <code>styles</code> bundle will be empty because by default newly generated app has <code>src/styles.css</code> file empty.</p>
<p>The <code>ng</code> tool removes <code>dist</code> folder between the builds so you should not worry about files left from previous builds and modes.</p>
<p>The content of the <code>dist</code> folder is everything you need to deploy your application to the remote server.
You can also use any web server of your choice to run the application in production.</p>
<p>For example:</p>
<ul>
<li>Nginx server</li>
<li>Tomcat server</li>
<li>IIS server</li>
<li>and many others</li>
</ul>
<p>In addition, you can deploy your application to any static pages host, like:</p>
<ul>
<li><a href="https://pages.github.com/">GitHub pages</a></li>
<li><a href="https://www.netlify.com/">Netlify</a></li>
<li>and many others</li>
</ul>
<p>It is still possible to use Angular CLI and embedded development server to test production builds.
You can use the following command to build the app in production mode and then run and open default browser to check it:</p>
<pre><code class="language-sh">ng serve --prod --open
</code></pre>
<h2 id="using-blueprints"><a class="header" href="#using-blueprints">Using blueprints</a></h2>
<p>Besides generating new application project structure, the <code>ng</code> tool supports creating core Angular building blocks
be means of <code>generate</code> (or <code>g</code>) command and several <code>blueprints</code>.</p>
<pre><code class="language-sh">ng generate &lt;blueprint&gt; &lt;options...&gt;
</code></pre>
<p>For the time being Angular CLI supports the following set of blueprints out-of-box:</p>
<table><thead><tr><th>Blueprint name</th><th>Command line usage</th></tr></thead><tbody>
<tr><td>Component</td><td>ng g component my-new-component</td></tr>
<tr><td>Directive</td><td>ng g directive my-new-directive</td></tr>
<tr><td>Pipe</td><td>ng g pipe my-new-pipe</td></tr>
<tr><td>Service</td><td>ng g service my-new-service</td></tr>
<tr><td>Class</td><td>ng g class my-new-class</td></tr>
<tr><td>Guard</td><td>ng g guard my-new-guard</td></tr>
<tr><td>Interface</td><td>ng g interface my-new-interface</td></tr>
<tr><td>Enum</td><td>ng g enum my-new-enum</td></tr>
<tr><td>Module</td><td>ng g module my-module</td></tr>
</tbody></table>
<p>Let's assume you have generated a new <code>my-first-app</code> like suggested below:</p>
<pre><code class="language-sh">ng new my-first-app
cd my-first-app
</code></pre>
<p>Now to create a new component, you should be using  the following command:</p>
<pre><code class="language-sh">ng g component my-first-component
</code></pre>
<p>The <code>ng</code> tool takes your current directory and creates all component related files:</p>
<pre><code class="language-text">installing component
  create src/app/my-first-component/my-first-component.component.css
  create src/app/my-first-component/my-first-component.component.html
  create src/app/my-first-component/my-first-component.component.spec.ts
  create src/app/my-first-component/my-first-component.component.ts
  update src/app/app.module.ts
</code></pre>
<p>If you are running <code>ng generate</code> command (or <code>ng g</code> by alias) from the root of your project,
the CLI should automatically put content to <code>src/app/&lt;feature&gt;</code> folder like shown above.</p>
<p>You can also specify additional folder structure that should become relative to <code>src/app</code> during generation.
All missing directories get created automatically.</p>
<p>Run the following command from the root project folder:</p>
<pre><code class="language-sh">ng g service services/simple-service
</code></pre>
<p>The <code>ng</code> tool creates <code>src/app/services</code> path and puts <code>simple-service</code> implementation there:</p>
<pre><code class="language-text">installing service
  create src/app/services/simple-service.service.spec.ts
  create src/app/services/simple-service.service.ts
  WARNING Service is generated but not provided, it must be provided to be used
</code></pre>
<p>Finally, you can change current directory and generate Angular artifacts there:</p>
<pre><code class="language-sh">mkdir src/app/directives
cd src/app/directives/
ng g directive my-first-directive
</code></pre>
<p>In this case, you should see get following output:</p>
<pre><code class="language-text">installing directive
  create src/app/directives/my-first-directive.directive.spec.ts
  create src/app/directives/my-first-directive.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>All blueprints follow common Angular code style guides.
You get a separate folder and all files one should expect when starting with a new Angular component:</p>
<ul>
<li>code file (<code>&lt;component&gt;.ts</code>)</li>
<li>external template file (<code>&lt;component&gt;.html</code>)</li>
<li>external css file (<code>&lt;component&gt;.css</code>)</li>
<li>unit test file (<code>&lt;component&gt;.spec.ts</code>)</li>
</ul>
<p>One of the best features of Angular CLI is that you do not get just placeholder files but a valid ready to use artefact and unit tests.
Let's peek inside <code>MyFirstComponent</code> component we have created earlier, and try integrating into the application.</p>
<pre><code class="language-ts">import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-my-first-component',
  templateUrl: './my-first-component.component.html',
  styleUrls: ['./my-first-component.component.css']
})
export class MyFirstComponentComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
</code></pre>
<p>You get <code>app-my-first-component</code> selector, external template and style,
together with a constructor and <code>OnInit</code> placeholder to save your time.</p>
<p>The stylesheet file (<strong>my-first-component.component.css</strong>) is empty by default,
and template file (<strong>my-first-component.component.html</strong>) contains the following simple layout:</p>
<pre><code class="language-html">&lt;p&gt;
  my-first-component works!
&lt;/p&gt;
</code></pre>
<p>The CLI will even update <code>src/app/app.module.ts</code> to include your newly created component into the application module:</p>
<pre><code class="language-ts">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppComponent } from './app.component';
import { MyFirstComponentComponent } from './my-first-component/my-first-component.component';

@NgModule({
  declarations: [
    AppComponent,
    MyFirstComponentComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>To test the generated component you can use main application template:</p>
<pre><code class="language-html">&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;app-my-first-component&gt;
&lt;/app-my-first-component&gt;
</code></pre>
<p>Finally, you can run development server if it is not running already:</p>
<pre><code class="language-sh">ng serve
</code></pre>
<p><img src="images/ng-cli-component.png" alt="Angular CLI component" /></p>
<p>As a starting point you also get a simple ready-to-run unit test for your component:</p>
<pre><code class="language-ts">import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyFirstComponentComponent } from './my-first-component.component';

describe('MyFirstComponentComponent', () =&gt; {
  let component: MyFirstComponentComponent;
  let fixture: ComponentFixture&lt;MyFirstComponentComponent&gt;;

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ MyFirstComponentComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyFirstComponentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () =&gt; {
    expect(component).toBeTruthy();
  });
});
</code></pre>
<p>As mentioned earlier you can run unit tests in <code>watch</code> mode with the help of <code>ng test</code> command:</p>
<p><img src="images/ng-cli-component-test.png" alt="Component Test" /></p>
<p>If you have added your component to the <code>app.component.html</code> template, some unit tests may fail.
To fix them you should update test configuration in <code>app.component.spec.ts</code>
and include your component into the test module:</p>
<pre><code class="language-ts">import { TestBed, async } from '@angular/core/testing';

import { AppComponent } from './app.component';
import { MyFirstComponentComponent } from './my-first-component/my-first-component.component';

describe('AppComponent', () =&gt; {
  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
        MyFirstComponentComponent
      ],
    }).compileComponents();
  }));

  ...
});
</code></pre>
<h2 id="creating-modules"><a class="header" href="#creating-modules">Creating Modules</a></h2>
<p>The Angular CLI tool also provides support for multiple modules
and generating entities that belong to the particular module.</p>
<p>Let's start by generating a new module using the next command:</p>
<pre><code class="language-sh">ng g module my-components
</code></pre>
<p>The output in the console should look similar to the following:</p>
<pre><code class="language-text">create src/app/my-components/my-components.module.ts (196 bytes)
</code></pre>
<p>And the content of the module contains a basic implementation like in the example below:</p>
<pre><code class="language-ts">// src/app/my-components/my-components.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: []
})
export class MyComponentsModule { }
</code></pre>
<p>Note that by default Angular creates a folder for your module, similar to what it does for components.
This is handy once you create components, services, directives and pipes that need to belongÂ to this module.
But if you want to put the resulting module in a single file next to the &quot;app.module.ts&quot; use the &quot;--flat&quot; switch.</p>
<pre><code class="language-sh">ng g module my-components --flat
</code></pre>
<p>In that case, the output will be:</p>
<pre><code class="language-text">create src/app/my-components.module.ts (196 bytes)
</code></pre>
<p>You can check more details on the available switches by running the &quot;ng g module --help&quot; command.</p>
<h3 id="assigning-components-to-modules"><a class="header" href="#assigning-components-to-modules">Assigning components to modules</a></h3>
<p>By default, Angular CLI appends all generated content to the main application module inside &quot;app.module.ts&quot;.
Once you have two or more modules in the application, the CLI will require the module name for every new content.</p>
<p>Try running the following command to see what happens:</p>
<pre><code class="language-sh">ng g component my-button-1
</code></pre>
<p>The output should be similar to the following one:</p>
<pre><code class="language-text">Error: More than one module matches.
Use skip-import option to skip importing the component into the closest module.
</code></pre>
<p>To include your new component into a particular module use the &quot;--module&quot; switch.
If you are building a shared module, you might also use the &quot;--export&quot; switch,
so that module exports your component besides declaration.</p>
<pre><code class="language-sh">ng g component my-button-1 --module=my-components --export
</code></pre>
<p>This time, you will get the following result:</p>
<pre><code class="language-text">  create src/app/my-button-1/my-button-1.component.css (0 bytes)
  create src/app/my-button-1/my-button-1.component.html (30 bytes)
  create src/app/my-button-1/my-button-1.component.spec.ts (651 bytes)
  create src/app/my-button-1/my-button-1.component.ts (287 bytes)
  update src/app/my-components.module.ts (321 bytes)
</code></pre>
<p>And the module content now looks like in the code example below:</p>
<pre><code class="language-ts">// src/app/my-components.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MyButton1Component } from './my-button-1/my-button-1.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [MyButton1Component],
  exports: [MyButton1Component]
})
export class MyComponentsModule { }
</code></pre>
<p>Do not forget to check the &quot;ng g component --help&quot; to see all available options.</p>
<p>You can also include your new module into some other existing module from the command line.</p>
<pre><code class="language-sh">ng g module my-feature --module=my-components --flat
</code></pre>
<p>As a result, the &quot;MyComponentsModule&quot; module will include &quot;MyFeatureModule&quot;:</p>
<pre><code class="language-ts">// src/app/my-components.module.ts

@NgModule({
  imports: [
    CommonModule,
    MyFeatureModule
  ],
  declarations: [MyButton1Component],
  exports: [MyButton1Component]
})
export class MyComponentsModule { }
</code></pre>
<h2 id="routing-support"><a class="header" href="#routing-support">Routing Support</a></h2>
<p>If you plan working with Angular Router or want to experiment with routing capabilities,
the Angular CLI can generate an application for you with initial Router support.</p>
<p>Use the &quot;--routing&quot; switch if you want to generate a routing module scaffold with your application.</p>
<pre><code class="language-sh">ng new my-app --routing
</code></pre>
<p>The routing scaffold should look similar to the one below:</p>
<pre><code class="language-ts">// src/app/app-routing.module.ts

import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
</code></pre>
<p>In addition, the main application component is going to contain the router outlet component:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<h2 id="generating-standalone-scripts"><a class="header" href="#generating-standalone-scripts">Generating Standalone Scripts</a></h2>
<p>The Angular CLI provides a special feature that allows detaching command line tools from the project,
and generating a set of scripts needed for standalone project compilation and testing:</p>
<pre><code class="language-sh">ng eject
</code></pre>
<p>Which is an equivalent for <code>ng eject -dev</code> or <code>ng eject --target=development</code>,
and instructs <code>ng</code> tool to use <code>development</code> configuration.
Alternatively, you can use <code>-prod</code> or <code>--target=production</code> switches to enable <code>production</code> mode.</p>
<p>Upon running <code>eject</code> command, the CLI will:</p>
<ul>
<li>update <code>package.json</code> with all dependencies needed to compile project without extra tools</li>
<li>generate and output the proper webpack configuration (<code>webpack.config.js</code>) and scripts for testing</li>
</ul>
<p>The tool might provide additional notes in the console output like below:</p>
<pre><code class="language-text">==============================================================
Ejection was successful.

To run your builds, you now need to do the following commands:
   - &quot;npm run build&quot; to build.
   - &quot;npm run test&quot; to run unit tests.
   - &quot;npm start&quot; to serve the app using webpack-dev-server.
   - &quot;npm run e2e&quot; to run protractor.

Running the equivalent CLI commands results in error.

==============================================================
Some packages were added. Please run &quot;npm install&quot;.
</code></pre>
<p>Now <code>scripts</code> section in your <code>package.json</code> file should link to local content for a <code>start</code>, <code>build</code> and various <code>test</code> scripts:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;ng&quot;: &quot;ng&quot;,
        &quot;start&quot;: &quot;webpack-dev-server --port=4200&quot;,
        &quot;build&quot;: &quot;webpack&quot;,
        &quot;test&quot;: &quot;karma start ./karma.conf.js&quot;,
        &quot;lint&quot;: &quot;ng lint&quot;,
        &quot;e2e&quot;: &quot;protractor ./protractor.conf.js&quot;,
        &quot;prepree2e&quot;: &quot;npm start&quot;,
        &quot;pree2e&quot;: &quot;webdriver-manager update --standalone false --gecko false --quiet&quot;
    }
}
</code></pre>
<h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components are the main building blocks in Angular.</p>
<p>A typical Angular application is represented by a tree of elements starting with a single root one.</p>
<pre><code class="language-html">&lt;app-root&gt;

    &lt;app-header title=&quot;My header&quot;&gt;
        &lt;!-- ... --&gt;
    &lt;/app-header&gt;

    &lt;app-layout type=&quot;horizontal&quot;&gt;

        &lt;app-sidebar&gt;
            &lt;!-- ... --&gt;
        &lt;/app-sidebar&gt;

        &lt;app-content&gt;
            &lt;!-- ... --&gt;
        &lt;/app-content&gt;

    &lt;/app-layout&gt;

    &lt;app-footer&gt;
        &lt;!-- ... --&gt;
    &lt;/app-footer&gt;

&lt;/app-root&gt;
</code></pre>
<p>As you can see from the markup above, our main application template consists at least of the following six components:</p>
<ul>
<li>app-root</li>
<li>app-header</li>
<li>app-layout</li>
<li>app-sidebar</li>
<li>app-content</li>
<li>app-footer</li>
</ul>
<p>Schematically it should look similar to the following:</p>
<p><img src="images/components-app-structure.png" alt="App Structure with Components" /></p>
<h2 id="creating-a-simple-component"><a class="header" href="#creating-a-simple-component">Creating a Simple Component</a></h2>
<p>Let's build a simple Angular component in the new &quot;basic-components&quot; project.</p>
<p>The easiest and quickest way to prepare a project structure is using Angular CLI to setup scaffold.</p>
<blockquote>
<p><strong>Angular CLI</strong></p>
<p>You can find detailed information on setting up project scaffolds in the <strong><a href="ch04-00-angular-cli.html">Angular CLI</a></strong> chapter.</p>
</blockquote>
<p>You start creating a component with importing the <code>@Component</code> decorator from the <code>@angular/core</code>:</p>
<pre><code class="language-ts">import { Component } from '@angular/core';
</code></pre>
<p>The <code>@Component</code> decorator supports multiple properties,
and we are going review them in the <strong><a href="ch05-04-component-metadata.html">Component Metadata</a></strong> section later in this chapter.
For the bare minimum, you need to set the &quot;selector&quot; and &quot;template&quot; values to create a basic reusable component.</p>
<p>Our minimal &quot;Header&quot; component implementation can look in practice like in the following example.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-header',
  template: '&lt;div&gt;{{ title }}&lt;/div&gt;'
})
export class HeaderComponent {

  title: string = 'Header';

}
</code></pre>
<p>You set the selector value to 'app-header'. That means you are registering a new HTML element called <code>&lt;app-header&gt;</code>.</p>
<p>You also set a &quot;template&quot; property that holds the inline HTML template string.
At run time the Header element is to be rendered as a <code>&lt;div&gt;</code> element with its inner text bound to the &quot;title&quot; property of the &quot;HeaderComponent&quot; class.</p>
<p>Note that before using Header component within an application, we need to register it within the main application module.</p>
<blockquote>
<p><strong>Application Module</strong></p>
<p>You are going to get more detailed information on Angular modules in a separate <strong><a href="ch05-01-creating-a-simple-component.html#modules">Modules</a></strong> chapter.</p>
<p>For now, it is good for you to have just a basic understanding of how components get registered within modules.</p>
</blockquote>
<p>Below you can see an example of how typically register a component.
For the sake of simplicity, we are going to see only newly added content.</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...
import { HeaderComponent } from './components/header.component';

@NgModule({
  declarations: [
    // ...
    HeaderComponent
  ],
  // ...
})
export class AppModule { }
</code></pre>
<p>Finally, to test your component just put the following content into the main application template HTML file.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.template --&gt;
&lt;app-header&gt;&lt;/app-header&gt;
</code></pre>
<p>Once you compile and run your web application, you should see the following content on the main page.</p>
<pre><code class="language-text">Header
</code></pre>
<p>Congratulations, you have just created a basic Angular component that you can now reuse across all your web application.</p>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/basic-components">angular/components/basic-components</a></strong> folder.</p>
</blockquote>
<h2 id="generating-components-with-angular-cli"><a class="header" href="#generating-components-with-angular-cli">Generating Components with Angular CLI</a></h2>
<p>Now let's try creating another component utilizing the Angular CLI.</p>
<p>This time we are going to create a Footer element.
That should give a good comparison on manual versus automatically generated approaches.</p>
<p>Using the command line prompt execute the following command in the project root directory:</p>
<pre><code class="language-sh">ng g component components/footer
</code></pre>
<p>You should instantly notice how Angular CLI saves your time.
It creates you a full set of files for your Footer component and event modifies the main application module file for you.</p>
<p>You can check the console output below:</p>
<pre><code class="language-text">installing component
  create src/app/components/footer/footer.component.css
  create src/app/components/footer/footer.component.html
  create src/app/components/footer/footer.component.spec.ts
  create src/app/components/footer/footer.component.ts
  update src/app/app.module.ts
</code></pre>
<blockquote>
<p><strong>Angular CLI</strong></p>
<p>You can find detailed information on blueprints and content generation in the <a href="ch04-00-angular-cli.html">4. Angular CLI</a> chapter.</p>
</blockquote>
<p>As a result, you get an initial component implementation with an external HTML and CSS templates and even a unit test scaffold.</p>
<pre><code class="language-ts">//src/app/components/footer/footer.component.ts
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-footer',
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.css']
})
export class FooterComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
</code></pre>
<p>Finally, you can update your main application template to see both header and footer elements in action:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;app-header&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Upon compiling the application and reloading the page, you should see the following output.</p>
<pre><code class="language-text">Header
footer works!
</code></pre>
<p>Note how Angular CLI provides a content of the automatically generated Footer element.</p>
<p>So as you can from the examples above, you save an enormous amount of time when using Angular CLI when it comes to scaffold generation.</p>
<h2 id="component-metadata"><a class="header" href="#component-metadata">Component Metadata</a></h2>
<p>According to the official documentation, you can use the following set of properties with a <code>@Component</code> decorator:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>changeDetection</td><td>ChangeDetectionStrategy</td><td>Defines the change detection strategy the component should use.</td></tr>
<tr><td>viewProviders</td><td>Provider[]</td><td>Defines the set of injectable objects that are visible to its view DOM children.</td></tr>
<tr><td>moduleId</td><td>string</td><td>ES/CommonJS module id of the file in which this component is defined.</td></tr>
<tr><td>templateUrl</td><td>string</td><td>Specifies a URL containing a relative path to an external file containing a template for the view.</td></tr>
<tr><td>template</td><td>string</td><td>An inline-defined template for the view.</td></tr>
<tr><td>styleUrls</td><td>string[]</td><td>List of URLs containing relative paths to the stylesheets to apply to this component's view at runtime.</td></tr>
<tr><td>styles</td><td>string[]</td><td>List of inline-defined styles to apply to this component's view at runtime.</td></tr>
<tr><td>animations</td><td>any[]</td><td>List of animations of this component in a special DSL-like format.</td></tr>
<tr><td>encapsulation</td><td>ViewEncapsulation</td><td>Defines style encapsulation strategy used by this component.</td></tr>
<tr><td>interpolation</td><td>[string, string]</td><td>Overrides the default encapsulation start and end delimiters (respectively <code>{{</code> and <code>}}</code>).</td></tr>
<tr><td>entryComponents</td><td>Array&lt;Type&lt;any&gt; | any[]&gt;</td><td>List of components that are dynamically inserted into the view of this component.</td></tr>
</tbody></table>
<p>The <code>@Component</code> decorator extends the <code>@Directive</code> one, so it also inherits the following set of properties you can use as well:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>selector</td><td>string</td><td>CSS selector that identifies this component in a template.</td></tr>
<tr><td>inputs</td><td>string[]</td><td>List of class property names to data-bind as component inputs.</td></tr>
<tr><td>outputs</td><td>string[]</td><td>List of class property names that expose output events that others can subscribe to.</td></tr>
<tr><td>host</td><td>{ [key: string]: string; }</td><td>Map that specifies the events, actions, properties and attributes related to the host element.</td></tr>
<tr><td>providers</td><td>Provider[]</td><td>List of providers available to this component and its children.</td></tr>
<tr><td>exportAs</td><td>string</td><td>A name under which the component instance is exported in a template.</td></tr>
<tr><td>queries</td><td>{ [key: string]: any; }</td><td>Map of queries that can be injected into the component.</td></tr>
</tbody></table>
<h2 id="templates"><a class="header" href="#templates">Templates</a></h2>
<p>There are two ways to assign a component view template: inline-defined and external file.</p>
<h3 id="inline-templates"><a class="header" href="#inline-templates">Inline Templates</a></h3>
<p>You specify inline template by setting the &quot;template&quot; field value of the <code>@Component</code> decorator.
To get better formatting and multi-line support, you can use template literals feature introduced in ES6 and backed by TypeScript out of the box.</p>
<blockquote>
<p><strong>Template Literals</strong></p>
<p>Template literals are string literals allowing embedded expressions.
You can use multi-line strings and string interpolation features with them.</p>
<p>For more detailed information on this ES6 feature, please refer to the following <strong><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals">Template literals</a></strong> article.</p>
</blockquote>
<p>Most of the modern IDEs already have support for mixed content, including TypeScript files.
If you are using <a href="https://code.visualstudio.com/">Visual Studio Code</a> for development,
then you already have syntax highlighting for HTML and CSS.</p>
<p>Let's edit the Header component template to take multiple lines like in the example below:</p>
<pre><code class="language-ts">// src/app/components/header.component.ts
@Component({
  selector: 'app-header',
  template: `
    &lt;div&gt;
        &lt;div&gt;{{ title }}&lt;/div&gt;
    &lt;/div&gt;
  `
})
export class HeaderComponent {
  title: string = 'Header';
}
</code></pre>
<p>Using backtick characters also allows you to have single and double quotes in HTML without any additional escaping or string concatenation.
You are using the same HTML content inlined as you would have in separate files.</p>
<p>Typically you may want to use inline templates only when your component view is small.</p>
<h3 id="external-templates"><a class="header" href="#external-templates">External Templates</a></h3>
<p>The HTML code in the templates usually grows over time and becomes less maintainable.
That is why storing HTML in the separate files may be more practical and productive.</p>
<p>The <code>@Component</code> decorator provides support for external templates through the &quot;templateUrl&quot; option.
Please note that you should set only &quot;template&quot; or &quot;templateUrl&quot;, you cannot define both of them at the same time.</p>
<p>Let's now update our Header component we created earlier and move its HTML template to a separate file.</p>
<pre><code class="language-html">&lt;!-- src/app/components/header.component.html --&gt;
&lt;div&gt;
    &lt;div&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>The <code>templateUrl</code> property should always point to a path relative to the component class file.
In our case, we put both files together in the same directory and update decorator declaration accordingly.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts
@Component({
  selector: 'app-header',
  templateUrl: './header.component.html'
})
export class HeaderComponent {
  title: string = 'Header';
}
</code></pre>
<p>Typically developers put them next to the component class implementation and give the same name for the file as the component:</p>
<ul>
<li>header.component.html</li>
<li>header.component.ts</li>
</ul>
<blockquote>
<p><strong>External Files</strong></p>
<p>External files are the most convenient and recommended way of storing your components' HTML templates.</p>
</blockquote>
<h2 id="styles"><a class="header" href="#styles">Styles</a></h2>
<p>Similar to the HTML templates, the <code>@Component</code> decorator also provides support for CSS styles in either inline or external form.</p>
<h3 id="inline-styles"><a class="header" href="#inline-styles">Inline Styles</a></h3>
<p>If your component is small and you decided to use inline HTML templates then high chances you may want to inline CSS styles as well.</p>
<p>The &quot;styles&quot; property of the <code>@Component</code> decorator is used to store an array of CSS styles that Angular applies to the component at runtime.</p>
<p>To test that in practice let's add a couple of class names to the HTM elements inside the component's template.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({
    selector: 'app-header',
    template: `
        &lt;div class=&quot;app-header&quot;&gt;
            &lt;div class=&quot;app-header-title&quot;&gt;
                {{ title }}
            &lt;/div&gt;
        &lt;/div&gt;
    `
})
export class HeaderComponent { ... }
</code></pre>
<p>We just added &quot;app-header&quot; and &quot;app-header-title&quot; classes, and it is time to provide some CSS for those elements.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({
    selector: 'app-header',
    template: `
        &lt;div class=&quot;app-header&quot;&gt;
            &lt;div class=&quot;app-header-title&quot;&gt;
                {{ title }}
            &lt;/div&gt;
        &lt;/div&gt;
    `,
    styles: [`
        .app-header {
            border: 1px solid gray;
            padding: 4px;
        }
        .app-header-title {
            font-weight: bold;
        }
    `]
})
export class HeaderComponent { ... }
</code></pre>
<p>Now if you compile and run your web application you should see a nice grey border around your Header component.
Also, the &quot;Header&quot; title should have the bold font style.</p>
<p><img src="images/components-01.png" alt="Inline Component Styles" /></p>
<p>As with the inline templates, you may want to inline your style files only for the small components.</p>
<h3 id="external-styles"><a class="header" href="#external-styles">External Styles</a></h3>
<p>The CSS styles tend to grow over time even faster than HTML content.
So it is recommended to move them to the separate files at early stages.</p>
<p>Similar to external HTML templates Angular provides support for external CSS.
You can use &quot;styleUrls&quot; property to provide an array of the URLs with relative paths to corresponding files.</p>
<p>You already know how to use external HTML templates with your components.
Let's now extract the CSS into a separate file as well.
Typically the main style file is called after the parent component class, in our case, it becomes &quot;header.component.css&quot;.</p>
<pre><code class="language-css">/* src/app/components/header.component.css */

.app-header {
  border: 1px solid gray;
  padding: 4px;
}

.app-header-title {
  font-weight: bold;
}
</code></pre>
<p>You should now have &quot;Header&quot; component split into the three separate files:</p>
<ul>
<li>header.component.css</li>
<li>header.component.html</li>
<li>header.component.ts</li>
</ul>
<p>With the changes to @Component decorator properties, the component implementation should now look like the following:</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  styleUrls: [
    './header.component.css'
  ]
})
export class HeaderComponent { ... }
</code></pre>
<p>Visually the component should look the same as with the inline CSS styles.
Once you compile and run your web application, the main page looks like on the screenshot below.</p>
<p><img src="images/components-01.png" alt="External Component Styles" /></p>
<blockquote>
<p><strong>External files</strong></p>
<p>External files are the most convenient and recommended way of storing your components' CSS stylesheets.</p>
</blockquote>
<h2 id="input-properties"><a class="header" href="#input-properties">Input properties</a></h2>
<p>The <code>@Input</code> decorator is used to mark a class property that binds to incoming data.</p>
<p>Let's take a closer look at our Header component created earlier in this chapter.</p>
<p>The component exposes a &quot;title&quot; property of the &quot;string&quot; type and with the default value set to &quot;Header&quot;.</p>
<pre><code class="language-ts">@Component({...})
export class HeaderComponent {
  title: string = 'Header';
}
</code></pre>
<p>We have also provided an HTML template that binds to the underlying &quot;title&quot; property.</p>
<pre><code class="language-html">&lt;div class=&quot;app-header&quot;&gt;
  &lt;div class=&quot;app-header-title&quot;&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>As you can notice from the example above the major limitation of the Header component is that we cannot change the header title text from the outside.</p>
<p>The only way we can use it so far is by utilizing plain selector:</p>
<pre><code class="language-html">&lt;app-header&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Next, let's provide data-binding support for the &quot;title&quot; property using <code>@Input</code> decorator as following:</p>
<pre><code class="language-ts">//src/app/components/header.component.ts

import { ..., Input } from '@angular/core';

@Component({ ... })
export class HeaderComponent {

  @Input()
  title: string = 'Header';
}
</code></pre>
<p>You can now use Header component with custom title values.
Set the value to &quot;My Header&quot; to test that in action.</p>
<pre><code class="language-html">&lt;app-header title=&quot;My Header&quot;&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>This time once your web application compiles and starts the Header should look like on the picture below:</p>
<p><img src="images/components-input-01.png" alt="" /></p>
<p>You can also bind &quot;title&quot; property value to another property.
For example, imagine a scenario when main application component maintains global settings and initializes Header and Footer content.</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({ ... })
export class AppComponent {
  title = 'app';
}
</code></pre>
<p>In this case, you can bind the Header title like following:</p>
<pre><code class="language-html">&lt;app-header [title]=&quot;title&quot;&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Reload the page, and you are going to see the header having now the &quot;app&quot; title as per main application component implementation.</p>
<p><img src="images/components-input-02.png" alt="" /></p>
<blockquote>
<p><strong>Binding to expressions</strong></p>
<p>Keep in mind that you are binding to JavaScript expressions when using square brackets with element attributes.</p>
<p>The example above can also be changed to bind to a string or component class method.
For example <code>&lt;app-header [title]=&quot;getHeaderTitle()&quot;&gt;</code> or <code>&lt;app-header [title]=&quot;'Hello ' + 'world'&quot;&gt;</code>.</p>
</blockquote>
<p>By default, the <code>@Input</code> takes the name of the decorated property when setting up the bindings.
You can, however, change the name of the resulting HTML attribute.</p>
<p>@Input decorator accepts additional optional property alias &quot;bindingPropertyName&quot; to redefine the name to use in the template.
Let's change the binding name of the &quot;title&quot; property to the &quot;title-text&quot; value.</p>
<pre><code class="language-ts">export class HeaderComponent {

    @Input('title-text')
    title: string = 'Header';

}
</code></pre>
<p>From now on you should be settings &quot;title-text&quot; attribute in HTML templates when using Header component with the custom title.</p>
<pre><code class="language-html">&lt;app-header title-text=&quot;My Title&quot;&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>Please note that you are going to deal with two different property names at the same time when using input aliases.
The component template still references property by the original name &quot;title&quot; while externally this property is known as &quot;title-text&quot;:</p>
<pre><code class="language-html">&lt;div class=&quot;app-header&quot;&gt;
  &lt;div class=&quot;app-header-title&quot;&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p><strong>Avoid aliasing inputs and outputs</strong></p>
<p>According to the Angular Style Guide (<a href="https://angular.io/guide/styleguide#style-05-13">Style 05-13</a>),
you should avoid using alias for <code>@Input</code> and <code>@Output</code> decorators except when is needed and serves an important purpose.</p>
<p>Two names for the same property is confusing and may require additional documentation and maintenance over time.</p>
</blockquote>
<h2 id="output-events"><a class="header" href="#output-events">Output Events</a></h2>
<p>You use <code>@Output</code> decorator in combination with the <code>EventEmitter</code> type to create component events.</p>
<p>To better understand how events are used and work let's introduce and see a component event in action.</p>
<h3 id="raising-events"><a class="header" href="#raising-events">Raising Events</a></h3>
<p>We are going to extend our Header component with a &quot;click&quot; event.
Every time the header title gets clicked the component is going to raise a &quot;titleClick&quot; event.</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

import { ..., Output, EventEmitter } from '@angular/core';

@Component({...})
export class HeaderComponent {
    // ...

    @Output()
    titleClick = new EventEmitter();
}
</code></pre>
<p>Now to raise the newly introduced event from the component, we call its <code>next</code> method:</p>
<pre><code class="language-ts">this.titleClick.next();
</code></pre>
<p>Next, we need to wire component template with the underlying method <code>handleTitleClick</code>.
The latter is going to be responsible for raising the corresponding <code>titleClick</code> event.</p>
<pre><code class="language-html">&lt;!-- src/app/components/header.component.html --&gt;

&lt;div class=&quot;app-header&quot;&gt;
  &lt;div class=&quot;app-header-title&quot; (click)=&quot;handleTitleClick()&quot;&gt;{{ title }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>The <code>handleTitleClick</code> implementation can be as follows:</p>
<pre><code class="language-ts">// src/app/components/header.component.ts

@Component({...})
export class HeaderComponent {
    ...

    @Output()
    titleClick = new EventEmitter();

    handleTitleClick() {
        this.titleClick.next();
    }
}
</code></pre>
<h3 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h3>
<p>We have extended our Header component to raise an event once a user clicks the title.
Now let's make our main application handle this event and display click counter on the page.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-header
  [title]=&quot;title&quot;
  (titleClick)=&quot;onTitleClicked()&quot;&gt;
&lt;/app-header&gt;

&lt;div&gt;
  Header clicks: {{ headerClicks }}
&lt;/div&gt;

&lt;app-footer&gt;&lt;/app-footer&gt;
</code></pre>
<p>As you can see from the code above the main application component subscribes
to the <code>titleClick</code> event and uses <code>onTitleClicked</code> method as an event handler.</p>
<p>The component also displays the <code>headerClicks</code> property value for us to see the event handler works.
The final thing we need right now is incrementing the counter property like in the code below:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({...})
export class AppComponent {

    headerClicks = 0;

    onTitleClicked() {
        this.headerClicks += 1;
    }

}
</code></pre>
<p>Now if you run the web application and click several times on the header text,
you should see the clicks counter increase in real time.</p>
<p><img src="images/components-output-01.png" alt="" /></p>
<h3 id="typed-events"><a class="header" href="#typed-events">Typed Events</a></h3>
<p>The EventEmitter type we used for earlier is a generic type, and by default takes the type variable of <code>any</code>.</p>
<pre><code class="language-text">EventEmitter&lt;any&gt;
</code></pre>
<p>In many cases, you may want to provide the additional event arguments to enable better handling of your component events.
For example, a &quot;click&quot; event may expose details on the mouse cursor position or a &quot;textChanged&quot; event that exposes old and new text values.</p>
<p>In the previous section, we have already created a Header component that raises generic &quot;titleClick&quot; event with no arguments.
To compare both approaches let's now update Footer component with the similar event but of a specific type.</p>
<p>The Footer is going to count the number of clicks itself and provide the value as part of the event.
The main application is no longer required to keep track on clicks as it is going to get exact values from the corresponding event arguments.</p>
<p>If you remember, we created a Footer component using the following Angular CLI command:</p>
<pre><code class="language-sh">ng g component components/footer
</code></pre>
<p>First, create a <code>FooterClickedEvent</code> class to hold the clicks-related information for our <code>titleClicked</code> event:</p>
<pre><code class="language-ts">// src/app/components/footer/footer-clicked.event.ts

export class FooterClickedEvent {

    constructor(public readonly totalClicks: number = 0) {
    }

}
</code></pre>
<p>For the sake of simplicity, we are going to create a class with a single read-only property <code>totalClicks</code>
we assign in the constructor, and that defaults to zero if not provided.</p>
<p>Next, edit your footer component and update its code with the following pieces
that add a <code>title</code> input property and <code>titleClicked</code> output event:</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

import { ..., Output, EventEmitter } from '@angular/core';
import { FooterClickedEvent } from './footer-clicked.event';

@Component({...})
export class FooterComponent {

    @Input()
    title = 'Footer';

    @Output()
    titleClick = new EventEmitter&lt;FooterClickedEvent&gt;();

}
</code></pre>
<p>As you can see above, we also declare a private property <code>totalClicks</code> to hold the overall clicks count.</p>
<p>Note how we use <code>EventEmitter</code> type this time.
Using <code>FooterClickedEvent</code> as an EventEmitter's type variable allows us now to create an instance of the given type and emit as an event.</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

@Component({...})
export class FooterComponent {
    ...

    private totalClicks = 0;

    handleTitleClick() {
        const event = new FooterClickedEvent(++this.totalClicks)
        this.titleClick.next(event);
    }

}
</code></pre>
<p>Now we can update the component template to display the title and handle mouse clicks:</p>
<pre><code class="language-html">&lt;!-- src/app/components/footer/footer.component.html --&gt;

&lt;p&gt;
  &lt;span (click)=&quot;handleTitleClick()&quot;&gt;{{ title }}&lt;/span&gt;
&lt;/p&gt;
</code></pre>
<p>Every time user clicks the &quot;title&quot; element of the Footer, the component is going to increment clicks counter
and raise an event with its actual value.</p>
<h3 id="accessing-event-parameters"><a class="header" href="#accessing-event-parameters">Accessing Event Parameters</a></h3>
<p>Angular provides a way to access the original event by using a special <code>$event</code> variable that you can pass to your handlers.</p>
<pre><code class="language-html">&lt;app-footer
  title=&quot;My footer&quot;
  (titleClick)=&quot;onHeaderClicked($event)&quot;&gt;
&lt;/app-footer&gt;
</code></pre>
<p>In our current case, we handle the <code>titleClick</code> event and pass original <code>FooterClickedEvent</code> to the <code>onHeaderClicked</code> handler inside application controller.
That provides access to the <code>totalClicks</code> property we created earlier.</p>
<blockquote>
<p><strong>DOM events</strong></p>
<p>Please keep in mind that &quot;$event&quot; usage applies to all events, either custom or standard DOM ones.
For instance, you can inspect &quot;click&quot;, &quot;hover&quot;, &quot;input&quot; and many other DOM events from within your class methods.</p>
</blockquote>
<p>Let's now update our main application component to display the number of times the user clicked the Footer.</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...
import { FooterClickedEvent } from './components/footer/footer-clicked.event';

@Component({...})
export class AppComponent {
    ...
    footerClicks = 0;

    onHeaderClicked(event: FooterClickedEvent) {
        this.footerClicks = event.totalClicks;
    }
}
</code></pre>
<p>As you can see in the example above, we now can import the <code>FooterClickedEvent</code> type and
use with the event handler parameters to get type checking and code completion support in your IDE.</p>
<p>Finally, let's update the main component template to display click counters for the Footer alongside the Header.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-header
  [title]=&quot;title&quot;
  (titleClick)=&quot;onTitleClicked()&quot;&gt;
&lt;/app-header&gt;

&lt;div&gt;Header clicks: {{ headerClicks }}&lt;/div&gt;
&lt;div&gt;Footer clicks: {{ footerClicks }}&lt;/div&gt;

&lt;app-footer
  title=&quot;My footer&quot;
  (titleClick)=&quot;onHeaderClicked($event)&quot;&gt;
&lt;/app-footer&gt;
</code></pre>
<p>You can now run your web application and make several clicks on Header and Footer components to see all event handlers in action.
You should see results similar to the following:</p>
<p><img src="images/components-output-02.png" alt="" /></p>
<h3 id="aliased-outputs"><a class="header" href="#aliased-outputs">Aliased Outputs</a></h3>
<p>Similar to the <code>@Input</code> decorator the <code>@Output</code> one also supports custom aliases for event names
and takes the name of the decorated property as the default value.</p>
<p>In the previous examples, we used the <code>titleClick</code> for the output property name:</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

@Component({...})
export class FooterComponent {
    // ...

    @Output()
    titleClick = new EventEmitter&lt;FooterClickedEvent&gt;();
}
</code></pre>
<p>You could also provide the <code>title-click</code> alias for the event like below:</p>
<pre><code class="language-ts">// src/app/components/footer/footer.component.ts

@Component({...})
export class FooterComponent {
    // ...

    @Output('title-click')
    titleClick = new EventEmitter&lt;FooterClickedEvent&gt;();
}
</code></pre>
<p>In this case the &quot;official&quot; (or public) event name for the Footer's <code>titleClick</code> component would be <code>title-click</code>, and not <code>titleClick</code>:</p>
<pre><code class="language-html">&lt;app-footer
  title=&quot;My footer&quot;
  (title-click)=&quot;onHeaderClicked($event)&quot;&gt;
&lt;/app-footer&gt;
</code></pre>
<blockquote>
<p><strong>Avoid aliasing inputs and outputs</strong></p>
<p>According to the Angular Style Guide (<a href="https://angular.io/guide/styleguide#style-05-13">Style 05-13</a>),
you should avoid using alias for the <code>@Input</code> and <code>@Output</code> decorators except when is needed and serves an important purpose.</p>
<p>Two names for the same property is confusing and may require additional documentation and maintenance over time.</p>
</blockquote>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>Every Angular component can declare its own set of providers.
The use of local providers allows developers to replace global instances of services,
and register and use a new copy of the service for the given component and all child components.</p>
<p>Let's see how local component providers work in practice.
We are going to need a new service 'ClickCounterService' that you can generate with the following Angular CLI command:</p>
<pre><code class="language-sh">ng g service click-counter
</code></pre>
<p>The service is going to keep track of the user clicks on the elements.
Our components should notify the service upon every click,
and also subscribe to the service events to get notifications on clicks from other components.</p>
<p>Add the <code>clicks</code> property to the service to hold total amount of clicks happened across the application.
Then, add the <code>clicked</code> event to allow components to subscribe and perform custom actions if needed.
Finally, implement the <code>click</code> method that increments the click counter and emits the corresponding event at the same time.</p>
<pre><code class="language-ts">import { Injectable, EventEmitter } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class ClickCounterService {

  clicks = 0;

  clicked = new EventEmitter&lt;number&gt;();

  click() {
    this.clicks += 1;
    this.clicked.emit(this.clicks);
  }

}
</code></pre>
<p>Let's register the newly created &quot;ClickCounterService&quot; service as part of the global providers, in the main application module.</p>
<blockquote>
<p><strong>Registering service</strong></p>
<p>Given that developers can register services in different places,
the Angular CLI does not perform default registration and does not modify &quot;app.module.ts&quot; file
like it does for other Angular entities.</p>
</blockquote>
<p>Please refer to the code below for an example of service registration:</p>
<pre><code class="language-ts">// src/app/app.module.ts

// ...
import { ClickCounterService } from './click-counter.service';

@NgModule({
  ...
  providers: [
    ClickCounterService
  ],
  ...
})
export class AppModule { }
</code></pre>
<p>For the next step, we are going to need three simple components.
You can quickly generate them using the following Angular CLI commands:</p>
<pre><code class="language-sh">ng g component componentA
ng g component componentB
ng g component componentC
</code></pre>
<p>Now, replace the content of the main application component template with the following code:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-component-a&gt;&lt;/app-component-a&gt;
&lt;app-component-b&gt;&lt;/app-component-b&gt;
&lt;app-component-c&gt;&lt;/app-component-c&gt;
</code></pre>
<p>Once you build and run the application, you should see the following content on the main page:</p>
<pre><code class="language-text">component-a works!
component-b works!
component-c works!
</code></pre>
<p>Now, let's integrate one of the components with the &quot;ClickCounterService&quot; service we introduced earlier.</p>
<p>Our component is going to have an HTML button that invokes <code>onClick</code> method upon every click.
The component also subscribes to the service's &quot;clicked&quot; event to update the local <code>totalClicks</code> property and display it to the user.</p>
<pre><code class="language-ts">// src/app/component-a/component-a.component.ts

import { Component, OnInit } from '@angular/core';
import { ClickCounterService } from '../click-counter.service';

@Component({
  selector: 'app-component-a',
  templateUrl: './component-a.component.html',
  styleUrls: ['./component-a.component.css']
})
export class ComponentAComponent implements OnInit {

  totalClicks = 0;

  constructor(private clickService: ClickCounterService) { }

  ngOnInit() {
    this.clickService.clicked.subscribe((clicks) =&gt; {
      this.totalClicks = clicks;
    });
  }

  onClick() {
    this.clickService.click();
  }

}
</code></pre>
<p>Also, replace the component template content with the following markup:</p>
<pre><code class="language-html">&lt;!-- src/app/component-a/component-a.component.html --&gt;

Component A &lt;br&gt;
Clicks: {{ totalClicks }} &lt;br&gt;
&lt;button (click)=&quot;onClick()&quot;&gt;Click&lt;/button&gt;
</code></pre>
<p>Run the application or switch to the running one. Click the component button multiple times to see the counter updates.</p>
<p><img src="images/component-providers-01.png" alt="" /></p>
<p>Repeat the same procedure for other two components we got.
All three components should display the total number of clicks fetched from the server, and have a button for the user to click.</p>
<p>Also, let's slightly improve the main application template and add dividers for better visibility:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-component-a&gt;&lt;/app-component-a&gt;
&lt;hr&gt;
&lt;app-component-b&gt;&lt;/app-component-b&gt;
&lt;hr&gt;
&lt;app-component-c&gt;&lt;/app-component-c&gt;
</code></pre>
<p>Switch to your running application and try clicking one of the buttons several times.
You should see that all click counters get updated automatically with the same value.
That is an expected behavior because all we got three components powered by the same instance of the &quot;ClickCounterService&quot; service.
Every time we click a button, the service notifies other components that update local counter properties and display labels.</p>
<p><img src="images/component-providers-02.png" alt="" /></p>
<p>Now, let's see what happens if one of the components, let it be the <code>Component B</code>, declares its own <code>providers</code> collection.
Import the &quot;ClickCounterService&quot; and declare it as in the example below:</p>
<pre><code class="language-ts">// src/app/component-b.component.ts

// ...
import { ClickCounterService } from '../click-counter.service';

@Component({
  selector: 'app-component-b',
  templateUrl: './component-b.component.html',
  styleUrls: ['./component-b.component.css'],
  providers: [
    ClickCounterService
  ]
})
export class ComponentBComponent implements OnInit {
  // ...
}
</code></pre>
<p>If now you start clicking on the first component, only &quot;Component A&quot; and &quot;Component C&quot; are going to update the labels.
The &quot;Component B&quot; should remain with the zero value.</p>
<p><img src="images/component-providers-03.png" alt="" /></p>
<p>As you can see, the &quot;Component B&quot; declares its local instance of the service, so it does not react to the events raised by the global one.
Now if you click the &quot;Component B&quot; button several times, its counter label should update separately from other components.
Moreover, other components are not going to update on &quot;Component B&quot; clicks, as they are listening to the global service events.</p>
<p><img src="images/component-providers-04.png" alt="" /></p>
<p>The component-level provider is a great feature.
It allows you to have more than one instance of the service or to have custom service implementation
or replacement for a particular component and all child components that you use in its template.</p>
<blockquote>
<p><strong>Advanced feature</strong></p>
<p>You should be very careful and use this feature only when it is necessary
as it is quite easy to introduce an issue when creating multiple instances of the same service type.
For example the Authentication Service. Typically you may want always to have only one instance,
as the service might keep the authentication state or some other critical data,
and having more than one service leads to application issues.</p>
</blockquote>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/blob/master/angular/components/component-providers">angular/components/component-providers</a></strong> folder.</p>
</blockquote>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p>The host property is an object of a Map type and specifies the events, actions,
properties and attributes related to the resulting element.</p>
<p>Use the following Angular CLI command to generate a new <code>host-events</code> component for the tests:</p>
<pre><code class="language-sh">ng g component host-events
</code></pre>
<p>Also, replace the content of the main application component template with your component declaration:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Host events:&lt;/h2&gt;
&lt;app-host-events&gt;&lt;/app-host-events&gt;
</code></pre>
<p>Run the application and ensure the main page looks similar to the following:</p>
<p><img src="images/component-host-01.png" alt="" /></p>
<h3 id="css-class"><a class="header" href="#css-class">CSS Class</a></h3>
<p>Your component or directive can assign a class name to the corresponding DOM element that serves the root of the component.
For example setting the class name to the <code>host-events</code> value looks like the following:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts

@Component({
  selector: 'app-host-events',
  templateUrl: './host-events.component.html',
  styleUrls: ['./host-events.component.css'],
  host: {
    class: 'host-events'
  }
})
export class HostEventsComponent implements OnInit {
  //...
}
</code></pre>
<p>At runtime, if you use the &quot;Inspect element&quot; tool to view the compiled HTML output, it should look similar to the following:</p>
<pre><code class="language-html">&lt;app-host-events _ngcontent-c0=&quot;&quot; class=&quot;host-events&quot; _nghost-c1=&quot;&quot;&gt;
    &lt;p _ngcontent-c1=&quot;&quot;&gt;
        host-events works!
    &lt;/p&gt;
&lt;/app-host-events&gt;
</code></pre>
<p>Note that the main <code>app-host-events</code> element has now the <code>host-events</code> class name associated with it.</p>
<p>You can also set multiple classes based on property values using the following format:</p>
<pre><code class="language-text">host: {
    '[class.&lt;className1&gt;]': '&lt;statement1&gt;',
    '[class.&lt;classNameN&gt;]': '&lt;statementN&gt;'
}
</code></pre>
<p>Let's bind a couple of CSS class names to the component class properties:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts

@Component({
  selector: 'app-host-events',
  templateUrl: './host-events.component.html',
  styleUrls: ['./host-events.component.css'],
  host: {
    '[class.is-invalid]': 'isInvalid',
    '[class.is-readonly]': 'isReadonly'
  }
})
export class HostEventsComponent implements OnInit {
    // ...

    isInvalid: boolean = false;
    isReadonly: boolean = false;
}
</code></pre>
<p>The class values are toggled based on the corresponding property values.</p>
<p>For example, the <code>is-invalid</code> is appended to the class list of the DOM element as soon as the <code>isInvalid</code> property value turns to <code>true</code>,
also, is automatically removed from the class list if it has the value of <code>false</code>.</p>
<h3 id="host-events"><a class="header" href="#host-events">Host Events</a></h3>
<p>The component or directive you create can also use <code>host</code> metadata property to bind element events to the class methods.
The usage format, in this case, is as follows:</p>
<pre><code class="language-text">host: {
    '(&lt;event&gt;)': '&lt;statement&gt;'
}
</code></pre>
<p>To test the event bindings in action let's wire the <code>mouseenter</code> and <code>mouseleave</code> DOM events
with the <code>onMouseEnter</code> and <code>onMouseLeave</code> methods that are going to change the <code>color</code> property value:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-host-events',
  templateUrl: './host-events.component.html',
  styleUrls: ['./host-events.component.css'],
  host: {
    class: 'host-events',
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()'
  }
})
export class HostEventsComponent {

  color = 'black';

  onMouseEnter() {
    this.color = 'red';
  }

  onMouseLeave() {
    this.color = 'black';
  }

}
</code></pre>
<p>Finally, update the component template to use the <code>color</code> property like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/host-events/host-events.component.html --&gt;

&lt;p [style.color]=&quot;color&quot;&gt;
  host-events works!
&lt;/p&gt;
</code></pre>
<p>Now, switch to the running application and try moving the mouse cursor over the component text.
You should see the colour of the text changing automatically upon mouse events.</p>
<p><img src="images/component-host-02.png" alt="" /></p>
<p>Your component can also listen to global events using the following format:</p>
<pre><code class="language-text">host: {
    '(&lt;target&gt;:&lt;event&gt;)': '&lt;statement&gt;'
}
</code></pre>
<p>Where 'target' can be of one the following values:</p>
<ul>
<li>window</li>
<li>document</li>
<li>body</li>
</ul>
<p>For example, the component can listen to 'window.resize' events and adapt the layout accordingly:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts
// ...

@Component({
  // ...
  
  host: {
    class: 'host-events',
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()',
    '(window:resize)': 'onWindowResize()'
  }
})
export class HostEventsComponent {

  // ...

  onWindowResize() {
    console.log('Window resized');
  }

}
</code></pre>
<p>If you run the developer tools in your browser and try resizing the browser window,
you should notice the component reacts on that and writes corresponding messages to the console log.</p>
<h3 id="host-attributes"><a class="header" href="#host-attributes">Host Attributes</a></h3>
<p>The Angular framework allows you to map multiple HTML attributes to the class properties or static string values.
Let's set the <code>role</code> and <code>aria-label</code> attributes from within the host metadata:</p>
<pre><code class="language-ts">// src/app/host-events/host-events.component.ts
// ...

@Component({
  // ...
  
  host: {
    class: 'host-events',
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()',
    '(window:resize)': 'onWindowResize()',
    'role': 'button',
    'aria-label': 'Demo button'
  }
})
export class HostEventsComponent {
  // ...
}
</code></pre>
<p>As soon as the page gets rendered, you can inspect the compiled HTML layout to check the element attributes.
The <code>app-host-events</code> element now contains the expected attributes:</p>
<pre><code class="language-html">&lt;app-host-events _ngcontent-c0=&quot;&quot; aria-label=&quot;Demo button&quot; class=&quot;host-events&quot; role=&quot;button&quot; _nghost-c1=&quot;&quot;&gt;
    &lt;p _ngcontent-c1=&quot;&quot; style=&quot;color: black;&quot;&gt;
        host-events works!
    &lt;/p&gt;
&lt;/app-host-events&gt;
</code></pre>
<h3 id="host-properties"><a class="header" href="#host-properties">Host Properties</a></h3>
<p>Finally, you can bind component properties to element properties.
That might be useful when developing Angular directives.</p>
<p>For example, a directive that automatically changes the button value based on one of its properties can look like the following:</p>
<pre><code class="language-ts">// src/app/host-properties.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appHostProperties]',
  host: {
    '[innerHTML]': 'value'
  }
})
export class HostPropertiesDirective {

  value = 'Custom Value';

}
</code></pre>
<p>Now, let's define a simple button and see the directive in action:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Host events:&lt;/h2&gt;
&lt;app-host-events&gt;&lt;/app-host-events&gt;

&lt;hr&gt;
&lt;button appHostProperties&gt;Click me&lt;/button&gt;
</code></pre>
<p>Note that we provided the button text in the HTML template.
Switch back to the browser window and ensure the button value got changed by the directive as per the host metadata settings.</p>
<p><img src="images/component-host-03.png" alt="" /></p>
<p>Similar to the CSS classes, you can provide values for multiple attributes of the decorated DOM element using the following syntax:</p>
<pre><code class="language-text">host: {
    '[attr.&lt;name1&gt;]': '&lt;statement1&gt;',
    '[attr.&lt;nameN&gt;]': '&lt;statementN&gt;',
}
</code></pre>
<p>Let's bind a &quot;custom1&quot; attribute to the &quot;attrValue&quot; property of the class to check how that feature works.</p>
<pre><code class="language-ts">import { Directive } from '@angular/core';

@Directive({
  selector: '[appHostProperties]',
  host: {
    '[innerHTML]': 'value',
    '[attr.custom1]': 'attrValue'
  }
})
export class HostPropertiesDirective {

  value = 'Custom Value';
  attrValue = 'some attribute value';
}

</code></pre>
<p>If you remember, we got a button element declared in the main application template like below:</p>
<pre><code class="language-html">&lt;button appHostProperties&gt;Click me&lt;/button&gt;
</code></pre>
<p>At the runtime, the element gets a custom attribute from the directive:</p>
<pre><code class="language-html">&lt;button _ngcontent-c0=&quot;&quot; apphostproperties=&quot;&quot; custom1=&quot;some attribute value&quot;&gt;Custom Value&lt;/button&gt;
</code></pre>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/component-host">angular/components/component-host</a></strong> folder.</p>
</blockquote>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>There may be scenarios when you need accessing child components from your current component that contains them.
That becomes useful when you need calling public methods or change properties of the children.</p>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/component-queries">angular/components/component-queries</a></strong> folder.</p>
</blockquote>
<h3 id="preparing-the-project"><a class="header" href="#preparing-the-project">Preparing the Project</a></h3>
<p>Let's start by creating a new Angular project with the help of Angular CLI, and creating two components <code>List</code> and <code>ListItem</code> to experiment.</p>
<pre><code class="language-sh">ng g component list
ng g component list-item
</code></pre>
<p>Extend the generated List component with an extra property <code>title</code> marked with the <code>@Input</code> decorator.</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

import { /*...,*/ Input } from '@angular/core';

@Component({/*...*/})
export class ListComponent implements OnInit {

  @Input()
  title = 'List Title';

  // ...
}
</code></pre>
<p>Next, update the component HTML template to display the <code>title</code> value,
and also the <code>ng-content</code> component to render any other components or HTML elements the end developers provide:</p>
<pre><code class="language-html">&lt;!-- src/app/list/list.component.html --&gt;

&lt;div&gt;{{ title }} &lt;/div&gt;
&lt;ng-content&gt;&lt;/ng-content&gt;
</code></pre>
<p>Now you can declare a List element in the main application component template, and also put several ListItem components inside its tags:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;
</code></pre>
<p>At runtime, the code above should give you the following output on the main page:</p>
<p><img src="images/component-queries-01.png" alt="" /></p>
<h3 id="viewchild"><a class="header" href="#viewchild">@ViewChild</a></h3>
<p>The <code>@ViewChild</code> decorator allows you to retrieve and reference the component or directive from the current component View.</p>
<p>For example, the main application component can gain access to the List component we have defined in its HTML template,
and modify properties of the component instance from the code.</p>
<p>To do that we need to use a <code>@ViewChild</code> decorator with the target type.</p>
<p>You can access the property decorated with the <code>@ViewChild</code> only after component's View initializes.
The <code>AfterViewInit</code> interface and corresponding method is the most appropriate place for that.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ ViewChild, AfterViewInit } from '@angular/core';
import { ListComponent } from './list/list.component';

@Component({...})
export class AppComponent implements AfterViewInit {

  @ViewChild(ListComponent)
  list: ListComponent;

  ngAfterViewInit() {
    this.list.title = 'custom list title';
  }
}
</code></pre>
<p>In the code snippet above, we change the title of the child List component from code.
Switch to the browser running your application, and you should see the following:</p>
<p><img src="images/component-queries-02.png" alt="" /></p>
<p>The component query is not limited to the target type reference.
You can also use local references and use string identifiers, for example, mark the List with the &quot;myList&quot; id:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list #myList&gt;
  &lt;!-- ... --&gt;
&lt;/app-list&gt;
</code></pre>
<p>Now you can use this id with the <code>@ViewChild</code> decorator if needed:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent implements AfterViewInit {

  @ViewChild('myList')
  list: ListComponent;

  // ...
}
</code></pre>
<h3 id="viewchildren"><a class="header" href="#viewchildren">@ViewChildren</a></h3>
<p>If you declare more than one List component, you should notice that every time only the first instance is fetched.
To get a reference to all the child instances of the particular component type you need to use a <code>@ViewChildren</code> decorator.</p>
<p>Let's have two List components separated by a horizontal line like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;

&lt;hr&gt;

&lt;app-list&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;
</code></pre>
<p>Now create a <code>lists</code> property in the underlying component class to reference all &quot;ListComponent&quot; instances after View gets initialized:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ QueryList, ViewChildren } from '@angular/core';
import { ListComponent } from './list/list.component';

@Component({/*...*/})
export class AppComponent implements AfterViewInit {

  @ViewChild(ListComponent)
  list: ListComponent;

  @ViewChildren(ListComponent)
  lists: QueryList&lt;ListComponent&gt;;

  // ...
}
</code></pre>
<p>For the next step, we are going to update the <code>title</code> property of every List component in the View:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ AfterViewInit, QueryList, ViewChildren } from '@angular/core';
import { ListComponent } from './list/list.component';

@Component({/*...*/})
export class AppComponent implements AfterViewInit {
  // ...

  @ViewChildren(ListComponent)
  lists: QueryList&lt;ListComponent&gt;;

  ngAfterViewInit() {
    let i = 0;
    this.lists.forEach(l =&gt; {
      l.title = 'Custom title #' + (i++);
    });
  }
}
</code></pre>
<p>Switch back to the browser and once the application compiles and restarts you should see the following:</p>
<p><img src="images/component-queries-03.png" alt="ViewChildren Queries" /></p>
<h3 id="contentchild"><a class="header" href="#contentchild">@ContentChild</a></h3>
<p>The <code>@ViewChild</code> provides access only to components and directives that are part of the view but not inside the <code>ng-content</code> tags.
You need to use <code>@ContentChild</code> decorator to work with the elements inside <code>ng-content</code> container.</p>
<p>If you remember, the List component template already features the <code>ng-template</code>:</p>
<pre><code class="language-html">&lt;!-- src/app/list/list.component.html --&gt;

&lt;div&gt;{{ title }} &lt;/div&gt;
&lt;ng-content&gt;&lt;/ng-content&gt;
</code></pre>
<p>Update the ListItemComponent component class with the &quot;title&quot; property like in the following example:</p>
<pre><code class="language-ts">// src/app/list-item/list-item.component.ts
// ...

@Component({/*...*/})
export class ListItemComponent {

  title = 'list-item works!';

}
</code></pre>
<p>For the sake of simplicity just replace the content of the ListItem component template with the next block of HTML:</p>
<pre><code class="language-html">&lt;!-- src/app/list-item/list-item.component.html --&gt;

&lt;p&gt;
  {{ title }}
&lt;/p&gt;
</code></pre>
<p>For a start, let's access the very first entry of the List content collection
by introducing a <code>firstListItem</code> property decorated with the <code>@ContentChild</code>.</p>
<p>As soon as component content gets initialized, we are going to update the title of the referenced item.</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

import { /*...,*/ ContentChild, AfterContentInit } from '@angular/core';
import { ListItemComponent } from '../list-item/list-item.component';

@Component({/*...*/})
export class ListComponent implements AfterContentInit {
  ...

  @ContentChild(ListItemComponent)
  firstListItem: ListItemComponent;

  ngAfterContentInit() {
    this.firstListItem.title = 'first item';
  }
}
</code></pre>
<p>Note that your component now needs to implement the <code>AfterContentInit</code> interface
and have the corresponding <code>ngAfterContentInit</code> method implementation.
That is the most recommended place to work with the elements provided using the <code>@ContentChild</code> decorator.</p>
<p>Switch to the browser, and you should now look the following on the main page:</p>
<p><img src="images/component-queries-04.png" alt="ContentChild Query" /></p>
<h3 id="contentchildren"><a class="header" href="#contentchildren">@ContentChildren</a></h3>
<p>Similar to the <code>@ViewChild</code>, the <code>@ContentChild</code> decorator always returns the first found element
if there are more than one declared in the Component View.</p>
<p>You are going to need a <code>@ContentChildren</code> decorator if you intend working with all the instances.</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

import { /*...,*/ ContentChildren, QueryList } from '@angular/core';
import { ListItemComponent } from '../list-item/list-item.component';

@Component({/*...*/})
export class ListComponent implements AfterContentInit {
  // ...

  @ContentChildren(ListItemComponent)
  listItems: QueryList&lt;ListItemComponent&gt;;

  ngAfterContentInit() {
    this.listItems.forEach(item =&gt; {
      item.title = item.title + ' (' + new Date().toLocaleDateString() + ')';
    });
  }
}
</code></pre>
<p>The example above should already be familiar to you.
We have just updated every item in the list by changing its title.
The main page in the browser should be looking similar to the following one:</p>
<p><img src="images/component-queries-05.png" alt="ContentChildren Query" /></p>
<h3 id="listening-for-view-and-content-changes"><a class="header" href="#listening-for-view-and-content-changes">Listening for View and Content Changes</a></h3>
<p>So with <code>@ContentChild</code>, <code>@ContentChildren</code>, <code>@ViewChild</code> and <code>@ViewChildren</code> decorators we can import
and manipulate elements and components in the controller class.</p>
<p>But what if developer applies conditional visibility to the layout entries like in the example below?</p>
<pre><code class="language-html">&lt;app-list&gt;
  &lt;app-list-item *ngIf=&quot;showFirstItem&quot;&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;
</code></pre>
<p>As we already know, based on the &quot;ngIf state&quot;, the Angular will remove a corresponding element from the DOM, or add it back.
There are many scenarios, however, when your component controller needs to know about such changes.
For example, imagine a &quot;DataTable&quot; component that uses child components to define column structure,
but then turns developer-defined view or content elements to some internal representation.
The component must always know what is the &quot;visible&quot; part of the layout to work with.</p>
<p>Let's now extend our previous &quot;ViewChildren&quot; example with an extra flag to toggle visibility of the first list entry.
We will add a &quot;showFirstItem&quot; property, and a button that changes the property value on each click.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent implements AfterViewInit {

  showFirstItem = true;

  // ...
}
</code></pre>
<p>Next, append the following block to the component template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;hr&gt;

&lt;button (click)=&quot;showFirstItem = !showFirstItem&quot;&gt;
  Toggle first item
&lt;/button&gt;
</code></pre>
<p>We have declared two List components in the previous examples.
Let's now wire the first entry of each of the components with the <code>showFirstItem</code> condition like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-list&gt;
  &lt;app-list-item *ngIf=&quot;showFirstItem&quot;&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;

&lt;hr&gt;

&lt;app-list&gt;
  &lt;app-list-item *ngIf=&quot;showFirstItem&quot;&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
  &lt;app-list-item&gt;&lt;/app-list-item&gt;
&lt;/app-list&gt;

&lt;hr&gt;

&lt;button (click)=&quot;showFirstItem = !showFirstItem&quot;&gt;
  Toggle first item
&lt;/button&gt;
</code></pre>
<p>If you run the application now, you will see every first item appear and disappear from the list each time you click the &quot;Toggle first item&quot; buttons.
We have just emulated the situation when layout changes based on the external criteria.
But how does the component now react on those changes?</p>
<p>The &quot;QueryList&quot; class exposes a special &quot;changes&quot; property of the <code>Observable&lt;any&gt;</code>
type that can help us watch for the layout changes and achieve the desired behavior.</p>
<p>Now you can update the ListComponent implementation and add a simple change tracking code like in the following example:</p>
<pre><code class="language-ts">// src/app/list/list.component.ts

@Component({/*...*/})
export class ListComponent implements AfterContentInit {

  // ...

  ngAfterContentInit() {
    // ...

    this.listItems.changes.subscribe(() =&gt; {
      console.log(
        `List content changed and has now ${this.listItems.length} items.`
      );
    });
  }
}
</code></pre>
<p>Please run the application once again and click the &quot;Toggle first item&quot; button a few times.
Alongside the element being added to and removed from the page, you will see the following console output:</p>
<pre><code class="language-text">List content changed and has now 2 items.
List content changed and has now 2 items.
List content changed and has now 3 items.
List content changed and has now 3 items.
List content changed and has now 2 items.
List content changed and has now 2 items.
</code></pre>
<p>We have two instances of the ListComponent declared in the application component template.
And both lists have its first element wired with conditional visibility expression.
That is why you will see messages from both components in the browser console output window.</p>
<p>As you can see, subscribing and listening to <code>QueryList&lt;T&gt;.change</code> events gives you an ability
to react on layout changes and perform extra behaviors at the component level.</p>
<h1 id="component-lifecycle"><a class="header" href="#component-lifecycle">Component Lifecycle</a></h1>
<h1 id="content-projection"><a class="header" href="#content-projection">Content Projection</a></h1>
<h1 id="dependency-injection"><a class="header" href="#dependency-injection">Dependency Injection</a></h1>
<p>Dependency Injection, also known as DI, is one of the major features of the Angular framework.</p>
<p>With dependency injection, Angular greatly improves development and testing process
by providing an infrastructure that helps to move share coded into the separate application services and blocks
that can be centrally maintained, reused or replaced at run time.</p>
<p>In this chapter, we are going to try key features of dependency injection in practice.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code as an Angular CLI project for this chapter in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/dependency-injection">angular/dependency-injection</a>&quot; folder.</p>
</blockquote>
<h2 id="preparing-a-project"><a class="header" href="#preparing-a-project">Preparing a Project</a></h2>
<p>First, let's use Angular CLI tool and generate a new project called &quot;dependency-injection&quot;.</p>
<pre><code class="language-sh">ng new dependency-injection
cd dependency-injection
</code></pre>
<p>Next, generate two components <code>component1</code> and <code>component2</code>, as in the example below:</p>
<pre><code class="language-sh">ng g component component1
ng g component component2
</code></pre>
<p>Finally, update the main application component template to use both components we have just created:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-component1&gt;&lt;/app-component1&gt;
&lt;app-component2&gt;&lt;/app-component2&gt;
</code></pre>
<p>If you now run the application with the <code>ng serve --open</code> command you should see two default component templates
that get generated automatically by Angular CLI:</p>
<pre><code class="language-text">component1 works!
component2 works!
</code></pre>
<p>You now have a working project ready for DI experiments.</p>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<h3 id="creating-logservice"><a class="header" href="#creating-logservice">Creating LogService</a></h3>
<p>As an example, let's build a shared Logger service now.</p>
<p>Logging is an excellent example of how to turn a frequently used functionality into an injectable service.
That is something you are not going to re-implement in each component.</p>
<p>You can save your time by using Angular CLI to generate a new &quot;log&quot; service utilizing the following command:</p>
<pre><code class="language-sh">ng g service services/log
</code></pre>
<p>That should give you a scaffold for a new service called <code>LogService</code>:</p>
<pre><code class="language-ts">// src/app/services/log.service.ts

import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class LogService {

  constructor() { }

}
</code></pre>
<p>We use a special <code>@Injectable</code> decorator here to mark the class and instruct Angular
that the given class should participate in the dependency injection layer.</p>
<p>All classes marked with <code>@Injectable</code> can get imported into other entities like services, components, directives or pipes.
The Angular framework creates instances of those classes, usually in the form of &quot;singletons&quot;,
and injects into other primitives on demand.</p>
<p>Note the warning message that Angular CLI generates for every new service scaffold:</p>
<pre><code class="language-text">installing service
  create src/app/services/log.service.spec.ts
  create src/app/services/log.service.ts
  WARNING Service is generated but not provided, it must be provided to be used
</code></pre>
<p>We are going to walk through Modules feature later in this chapter.
For now, just edit the <code>app.module.ts</code> file and add the <code>LogService</code> file to the <code>providers</code> section as in the following example:</p>
<pre><code class="language-ts">// src/app/app.module.ts
// ...

import { LogService } from './services/log.service';

@NgModule({
  declarations: [/* ... */],
  imports: [/* ... */],
  providers: [
    LogService
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>That allows injecting <code>LogService</code> into all application components,
including the <code>component1</code> and <code>component2</code> we have created earlier.</p>
<p>Next, let's extend the service implementation with an <code>info</code> method we can reuse across the components:</p>
<pre><code class="language-ts">// src/app/services/log.service.ts

@Injectable({ providedIn: 'root' })
export class LogService {

  constructor() { }

  info(message: string) {
    console.log(`[info] ${message}`);
  }

}
</code></pre>
<p>At this point, we got a minimal logging service implementation that we can use in our components.</p>
<h3 id="injecting-and-using-logservice"><a class="header" href="#injecting-and-using-logservice">Injecting and Using LogService</a></h3>
<p>We are going to use constructor parameters to inject the <code>LogService</code> created earlier.</p>
<p>The Angular framework takes care of all the intermediate steps needed to find the expected type of the service,
instantiate it and provide as a parameter when building our component.</p>
<pre><code class="language-ts">// src/app/component1/component1.component.ts

import { Component } from '@angular/core';
import { LogService } from './../services/log.service';

@Component({/*...*/})
export class Component1Component {

  constructor(logService: LogService) {
    logService.info('Component 1 created');
  }

}
</code></pre>
<p>You can now try to update the second component implementation yourself
and add the same LogService integration as in the example above.</p>
<p>Once you are finished updating the code, run the application,
and you should see the following output in the browser console:</p>
<pre><code class="language-text">[info] Component 1 created
[info] Component 2 created
</code></pre>
<h2 id="providers-1"><a class="header" href="#providers-1">Providers</a></h2>
<p>In the previous examples, you should have noticed that to import and use a class decorated with <code>@Injectable</code>
one needs to declare its Type in the <code>providers</code> array of the main application Module.</p>
<p>That makes Angular &quot;know&quot; about the services when instantiating components for your web application.</p>
<p>You can have numerous services that perform various sets of functionality, all registered within the root module:</p>
<pre><code class="language-ts">@NgModule({
  // ...,

  providers: [
    ...
    LogService,
    AuthenticationService,
    AvatarService,
    UserService,
    ChatService
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The concept of <code>providers</code> in Angular goes beyond the collection of classes, in fact,
it supports several powerful ways to control how dependency injection behaves at runtime.</p>
<p>Besides strings, the framework supports an object-based notation for defining providers.</p>
<h3 id="using-a-class"><a class="header" href="#using-a-class">Using a Class</a></h3>
<p>Earlier in this chapter, we have been using a string value to define a LogService dependency in the <code>providers</code> section.
We can express the same value with the help of the following notation:</p>
<pre><code class="language-ts">{ provide: &lt;key&gt;, useClass: &lt;class&gt; }
</code></pre>
<p>Let's take a look at the next example:</p>
<pre><code class="language-ts">@NgModule({
  // ...
  
  providers: [
    { provide: LogService, useClass: LogService }
  ],

  //...
})
export class AppModule { }
</code></pre>
<p>We are using <code>LogService</code> both as a &quot;key&quot; for injection and as a &quot;value&quot; to build a new instance for injection.</p>
<p>The main feature of this approach is that &quot;key&quot; and &quot;value&quot; can be different classes.
That allows swapping the value of the service with a custom implementation if needed, or with a Mock object for an improved unit testing experience.</p>
<p>Now, let's create a custom logger implementation <code>CustomLogService</code>:</p>
<pre><code class="language-sh">ng g service services/custom-log
</code></pre>
<p>Next, implement the <code>info</code> method, but this time it should contain some different output for us to distinguish both implementations:</p>
<pre><code class="language-ts">import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CustomLogService {

  constructor() { }

  info(message: string) {
    console.log(`[custom]: [info] ${message}`);
  }

}
</code></pre>
<p>Finally, you need to import this class into the main application module and declare as a new provider with the &quot;LogService&quot; key.
Don't forget to comment out or remove the former logger declaration as in the example below:</p>
<pre><code class="language-ts">import { LogService } from './services/log.service';
import { CustomLogService } from './services/custom-log.service';

@NgModule({
  // ...,

  providers: [
    // LogService
    { provide: LogService, useClass: CustomLogService }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The code above means that all the components that inject the <code>LogService</code> as part of the constructor parameters
are going to receive the <code>CustomLogService</code> implementation at runtime.</p>
<p>Essentially we are swapping the value of the logger, and no component is going to notice that.
That is the behavior developers often use for unit testing purposes.</p>
<p>If you now run the web application and navigate to browser console, you should see the following output:</p>
<pre><code class="language-text">[custom]: [info] Component 1 created
[custom]: [info] Component 2 created
</code></pre>
<p>Strings now contain &quot;[custom]: &quot; as a prefix, which proves the <code>Component1</code> and <code>Component2</code>
are now dealing with the <code>CustomLogService</code> code that has been successfully injected using the <code>LogService</code> key.</p>
<h3 id="using-a-class-factory"><a class="header" href="#using-a-class-factory">Using a Class Factory</a></h3>
<p>Previously we have been relying on the Angular framework to create instances of the injectable entities.</p>
<p>There is also a possibility to control how the class gets instantiated if you need more than just a default constructor calls.
Angular provides support for &quot;class factories&quot; for that very purpose.</p>
<p>You are going to use the following notation for class factories:</p>
<pre><code class="language-ts">{ provide: &lt;key&gt;, useFactory: &lt;function&gt; }
</code></pre>
<p>Before we jump into configuration details, let's extend our newly introduced <code>CustomLogService</code> service with the custom &quot;prefix&quot; support.
We are going to implement a special <code>setPrefix</code> method:</p>
<pre><code class="language-ts">import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CustomLogService {

  private prefix = '[custom]';

  setPrefix(value: string) {
    this.prefix = value;
  }

  info(message: string) {
    console.log(`${this.prefix}: [info] ${message}`);
  }

}
</code></pre>
<p>As you can see from the code above the <code>info</code> method is going to use a custom prefix for all the messages.</p>
<p>Next, create an exported function <code>customLogServiceFactory</code> that is going to control how the CustomLogService instance gets created.
In our case we are going to provide a custom prefix like in the example below:</p>
<pre><code class="language-ts">export function customLogServiceFactory() {
  const service = new CustomLogService();
  service.setPrefix('(factory demo)');
  return service;
}
</code></pre>
<p>As you can imagine, there could be more sophisticated configuration scenarios for all application building blocks,
including services, components, directives and pipes.</p>
<p>Finally, you can use the factory function for the <code>LogService</code>.
In this case, we both replace the real instance with the <code>CustomLogService</code>, and pre-configure the latter with a custom prefix for info messages:</p>
<pre><code class="language-ts">@NgModule({
  // ...
  
  providers: [
    { provide: LogService, useFactory: customLogServiceFactory }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>This time, when the application runs, you should see the following output:</p>
<pre><code class="language-text">(factory demo): [info] Component 1 created
(factory demo): [info] Component 2 created
</code></pre>
<h4 id="class-factories-with-dependencies"><a class="header" href="#class-factories-with-dependencies">Class Factories With Dependencies</a></h4>
<p>When you use the default provider registration for a service, directive or component,
the Angular framework automatically manages and injects dependencies if needed.
In the case of factories, you can use additional <code>deps</code> property to define dependencies
and allow your factory function to access corresponding instances during execution.</p>
<p>Let's imagine we need to manually bootstrap the <code>AuthenticationService</code>
that depends on the <code>RoleService</code> and <code>LogService</code> instances.</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class AuthenticationService {

  constructor(private roles: RoleService,
              private log: LogService) {
  }
  
  // ...
}
</code></pre>
<p>We should declare our factory-based provider the following way now:</p>
<pre><code class="language-ts">@NgModule({
  // ...,
  
  providers: [
      {
        provide: AuthenticationService,
        useFactory: authServiceFactory,
        deps: [ RoleService, LogService ]
      }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>With the code above we instruct Angular to resolve the <code>RoleService</code> and <code>LogService</code>
and use with our custom factory function when the <code>AuthenticationService</code> singleton instance gets created for the first time.</p>
<p>Finally, your factory implementation should look similar to the following one:</p>
<pre><code class="language-ts">export function authServiceFactory(roles: RoleService, log: LogService) {
  const service = new AuthenticationService(roles, log);
  // do some additional service setup
  return service;
}
</code></pre>
<h3 id="using-inject-decorator"><a class="header" href="#using-inject-decorator">Using @Inject Decorator</a></h3>
<p>Another important scenario you might be interested in is the <code>@Inject</code> decorator.</p>
<p>The <code>@Inject</code> decorator instructs Angular that a given parameter must get injected at runtime.
You can also use it to get references to &quot;injectables&quot; using string-based keys.</p>
<p>To demonstrate <code>@Inject</code> decorator in practice let's create a <code>dateFactory</code> function to generate current date:</p>
<pre><code class="language-ts">// src/app/app.module.ts

export function dateFactory() {
  return new Date();
}
</code></pre>
<p>Now we define a custom provider with the key <code>DATE_NOW</code> that is going to use our new factory.</p>
<pre><code class="language-ts">@NgModule({
  // ...,

  providers: [
    { provide: 'DATE_NOW', useFactory: dateFactory }
  ],

  // ...
})
export class AppModule { }
</code></pre>
<p>For the next step, you can import the <code>@Inject</code> decorator from the <code>angular/core</code> namespace
and use it with the <code>Component1</code> we created earlier in this chapter:</p>
<pre><code class="language-ts">import { /*...,*/ Inject } from '@angular/core';

@Component({...})
export class Component1Component {

  constructor(logService: LogService, @Inject('DATE_NOW') now: Date) {
    logService.info('Component 1 created');
    logService.info(now.toString());
  }

}
</code></pre>
<p>There are two points of interest in the code above. First, we inject <code>LogService</code> instance
as a <code>logService</code> parameter using its type definition: <code>logService: LogService</code>.
Angular is smart enough to resolve the expected value based on the <code>providers</code> section in the Module, using <code>LogService</code> as the key.</p>
<p>Second, we inject a date value into the <code>now</code> parameter.
This time Angular may experience difficulties resolving the value based on the <code>Date</code> type,
so we have to use the <code>@Inject</code> decorator to explicitly bind <code>now</code> parameter to the <code>DATE_NOW</code> value.</p>
<p>The browser console output, in this case, should be as the following one:</p>
<pre><code class="language-text">(factory demo): [info] Component 1 created
(factory demo): [info] Sun Aug 06 2017 08:45:36 GMT+0100 (BST)
(factory demo): [info] Component 2 created
</code></pre>
<p>Another important use case for the @Inject decorator is using custom types in TypeScript
when the service has different implementation class associated with the provider key,
like in our early examples with LogService and CustomLogService.</p>
<p>Below is an alternative way you can use to import <code>CustomLogService</code> into the component and use all the API exposed:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class Component1Component {

  constructor(@Inject(LogService) logService: CustomLogService) {
    logService.info('Component 1 created');
  }

}
</code></pre>
<p>In this case, you are getting access to real <code>CustomLogService</code> class that is injected by Angular for all the <code>LogService</code> keys.
If your custom implementation has extra methods and properties, not provided by the <code>LogService</code> type, you can use them from within the component now.</p>
<p>This mechanism is often used in unit testing when the Mock classes expose additional features to control the execution and behavior flow.</p>
<h3 id="using-a-value"><a class="header" href="#using-a-value">Using a Value</a></h3>
<p>Another scenario for registering providers in the Angular framework is providing instances directly, without custom or default factories.</p>
<p>The format, in this case, should be as following:</p>
<pre><code class="language-ts">{ provide: &lt;key&gt;, useValue: &lt;value&gt; }
</code></pre>
<p>There are two main scenarios of providing the values.</p>
<p>The first scenario is pretty much similar to the factory functions you can create and initialize the service instance
before other components and services use it.</p>
<p>Below is the basic example of how you can instantiate and register custom logging service by value:</p>
<pre><code class="language-ts">const logService = new CustomLogService();
logService.setPrefix('(factory demo)');

@NgModule({
  // ...
  
  providers: [
    { provide: LogService, useValue: logService }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The second scenario is related to configuration objects you can pass to initialize or setup other components and services.</p>
<p>Let's now register a <code>logger.config</code> provider with a JSON object value:</p>
<pre><code class="language-ts">@NgModule({
  // ...,

  providers: [
    {
      LogService,
      {
        provide: 'logger.config',
        useValue: {
          logLevel: 'info',
          prefix: 'my-logger'
        }
      }
    }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>Now any component, service or directive can receive the configuration values by injecting it as <code>logger.config</code>.
To enable static type checking you can create a TypeScript interface describing the settings object:</p>
<pre><code class="language-ts">export interface LoggerConfig {
  logLevel?: string;
  prefix?: string;
}
</code></pre>
<p>Finally, proceed to the <code>LogService</code> code and inject the JSON object
using the <code>logger.config</code> token and <code>LoggerConfig</code> interface like in the following example:</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class LogService {

  constructor(@Inject('logger.config') config: LoggerConfig) {
    console.log(config);
  }

  info(message: string) {
    console.log(`[info] ${message}`);
  }

}
</code></pre>
<p>For the sake of simplicity we just log the settings content to the browser console.
Feel free to extend the code with configuring the log service behavior based on the incoming setting values.</p>
<p>If you run the web application right now and open the browser console you should see the next output:</p>
<pre><code class="language-text">{
  logLevel: 'info',
  prefix: 'my-logger'
}
</code></pre>
<p>Registering providers with exact values is a compelling feature when it comes to global configuration and setup.
Especially if you are building redistributable components, directives or services that developers can configure from the application level.</p>
<h3 id="using-an-alias"><a class="header" href="#using-an-alias">Using an Alias</a></h3>
<p>The next feature we are going to see in action is &quot;provider alias&quot;.</p>
<p>You are probably not going to use this feature frequently in applications,
but it is worth taking a look at what it does if you plan to create and maintain redistributable component libraries.</p>
<p>Let's imagine a scenario when you have created a shared component library with an <code>AuthenticationService</code> service
that performs various login and logout operations that you and other developers
can reuse across multiple applications and other component libraries.</p>
<p>After some time you may find another service implementation with the same APIs,
or let's assume you want to replace the service with a newer <code>SafeAuthenticationService</code> implementation.</p>
<p>The main issue you are going to come across when replacing Types is related to breaking changes.
The old service might be in use in a variety of modules and applications, many files import the Type,
use in constructor parameters to inject it, and so on.</p>
<p>For the scenario above is where &quot;alias&quot; support comes to the rescue.
It helps you to smooth the transition period for old content and provide backwards compatibility with existing integrations.</p>
<p>Let's now take a look at the next example:</p>
<pre><code class="language-ts">@NgModule({
  // ...
  
  providers: [
    SafeAuthenticationService,
    { provide: AuthenticationService, useExisting: SafeAuthenticationService }
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>As you can see from the example above, we register a new <code>SafeAuthenticationService</code> service
and then declare an <code>AuthenticationService</code> that points to the same <code>SafeAuthenticationService</code>.</p>
<p>Now all the components that use <code>AuthenticationService</code> are going to receive the instance of the <code>SafeAuthenticationService</code> service automatically.
All the newly introduced components can now reference new service without aliases.</p>
<blockquote>
<p><strong>Difference with the &quot;useClass&quot;</strong></p>
<p>You may wonder what's the difference with the <code>useClass</code> provider registration compared to the <code>useExisting</code> one.</p>
<p>When using <code>useClass</code>, you are going to end up with two different instances registered at the same time.
That is usually not a desirable behavior as services may contain events for example, and various components may have issues finding the &quot;correct&quot; instance.</p>
<p>The <code>useExisting</code> approach allows you to have only one singleton instance referenced by two or more injection tokens.</p>
</blockquote>
<h2 id="injection-tokens"><a class="header" href="#injection-tokens">Injection Tokens</a></h2>
<p>As you might have already understood the Angular dependency injection layer keeps a map of providers that are being identified by &quot;keys&quot;,
also known as &quot;injection tokens&quot;, and uses this map to resolve, create and inject instances at runtime.</p>
<p>The injection tokens can be of different types. We have already tried Types and Strings in action in previous sections.</p>
<h3 id="type-tokens"><a class="header" href="#type-tokens">Type Tokens</a></h3>
<p>Type-based injection tokens are the most commonly used way to register providers.
Typically you import the service type from the corresponding file and put it into the <code>providers</code> section of the module.</p>
<pre><code class="language-ts">import { LogService } from './services/log.service';

@NgModule({
  // ...
  
  providers: [
    LogService
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The same applies to custom provider registration options we tried earlier:</p>
<pre><code class="language-ts">providers: [
  { provide: LogService, useClass: LogService },
  { provide: LogService, useFactory: customLogServiceFactory },
  { provide: LogService, useValue: logService },
  { provide: AuthenticationService, useExisting: SafeAuthenticationService }
]
</code></pre>
<p>In all the cases above we use a real Type reference to register a new provider.</p>
<h3 id="string-tokens"><a class="header" href="#string-tokens">String Tokens</a></h3>
<p>Another way to register a provider involves the string-based injection tokens.
Typically you are going to use strings when there is no Type reference available,
for example when registering plain values or objects:</p>
<pre><code class="language-ts">providers: [
  { provide: 'DATE_NOW', useFactory: dateFactory },
  { provide: 'APP_VERSION', useValue: '1.1.0' },
  {
    provide: 'logger.config',
    useValue: {
      logLevel: 'info',
      prefix: 'my-logger'
    }
  }
]
</code></pre>
<h3 id="generic-injectiontoken"><a class="header" href="#generic-injectiontoken">Generic InjectionToken</a></h3>
<p>Also, Angular provides a special generic class <code>InjectionToken&lt;T&gt;</code> to help you create custom injection tokens
backed by specific types: primitives, classes or interfaces.
That enables static type checks and prevents many type-related errors at early stages.</p>
<p>Let's create separate file <code>tokens.ts</code> to hold our custom injection tokens, and create a simple string-based one:</p>
<pre><code class="language-ts">import { InjectionToken } from '@angular/core';

export const REST_API_URL = new InjectionToken&lt;string&gt;('rest.api.url');
</code></pre>
<p>Now we can use this token within the main application module to register a URL value
that all components and services can use when needed:</p>
<pre><code class="language-ts">import { REST_API_URL } from './tokens';

@NgModule({
  // ...,

  providers: [
    // ...,
    
    { provide: REST_API_URL, useValue: 'http://localhost:4200/api' }
  ]
})
</code></pre>
<p>From this moment we can use the same token to import registered value in the service or a component like in the example below:</p>
<pre><code class="language-ts">// ...

import { REST_API_URL } from './../tokens';

@Injectable({ providedIn: 'root' })
export class LogService {

  constructor(@Inject(REST_API_URL) restApiUrl: string) {
    console.log(restApiUrl);
  }

  // ...
}
</code></pre>
<p>At runtime, you should see the actual value of the <code>REST_API_URL</code> provider in the browser console: <code>http://localhost:4200/api</code>.</p>
<p>As mentioned earlier, you can also use interfaces or classes with the <code>InjectionToken&lt;T&gt;</code>.
That does not affect the process of dependency injection but gives you an opportunity for static compile-time checks
and auto completion if your code editor supports TypeScript.</p>
<p>Let's create a token for the <code>LoggerConfig</code> interface we set up in this chapter earlier:</p>
<pre><code class="language-ts">export interface LoggerConfig {
  logLevel?: string;
  prefix?: string;
}

export const LOGGER_CONFIG = new InjectionToken&lt;LoggerConfig&gt;('logger.config');
</code></pre>
<p>You can now define a type-safe configuration object and register it with the dependency injection system using main application module:</p>
<pre><code class="language-ts">const loggerConfig: LoggerConfig = {
  logLevel: 'warn',
  prefix: 'warning:'
};

@NgModule({
  // ...,
  
  providers: [
    // ...,
    
    { provide: LOGGER_CONFIG, useValue: loggerConfig }
  ]
})
</code></pre>
<p>Finally, you can use that token to inject configuration into the LogService and use it to setup the service accordingly:</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class LogService {

  constructor(@Inject(LOGGER_CONFIG) config: LoggerConfig) {
    console.log(config);
  }

  // ...
}
</code></pre>
<h2 id="injecting-multiple-instances"><a class="header" href="#injecting-multiple-instances">Injecting Multiple Instances</a></h2>
<p>Previously we have been working with injectables backed by the singletons.
That means any components, directives or other services are typically referencing the same instance created only once on the very first request.</p>
<p>There are cases, however, when you may want to have multiple service instances injected at runtime utilizing a single injection token.</p>
<p>An excellent example is plugin systems and plugins support.
Typically you are going to require a special contract or interface that every external plugin must implement.
The service, component or an application layer need to rely on only the common and shared API,
and it makes sense injecting an entire collection of the plugin instances without knowing exact types.</p>
<p>Let's build a logging service that supports external plugins and injects them as a single collection.</p>
<p>First, create a <code>LogPlugin</code> interface for external plugin implementation,
and a basic <code>CompositeLogService</code> scaffold for our service.</p>
<p>We are going to get back to it shortly.</p>
<pre><code class="language-ts">// src/app/services/composite-log.service.ts

export interface LogPlugin {
  name: string;
  level: string;
  log(message: string);
}

@Injectable({ providedIn: 'root' })
export class CompositeLogService {

  constructor() { }

}
</code></pre>
<p>The <code>LogPlugin</code> interface contains a bare minimum of APIs, at this point we need a <code>name</code> for demo and debugging purposes,
alongside the level of the messages our plugin supports and the method to write a log message.</p>
<p>Next, create an injection token <code>LOGGER_PLUGIN</code> backed by the interface we have just created above.</p>
<pre><code class="language-ts">// src/app/tokens.ts

import { LogPlugin } from './services/composite-log.service';

export const LOGGER_PLUGIN = new InjectionToken&lt;LogPlugin&gt;('logger.plugin');
</code></pre>
<p>We are going to use that token to register various logger plugins, and also inject existing plugin instances for the <code>CompositeLogService</code>.</p>
<p>After that let's create a couple of Loggers that implement the <code>LogPlugin</code> interface.
There is going to be one class for error messages and one for warnings.</p>
<pre><code class="language-ts">import { LogPlugin } from './composite-log.service';

export class ErrorLogPlugin implements LogPlugin {

    name = 'Error Log Plugin';
    level = 'error';

    log(message: string) {
      console.error(message);
    }
}

export class WarningLogPlugin implements LogPlugin {

  name = 'Warning Log Plugin';
  level = 'warn';

  log(message: string) {
    console.warn(message);
  }
}
</code></pre>
<p>Now you are ready to register the service and its plugins with the main application module like in the following example:</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { LOGGER_PLUGIN } from './tokens';
import { ErrorLogPlugin, WarningLogPlugin } from './services/loggers';


@NgModule({
  providers: [
    CompositeLogService,
    { provide: LOGGER_PLUGIN, useClass: ErrorLogPlugin, multi: true },
    { provide: LOGGER_PLUGIN, useClass: WarningLogPlugin, multi: true }
  ]
})
</code></pre>
<p>Please note that the most important part that enables multiple injections is the <code>multi</code> attribute we set to <code>true</code> when registering a provider.</p>
<p>Now let's get back to our <code>CompositeLogService</code> and inject instances of all previously registered plugins using the following format:</p>
<pre><code class="language-ts">constructor(@Inject(LOGGER_PLUGIN) plugins: LogPlugin[])
</code></pre>
<p>To demonstrate the instances, we are going to enumerate the injected collection and log all plugin names to the browser console:</p>
<pre><code class="language-ts">// src/app/services/composite-log.service.ts

import { Injectable, Inject } from '@angular/core';
import { LOGGER_PLUGIN } from './../tokens';

export interface LogPlugin {
  name: string;
  level: string;
  log(message: string);
}

@Injectable({ providedIn: 'root' })
export class CompositeLogService {

  constructor(@Inject(LOGGER_PLUGIN) private plugins: LogPlugin[]) {
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      for (const plugin of plugins) {
        console.log(`Loading plugin: ${plugin.name} (level: ${plugin.level})`);
      }
    }
  }

}
</code></pre>
<p>The service is ready for testing. The only thing we have left is to inject it somewhere.
The main application component is the best place to test all the newly introduced code quickly.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { CompositeLogService } from './services/composite-log.service';

@Component({/*...*/})
export class AppComponent {
  
  constructor(private logService: CompositeLogService) {
  }
  
}
</code></pre>
<p>Now if you run the application the console log is going to contain the following output:</p>
<pre><code class="language-text">Loading plugin: Error Log Plugin (level: error)
Loading plugin: Warning Log Plugin (level: warn)
</code></pre>
<p>In the real-life scenario, you would most probably want the log service to use different types of plugins for certain purposes.
Let's now extend our service and introduce a <code>log</code> method redirects logging calls to the plugins that support the corresponding levels.</p>
<pre><code class="language-ts">// src/app/services/composite-log.service.ts

@Injectable({ providedIn: 'root' })
export class CompositeLogService {
  // ...

  log(level: string, message: string) {
    const logger = this.plugins.find(p =&gt; p.level === level);
    if (logger) {
      logger.log(message);
    }
  }
  
}
</code></pre>
<p>To test how it works you can even use the <code>log</code> method within the service itself.
Update the constructor to send a message once all the external plugins are enumerated:</p>
<pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class CompositeLogService {
  
  constructor(@Inject(LOGGER_PLUGIN) private plugins: LogPlugin[]) {
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      for (const plugin of plugins) {
        console.log(`Loading plugin: ${plugin.name} (level: ${plugin.level})`);
      }
      this.log('warn', 'All plugins loaded');
    }
  }
  
}
</code></pre>
<p>For the sake of simplicity, we are going to use the <code>warn</code> level because we got only <code>warn</code> and <code>error</code> loggers registered.
Feel free to extend the collection of the loggers with the <code>info</code> or <code>debug</code> one as an exercise.</p>
<p>Once you run the web application, the main component should provide the following output to the browser console:</p>
<pre><code class="language-text">Loading plugin: Error Log Plugin (level: error)
Loading plugin: Warning Log Plugin (level: warn)
All plugins loaded
</code></pre>
<p>Now you are ready to deal with multiple instances injected as collections and got a basic scenario working in practice.</p>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional Dependencies</a></h2>
<p>Previously, we have successfully created a <code>CompositeLogService</code> service
based on multiple plugins injected with the same custom token.</p>
<p>However, what happens when there are no logger plugins registered within the application?
Let's comment out the plugin registration section in the app module providers to see what happens at runtime.</p>
<pre><code class="language-ts">@NgModule({
  providers: [
    CompositeLogService // ,
    // { provide: LOGGER_PLUGIN, useClass: ErrorLogPlugin, multi: true },
    // { provide: LOGGER_PLUGIN, useClass: WarningLogPlugin, multi: true }
  ]
})
</code></pre>
<p>Now if you rebuild and run your application it is going to crash with the following error in the browser console:</p>
<pre><code class="language-text">Error: No provider for InjectionToken logger.plugin!
</code></pre>
<p>The error above is an expected behavior.</p>
<p>Essentially, when you declare a dependency within the constructor parameters,
you instruct the Angular framework to ensure the corresponding dependency indeed exists, and injection can happen.</p>
<p>There are scenarios when having an instance is not mandatory, and application can function without it,
like in our case with logger plugins - the log service can have default fallback behaviour in case no plugins are present.</p>
<p>For those kinds of scenarios, the Angular framework provides us with the &quot;@Optional&quot; decorator
that allows making particular injections &quot;optional&quot; rather than &quot;mandatory&quot; during dependency injection phase.</p>
<pre><code class="language-ts">import { /*...,*/ Optional } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CompositeLogService {

  constructor((@Optional() @Inject(LOGGER_PLUGIN) private plugins: LogPlugin[]) {
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      // ...
    } else {
      console.log('No logger plugins found.');
    }
  }

 // ...
}
</code></pre>
<p>As you can see from the code above, we now have a possibility to check whether any plugins are available,
and perform the fallback behavior if needed.
Just for the demo purposes, we log the information message to the console:</p>
<pre><code class="language-text">No logger plugins found.
</code></pre>
<p>The <code>@Optional</code> decorator is a handy mechanism that helps you to prevent the runtime errors
when some content is missing or is not registered correctly.</p>
<h2 id="manual-injection"><a class="header" href="#manual-injection">Manual Injection</a></h2>
<p>You are not limited to automatic dependency injection mechanism.
The Angular provides you with a low-level APIs that allow you to resolve and create instances manually from code.</p>
<p>The DI utility class is called <code>ReflectiveInjector</code>, and you can import it from the <code>@angular/core</code> namespace.
It helps to create the <code>injectors</code> filled with resolved and created instances of the providers,
similar to those we used with the application modules.</p>
<pre><code class="language-ts">import { ReflectiveInjector } from '@angular/core';

@Component({/*...*/})
export class AppComponent {
  
  constructor() {
    const injector = ReflectiveInjector.resolveAndCreate([ LogService ]);
    const logService: LogService = injector.get(LogService);
    logService.info('hello world');
  }

}
</code></pre>
<p>Typically you are going to use this API only for concrete scenarios like unit testing or dynamic content creation.</p>
<blockquote>
<p>You can get more detailed information including code examples in the following article: <a href="https://angular.io/api/core/ReflectiveInjector">Reflective Injector</a>.</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We have covered the main scenarios for service and provider registration and tested them in action.</p>
<p>You can also refer to the <a href="https://angular.io/guide/dependency-injection#dependency-injection">Dependency Injection</a> article
for even more detailed information on how dependency injection works in Angular.</p>
<h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>There are three main event cases we are going to review in this chapter.
With Angular, you can raise Component events, DOM events and Service events.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/events">angular/events</a></strong> folder.</p>
</blockquote>
<p>To address all three scenarios let's create a simple <code>Panel</code> component that consists of the <code>Body</code>, <code>Header</code> and <code>Footer</code>.
The Header and Footer are going to be separate components.</p>
<p>First, generate a new Angular application using the Angular CLI tool.
Then execute the following commands to generate the prerequisites:</p>
<pre><code class="language-sh">ng g component panel
ng g component panel-header
ng g component panel-footer
</code></pre>
<p>Next, update the <code>Panel</code> component template like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/panel/panel.component.html --&gt;

&lt;app-panel-header&gt;&lt;/app-panel-header&gt;

&lt;p&gt;
  panel works!
&lt;/p&gt;

&lt;app-panel-footer&gt;&lt;/app-panel-footer&gt;
</code></pre>
<p>Finally, we can replace the default auto-generated content of the main application template
with the <code>Panel</code> we have just created above:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-panel&gt;
&lt;/app-panel&gt;
</code></pre>
<p>If you make a pause at this point and run the <code>ng serve --open</code> command you should see the following output on the main page:</p>
<pre><code class="language-text">panel-header works!

panel works!

panel-footer works!
</code></pre>
<p>At this point, we got all the basic prerequisites for testing the events.</p>
<h2 id="component-events"><a class="header" href="#component-events">Component Events</a></h2>
<p>It is now time to improve our <code>Header</code> component.</p>
<p>Let's provide a way to set the content text for the component to display when rendered,
and a simple click event <code>contentClick</code> that gets emitted every time user clicks the content.</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

import { /*...,*/ Input, Output, EventEmitter } from '@angular/core';

@Component({...})
export class PanelHeaderComponent {

  @Input()
  content = 'Panel header';

  @Output()
  contentClick = new EventEmitter();

  onContentClicked() {
    console.log('panel header clicked');
    this.contentClick.next();
  }

}
</code></pre>
<p>From the earlier chapters, you already know that we use <code>@Input</code> decorator
for the class properties we want to set or bind from the outside.
We also need to use the <code>@Output</code> decorator to mark our events.</p>
<blockquote>
<p><strong>Output Events</strong></p>
<p>You can get more details on the component events in the <a href="ch07-01-component-events.html#output-events">Output Events</a> section of the Components chapter.</p>
</blockquote>
<p>Also, note that in the example above we also add the <code>onContentClicked</code> method that is going to raise our <code>contentClick</code> event.</p>
<p>Below is an example of a minimal <code>Header</code> component template we can use to display a <code>content</code> value:</p>
<pre><code class="language-html">&lt;!-- src/app/panel-header/panel-header.component.html --&gt;

&lt;p (click)=&quot;onContentClicked()&quot;&gt;
    {{ content }}
&lt;/p&gt;
</code></pre>
<p>As you can see, we link the <code>click</code> event of the enclosed <code>p</code> element with the <code>onContentClicked</code> handler
that temporarily sends a message to the console log for testing/debugging purposes
and also invokes the <code>contentClicked</code> event that other components can use.</p>
<p>Also, we set a default value for the <code>content</code> property to the &quot;Panel header&quot; string.
So at the runtime, the content or application main page is going to look similar to the following:</p>
<pre><code class="language-text">Panel header

panel works!

panel-footer works!
</code></pre>
<p>However, we are not going to use the <code>Header</code> component directly.
It is the <code>Panel</code> component that needs it.
So we should allow our <code>Panel</code> component to control the header content, and also react on header click events.
Let's toggle the panel content as an example.</p>
<p>Edit the panel component class and add the <code>header</code> input property to hold the text for the <code>Header</code>,
and <code>displayBody</code> property to serve as a flag for showing and hiding the main panel content,
like in the example below:</p>
<pre><code class="language-ts">// src/app/panel/panel.component.ts

import { /*...,*/ Input } from '@angular/core';

@Component({...})
export class PanelComponent {

  @Input()
  header = 'My panel header';

  displayBody = true;
}
</code></pre>
<p>For the next step, let's update the panel component template
to link the <code>Header</code> properties with the newly introduced class members:</p>
<pre><code class="language-html">&lt;!-- src/app/panel/panel.component.html --&gt;

&lt;app-panel-header
  [content]=&quot;header&quot;
  (contentClick)=&quot;displayBody = !displayBody&quot;&gt;
&lt;/app-panel-header&gt;

&lt;ng-container *ngIf=&quot;displayBody&quot;&gt;
  &lt;p&gt;
    panel works!
  &lt;/p&gt;
&lt;/ng-container&gt;

&lt;app-panel-footer&gt;&lt;/app-panel-footer&gt;
</code></pre>
<p>You can now run the application and test your components by clicking the panel header text multiple times.
The panel should toggle its body content every time a header gets clicked.</p>
<p>Below is how the panel should look like by default, in the expanded state:</p>
<pre><code class="language-text">My panel header

panel works!

panel-footer works!
</code></pre>
<p>Also, the next example shows how the panel looks like in the <code>collapsed</code> state:</p>
<pre><code class="language-text">My panel header

panel-footer works!
</code></pre>
<p>Congratulations, you just got the component events working, and tested them in practice.
Now feel free to extend the <code>PanelFooterComponent</code> and add similar <code>content</code> and <code>contentClick</code> implementations.</p>
<h3 id="bubbling-up-child-events"><a class="header" href="#bubbling-up-child-events">Bubbling Up Child Events</a></h3>
<p>We have created a <code>PanelHeader</code> component earlier in this chapter.
Also, we introduced a <code>click</code> event for the component and made the <code>Panel</code> component host it within its template,
and toggle panel body content every time the <code>Panel Header</code> is clicked.</p>
<p>Imagine that the <code>&lt;app-panel&gt;</code> is a redistributable component, and you would like developers to have access to header clicks as well.
The <code>&lt;app-panel-header&gt;</code> however, is a child element, and developers do not have direct access to its instance when working with the <code>Panel</code>.
In this case, you would probably want your main <code>Panel</code> component re-throwing its child events.</p>
<p>We already got the <code>header</code> and the <code>footer</code> input properties that hold the values for the <code>&lt;app-panel-header</code> and <code>&lt;app-panel-footer&gt;</code> elements.
Let's now introduce two new output events and call them <code>headerClick</code> and <code>footerClick</code>.</p>
<pre><code class="language-ts">// src/app/panel/panel.component.ts

export class PanelComponent {

  displayBody = true;

  @Input()
  header = 'My panel header';

  @Input()
  footer = 'My panel footer';

  @Output()
  headerClick = new EventEmitter();

  @Output()
  footerClick = new EventEmitter();

  onHeaderClicked() {
    this.displayBody = !this.displayBody;
    this.headerClick.next();
  }

  onFooterClicked() {
    this.footerClick.next();
  }

}
</code></pre>
<p>As you can see from the code above, we also get two methods to raise our events.
The <code>onHeaderClicked</code> method is still toggling the panel body before raising the <code>headerClick</code> event.</p>
<p>Next, our <code>&lt;app-panel&gt;</code> component is going to watch the <code>contentClick</code> events of the child elements, and emit events for developers.
Update the HTML template and subscribe to the header and footer events like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/panel/panel.component.html --&gt;

&lt;app-panel-header
  [content]=&quot;header&quot;
  (contentClick)=&quot;onHeaderClicked()&quot;&gt;
&lt;/app-panel-header&gt;

&lt;ng-container *ngIf=&quot;displayBody&quot;&gt;
    &lt;p&gt;
        panel works!
    &lt;/p&gt;
&lt;/ng-container&gt;

&lt;app-panel-footer
  [content]=&quot;footer&quot;
  (contentClick)=&quot;onFooterClicked()&quot;&gt;
&lt;/app-panel-footer&gt;
</code></pre>
<p>Finally, let's test our panel events in action.
Update your main application template and subscribe to our newly introduced events for header and footer clicks:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;app-panel
  (headerClick)=&quot;onHeaderClicked()&quot;
  (footerClick)=&quot;onFooterClicked()&quot;&gt;
&lt;/app-panel&gt;
</code></pre>
<p>For the sake of simplicity we are going to log messages to browser console similar to the following:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {

  onHeaderClicked() {
    console.log('App component: Panel header clicked');
  }

  onFooterClicked() {
    console.log('App component: Panel footer clicked');
  }

}
</code></pre>
<p>If you compile and run your web application with the <code>ng serve --open</code> command,
you should be able to see messages in the console every time a header or footer elements of the panel get clicked.</p>
<h2 id="dom-events"><a class="header" href="#dom-events">DOM Events</a></h2>
<p>With multiple levels of nesting, the re-raising of child events quickly turns into a challenging and time-consuming process.
Like with our previous Panel example, to wrap it with another Angular component
developers may have to watch for panel events and raise them for the own implementation.
That is where native DOM events with bubbling support come to the rescue.</p>
<p>If set to bubble, a DOM event gets raised for every element up against the parent hierarchy.
Developers get an opportunity reacting on events that occur in deeply nested components.</p>
<blockquote>
<p><strong>Creating and triggering events</strong></p>
<p>You can get more details and examples on how to build and dispatch DOM events in the following article:
<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events">Creating and triggering events</a></p>
</blockquote>
<p>First, to raise a custom DOM event we need to get access to a native element of the component.
You can achieve that by injecting an <code>ElementRef</code> instance in the component constructor,
and saving as a private property called <code>elementRef</code>.</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

import { /*...,*/ ElementRef } from '@angular/core';

@Component({/*...*/})
export class PanelHeaderComponent {

    // ...

    constructor(private elementRef: ElementRef) {
    }

}
</code></pre>
<p>Next, we need updating the <code>onContentClicked</code> handler to raise an additional event.
You can leave the code to raise the <code>contentClick</code> event, so that component supports raising two types of the events at the same time.</p>
<p>Let's introduce a new <code>header-click</code> custom event that is set to bubble and contains clicked content in the <code>details</code> section.</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

@Component({/*...*/})
export class PanelHeaderComponent {

  // ...

  onContentClicked() {
    this.contentClick.next();

    this.elementRef.nativeElement.dispatchEvent(
      new CustomEvent('header-click', {
        detail: {
          content: this.content
        },
        bubbles: true
      })
    );
  }

}
</code></pre>
<p>We are now ready to see the newly introduced event in practice.</p>
<p>Let's update the main application component template with a top-most <code>div</code> element that is going to listen to the <code>header-click</code> event.
That is a good case to test event handling and see how event bubbles up to non-Angular elements.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div (header-click)=&quot;onDomHeaderClick($event)&quot;&gt;
  &lt;app-panel
    (headerClick)=&quot;onHeaderClicked()&quot;
    (footerClick)=&quot;onFooterClicked()&quot;&gt;
  &lt;/app-panel&gt;
&lt;/div&gt;
</code></pre>
<p>For testing purposes, we are going just to log the event details to the browser console.</p>
<pre><code class="language-ts">@Component({/*...*/})
export class AppComponent {

  // ...

  onDomHeaderClick(event) {
    console.log(event);
  }

}
</code></pre>
<p>Finally, if you run your web application at this point, and click the panel header content,
the following content should appear in the browser console output:</p>
<p><img src="images/ng-events-dom-01.png" alt="" /></p>
<p>As you can see from the picture above you can access all data in the custom event
including the &quot;detail&quot; object we have created earlier, and that contains our component-specific information.</p>
<p>Dispatching the custom DOM events is an excellent option if you want to allow developers to wrap your components,
or you are using composite components and trying to avoid re-throwing multiple events.</p>
<h2 id="service-events"><a class="header" href="#service-events">Service Events</a></h2>
<p>When working with events in Angular, you can achieve a significant level of flexibility
by utilizing the application services and service events.</p>
<p>Service-based events allow multiple components to communicate with each other
regardless of the component and DOM structure using the publish/subscribe approach.</p>
<p>Before we dive into details let's use Angular CLI and generate a new service using the following command:</p>
<pre><code class="language-sh">ng g service panel
</code></pre>
<p>You need to manually register the newly generated service within one of your modules.
For now, let's add the <code>PanelService</code> to the main application module in the <code>app.module.ts</code> file:</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { PanelService } from './panel.service';

@NgModule({
  providers: [
    PanelService
  ]
})
export class AppModule { }
</code></pre>
<p>Next, extend the service with a couple of events for header and footer clicks:</p>
<pre><code class="language-ts">// src/app/panel.service.ts

import { Injectable } from '@angular/core';
import { Subject } from 'rxjs/Rx';

import { PanelHeaderComponent } from './panel-header/panel-header.component';
import { PanelFooterComponent } from './panel-footer/panel-footer.component';

@Injectable({ providedIn: 'root' })
export class PanelService {

  headerClicked = new Subject&lt;PanelHeaderComponent&gt;();
  footerClicked = new Subject&lt;PanelFooterComponent&gt;();

}
</code></pre>
<p>In the example above, we are using generic <code>Subject&lt;T&gt;</code> to allow both emitting and subscribing to the same event.
We are going to pass either <code>PanelHeaderComponent</code> or <code>PanelFooterComponent</code> instance as the event argument.</p>
<p>Let's update the <code>PanelHeaderComponent</code> class and emit the <code>headerClicked</code> event like in the following example:</p>
<pre><code class="language-ts">// src/app/panel-header/panel-header.component.ts

import { PanelService } from '../panel.service';

@Component({/*...*/})
export class PanelHeaderComponent {

  constructor(
    private panelService: PanelService,
    private elementRef: ElementRef) {
  }

  onContentClicked() {
    // ...
    
    // raise service event
    this.panelService.headerClicked.next(this);
  }
}
</code></pre>
<p>As you can see, the component now injects the <code>PanelService</code> instance
and saves a reference to the private <code>panelService</code> property so that click handler can use to emit the corresponding event.</p>
<p>Subscribing to the event is also simple.
The component, in our case main application one, injects the <code>PanelService</code>
and uses <code>headerClicked.subscribe</code> to wire the event handler code:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { PanelHeaderComponent } from './panel-header/panel-header.component';
import { PanelService } from './panel.service';

@Component({/*...*/})
export class AppComponent {

  constructor(panelService: PanelService) {
    panelService.headerClicked.subscribe(
      (header: PanelHeaderComponent) =&gt; {
        console.log(`Header clicked: ${header.content}`);
      }
    );
  }
}
</code></pre>
<p>Now if you run your web application and click the header you should see the following output in the browser console:</p>
<pre><code class="language-text">Header clicked: My panel header
</code></pre>
<p>Congratulations, you have just established a basic communication channel between header
and footer components with the rest of the application content.</p>
<p>Many other components and services now can subscribe and react to click events.
Of course, we got over-simplified examples; you can imagine more complex scenarios involving different events in your application.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/events">angular/events</a></strong> folder.</p>
</blockquote>
<h1 id="directives"><a class="header" href="#directives">Directives</a></h1>
<p>A directive is one of the core building blocks in Angular.</p>
<p>It allows easy manipulation of the DOM structure of HTML elements, change their appearance and layout,
or even extend the behavior if needed.</p>
<h2 id="introduction-to-directives"><a class="header" href="#introduction-to-directives">Introduction to Directives</a></h2>
<p>There are three types of directives in Angular you are going to work with:</p>
<ul>
<li><strong>Components</strong> - also known as <code>Directives with Templates</code>, see <strong><a href="ch05-01-components.html">Components</a></strong> chapter for a detailed overview;</li>
<li><strong>Attribute Directives</strong> - extend elements, change the look and feel of the host elements;</li>
<li><strong>Structural Directives</strong> - change elements, manipulate DOM layout, add or remove elements or completely change underlying view;</li>
</ul>
<p>Let's start with a new project to host various kinds of directives we are going to experiment with:</p>
<pre><code class="language-sh">ng new directive-example
cd directive-example
ng serve --open
</code></pre>
<h2 id="attribute-directives"><a class="header" href="#attribute-directives">Attribute Directives</a></h2>
<p>Attribute directives change appearance or behavior of a host DOM element.
Usually, they look like regular HTML element attributes.</p>
<p>Let's create a simple clickable directive and call it <code>Clickme</code>.</p>
<pre><code class="language-sh">ng g directive directives/clickme
</code></pre>
<p>Angular CLI generates directive with unit test and updates main application module:</p>
<pre><code class="language-sh">installing directive
  create src/app/directives/clickme.directive.spec.ts
  create src/app/directives/clickme.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>Initial implementation should look like the following one:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appClickme]'
})
export class ClickmeDirective {

  constructor() { }

}
</code></pre>
<p>Directives can interact with the host by listening to events and setting properties of the target element.</p>
<h3 id="handling-host-events"><a class="header" href="#handling-host-events">Handling host events</a></h3>
<p>Your newly created directive can listen to events with the help of the <code>HostListener</code> decorator.
Angular invokes decorated method when the host element emits a corresponding event.</p>
<p>The format of the <code>HostListener</code> decorator and metadata is as following:</p>
<pre><code class="language-ts">interface HostListener {

  eventName : string
  args : string[]

}
</code></pre>
<p>You can use it to decorate class methods like shown below:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

@HostListener('domEvent', ['$event'])
onEvent(event) {
  // ...
}
</code></pre>
<p>Angular should be listening for the 'domEvent' event (if supported by host element)
and invoke <code>onEvent</code> method of the directive controller.</p>
<p>The event handler is also going to get a reference to the original DOM event,
as we instruct Angular to map specific <code>$event</code> argument to the <code>event</code> parameter.
That means directive can inspect properties of the original event
and even prevent default behavior or event bubbling if necessary.</p>
<p>The easiest way to demonstrate <code>HostListener</code> in action is by wiring a standard <code>click</code> event.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

import { /*...,*/ HostListener } from '@angular/core';

...
export class ClickmeDirective {
    // ...
    
    @HostListener('click', ['$event'])
    onClicked(e: Event) {
        console.log(e);
        alert('Clicked');
    }
}
</code></pre>
<p>Next put a <code>div</code> element to the <code>app.component.html</code> and decorate it with your <code>appHighlight</code> directive:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;div class=&quot;click-area&quot; appClickme&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>You also need to have some space to click on; this is what we are going to use <code>highlight-area</code> CSS class for:</p>
<pre><code class="language-css">/* src/app/app.component.css */

.click-area {
  width: 100px;
  height: 100px;
  background-color: beige;
}
</code></pre>
<p>Below is how the main page looks like after your changes:</p>
<p><img src="images/directives-clickme-01.png" alt="" /></p>
<p>You get the default 'app works!' label generated by the Angular CLI, and coloured <code>div</code> element.
Now if you click anywhere on the beige area the browser should display an alert: </p>
<p><img src="images/directives-clickme-02.png" alt="" /></p>
<p>So as you can see in the example above, with the help of <code>HostListener</code>, you can listen to any event emitted by host element.
We have added <code>appClickme</code> directive as an attribute of the <code>div</code>, 
and every click on the <code>div</code> automatically triggers <code>onClicked</code> method in the <code>ClickmeDirective</code>.</p>
<p>You can use any target for the directive, for example:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;button appClickme&gt;Click me&lt;/button&gt;
&lt;span appClickme&gt;Click me&lt;/span&gt;
&lt;input type=&quot;text&quot; appClickme&gt;
</code></pre>
<h3 id="host-members-binding"><a class="header" href="#host-members-binding">Host members binding</a></h3>
<p>Angular also provides a way for a directive to change host properties by using a <code>HostBinding</code> decorator.</p>
<p>During change detection cycle Angular checks all property bindings and updates host element of the directive if bound value changes.</p>
<p>The format of the HostBinding decorator and metadata is as following:</p>
<pre><code class="language-ts">interface HostBinding {

  hostPropertyName : string

}
</code></pre>
<p>You can use this decorator to change:</p>
<ul>
<li>
<p>attributes (applies to all elements)</p>
<p><code>@HostBinding('attr.text)</code></p>
</li>
<li>
<p>properties (corresponding properties must exist)</p>
<p><code>@HostBinding('title')</code></p>
</li>
<li>
<p>style values (applies to all elements)</p>
<p><code>@HostBinding('style.background-color')</code></p>
</li>
<li>
<p>class names (applies to all elements)</p>
<p><code>@HostBinding('class.some-class-name')</code></p>
</li>
</ul>
<h4 id="binding-element-attributes"><a class="header" href="#binding-element-attributes">Binding element attributes</a></h4>
<p>If you want your directive to change element attributes, you can use this decorator with class methods like below:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts

export class ClickmeDirective {

    @HostBinding('attr.propertyName')
    myProperty: string = 'hello world';

}
</code></pre>
<p>For example, if you apply directive to a <code>div</code> element, the property binding should cause the following attributes rendering at run time:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; propertyName=&quot;hello world&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Please note that if host property name parameter is not defined, then a class property name should be taken as a fallback value.</p>
<pre><code class="language-ts">@HostBinding()
title: string = 'element title';
</code></pre>
<p>This time, if you apply the directive to the <code>input</code> element, for instance, you should see the <code>title</code> property name as an attribute of the host:</p>
<pre><code class="language-ts">&lt;input appclickme=&quot;&quot; type=&quot;text&quot; title=&quot;element title&quot;&gt;
</code></pre>
<h4 id="binding-element-properties"><a class="header" href="#binding-element-properties">Binding element properties</a></h4>
<p>Keep in mind that in this case, the property should exist for a given element.
Angular should throw an error if you try to bind a missing property.</p>
<p>Let's try to bind a <code>value</code> property to demonstrate this behavior.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...
export class ClickmeDirective {

  @HostBinding()
  value: string = 'input value';

  // ...
}
</code></pre>
<p>You may still have a click area example on the main page, or you can do it once again:</p>
<pre><code class="language-html">&lt;div class=&quot;click-area&quot; appClickme&gt;
</code></pre>
<p>Angular should produce an error when page compiles and reloads:</p>
<pre><code class="language-text">Error: Uncaught (in promise): Error: Template parse errors:
Can't bind to 'value' since it isn't a known property of 'div'.

[ERROR -&gt;]&lt;div class=&quot;click-area&quot; appClickme&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>However, if you replace <code>div</code> with an <code>input</code> element that natively supports <code>value</code> property, you should get it rendered properly:</p>
<p><img src="images/directives-input-01.png" alt="" /> </p>
<p>You can, however, fix the issue and provide compatibility with all HTML elements by utilizing <code>attr.value</code> instead of <code>value</code> for the property binding:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...
export class ClickmeDirective {

  @HostBinding('attr.value')
  value: string = 'input value';

  // ...
}
</code></pre>
<p>In this case you are going to get the following HTML when both <code>&lt;input&gt;</code> and <code>&lt;div&gt;</code> are present on the page:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; class=&quot;click-area&quot; value=&quot;input value&quot;&gt;
  Click me
&lt;/div&gt;

&lt;input appclickme=&quot;&quot; type=&quot;text&quot; value=&quot;input value&quot;&gt;
</code></pre>
<p>Your main application component page should now render without errors.</p>
<p><img src="images/directives-input-02.png" alt="" /></p>
<h4 id="binding-style-attributes"><a class="header" href="#binding-style-attributes">Binding style attributes</a></h4>
<p>You bind single style attribute values using <code>@HostBinding('style.&lt;attribute&gt;)</code> format,
where <code>&lt;attribute&gt;</code> is a valid name of the CSS style attribute.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...
export class ClickmeDirective {
    // ...
    
    @HostBinding('style.background-color')
    background: string = 'lightblue';
}
</code></pre>
<p>Now the directive is painting its host element's background into light-blue.</p>
<p><img src="images/directives-input-03.png" alt="" /></p>
<p>This is how the rendered HTML looks like:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; class=&quot;click-area&quot; value=&quot;input value&quot; 
     style=&quot;background-color: rgb(173, 216, 230);&quot;&gt;
  Click me
&lt;/div&gt;
</code></pre>
<h4 id="binding-class-names"><a class="header" href="#binding-class-names">Binding Class Names</a></h4>
<p>Instead of binding single style attributes, you may want to operate CSS class names,
to be able providing external themes, or separating presentation layer from directive implementation.
It can be achieved by utilizing <code>@HostBinding('class.&lt;class-name&gt;')</code> where <code>&lt;class-name&gt;</code> is the name of the CSS class.</p>
<p>Note that having corresponding CSS class implementation is optional if you directive is not enforcing styles directly.
Developers can choose whether to implement or override the class, or leave defaults.</p>
<p>You can bind class names to the <code>boolean</code> values or expressions.
Angular appends provided CSS class name to the host element if the resulting value is <code>true</code>, and automatically removes it if value changes back to <code>false</code>.</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...

export class ClickmeDirective {
    // ...

    @HostBinding('class.is-selected')
    isSelected: boolean = true;
}
</code></pre>
<p>This is the initial template we have been using:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div class=&quot;click-area&quot; appClickme&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>So this is how Angular renders component at run time.
Note the <code>class</code> value now has both <code>click-area</code> we defined manually, and <code>is-selected</code> class provided by the directive controller.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appclickme=&quot;&quot; class=&quot;click-area is-selected&quot; value=&quot;input value&quot; 
     style=&quot;background-color: rgb(173, 216, 230);&quot;&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p>Typically you are going to apply or change CSS classes of the host element as a response to the host events wired by <code>HostBinding</code> decorators.</p>
<p>For example, the directive can listen to mouse events and toggle <code>hovered</code> styles:</p>
<pre><code class="language-ts">// src/app/directives/clickme.directive.ts
// ...

export class ClickmeDirective { 
    // ...

    @HostBinding('class.is-hovered')
    isHovered: boolean = false;

    @HostListener('mouseenter')
    onMouseEnter() {
        this.isHovered = true;
        // other code if needed
    }

    @HostListener('mouseleave')
    onMouseLeave() {
        this.isHovered = false;
        // other code if needed
    }
}
</code></pre>
<p>Our directive toggles the <code>isHovered</code> property value upon mouse enter and leave,
but it does not directly change the way its host element looks.
Instead, you or developers that use your directive can optionally add a custom <code>is-hovered</code> CSS class
to alter how the element looks and behaves on mouse interaction.</p>
<p>The example below adds a thin dashed border to the element when a user hovers it:</p>
<pre><code class="language-css">/* src/app/app.component.css */

.is-hovered {
  border: 1px dashed darkblue;
}
</code></pre>
<p>You can now run the application and move the mouse cursor in and out of the click area.</p>
<p><img src="images/directives-hover-01.png" alt="" /></p>
<p>Of course, you can control hover styles in pure CSS.
The code above is more a simple demonstration of capabilities to give you more ideas
on what is possible with <code>HostListener</code> and <code>HostBinding</code> combined.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/directive-example">angular/directives/directive-example</a></strong> folder.</p>
</blockquote>
<h3 id="built-in-attribute-directives"><a class="header" href="#built-in-attribute-directives">Built-in Attribute Directives</a></h3>
<p>Angular comes with the following ready-to-use attribute directives:</p>
<ul>
<li><a href="ch08-02-attribute-directives.html#ngstyle">NgStyle</a>, updates an HTML element styles</li>
<li><a href="ch08-02-attribute-directives.html#ngclass">NgClass</a>, adds and removes CSS classes on an HTML element</li>
<li><strong>NgModel</strong>, provides two-way binding to Form elements, see <strong>Forms</strong> chapter for more details</li>
<li><a href="ch08-02-attribute-directives.html#ngnonbindable">NgNonBindable</a>, prevents content from being evaluated and compiled in templates</li>
</ul>
<h4 id="ngstyle"><a class="header" href="#ngstyle">NgStyle</a></h4>
<p>The <code>NgStyle</code> directive is used to modify CSS style attributes of the host element or component.</p>
<pre><code class="language-html">&lt;element [ngStyle]=&quot;OPTIONS&quot;&gt;
    ...
&lt;/element&gt;
</code></pre>
<p>Where <code>OPTIONS</code> is an object literal <code>NgStyle</code> that binds and maps properties to style attributes.
Object keys should represent style names with an optional <code>.&lt;unit&gt;</code> suffix, for example, <code>width.px</code>, <code>font-style.em</code>.</p>
<pre><code class="language-html">&lt;button [ngStyle]=&quot;{ 'border-width': '1px' }&quot;&gt;button 1&lt;/button&gt;
&lt;button [ngStyle]=&quot;{ 'border-width.px': '1' }&quot;&gt;button 2&lt;/button&gt;
&lt;button [ngStyle]=&quot;{
  'background-color': 'white',
  'border': '1px blue solid'
}&quot;&gt;button 3&lt;/button&gt;
</code></pre>
<p>You should see three buttons with custom styles once you run the application:</p>
<p><img src="images/directives-ngstyle-01.png" alt="" /></p>
<p>It is also possible to bind <code>ngStyle</code> to the component property.</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; value=&quot;hello world&quot; [ngStyle]=&quot;inputStyle&quot;&gt;
</code></pre>
<p>In this case, you declare object literal within the component class implementation, for example:</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...

export class AppComponent {
    // ...
    
    inputStyle = {
        'border': '1px green solid',
        'background-color': 'white',
        'color': 'blue'
    };
}
</code></pre>
<p>That allows you to compose styles based on some other conditions dynamically.</p>
<p><img src="images/directives-ngstyle-02.png" alt="Directives with NgStyle" /></p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/attribute-directives">angular/directives/attribute-directives</a></strong> folder.</p>
</blockquote>
<h4 id="ngclass"><a class="header" href="#ngclass">NgClass</a></h4>
<p>The <code>NgClass</code> directive allows binding CSS class names on an HTML element.</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;OPTIONS&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<p>Where the <code>OPTIONS</code> value can take one of the following formats:</p>
<ul>
<li>string expression (single or <code>space</code> delimited)</li>
<li>object literal</li>
<li>array</li>
</ul>
<h5 id="binding-to-string-expression-single"><a class="header" href="#binding-to-string-expression-single">Binding to String Expression (single)</a></h5>
<p>With this format you specify a string expression that corresponds to a CSS class name:</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;'class1'&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<h5 id="binding-to-string-expression-space-delimited"><a class="header" href="#binding-to-string-expression-space-delimited">Binding to String Expression (space delimited)</a></h5>
<p>You can also provide multiple class names per single <code>space</code> delimited string expression:</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;'class1 class2 class3'&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<h5 id="binding-to-object-literal"><a class="header" href="#binding-to-object-literal">Binding to Object Literal</a></h5>
<p>This format is very similar to that of <code>NgStyle</code> one.
All object keys are CSS class names and get added to host element only if value evaluates to a truthy value.
In a case of a non-truthy value, Angular removes class names from the host.</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;{
    'class1': true,
    'class2': false,
    'class3': true }&quot;&gt;
    &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<h5 id="binding-to-array"><a class="header" href="#binding-to-array">Binding to Array</a></h5>
<p>Finally you can bind the <code>NgClass</code> directive to an array of class names:</p>
<pre><code class="language-html">&lt;element [ngClass]=&quot;['class1', 'class2', 'class3']&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<p>In all the cases described above you can also bind directive options to underlying controller properties or methods:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;element [ngClass]=&quot;currentClass&quot;&gt;&lt;!-- ... --&gt;&lt;/element&gt;
&lt;element [ngClass]=&quot;getClassObj()&quot;&gt;&lt;!-- ... --&gt;&lt;/element&gt;
&lt;element [ngClass]=&quot;getClassArr()&quot;&gt;&lt;!-- ... --&gt;&lt;/element&gt;
</code></pre>
<pre><code class="language-ts">// src/app/app.component.ts

export class MyComponent {

    currentClass: string = 'class1';

    getClassObj(): any {
      return {
        'class2': true,
        'class3': true
      };
    }

    getClassArr(): string[] {
      return [
        'class4',
        'class5'
      ];
    }
}
</code></pre>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/attribute-directives">angular/directives/attribute-directives</a></strong> folder.</p>
</blockquote>
<h4 id="ngnonbindable"><a class="header" href="#ngnonbindable">NgNonBindable</a></h4>
<p>You use <code>NgNonBindable</code> directive to switch off Angular evaluating code or binding values for a particular element and its content.</p>
<p>For example if you want displaying source code:</p>
<pre><code class="language-html">&lt;h2&gt;NgNonBindable&lt;/h2&gt;
&lt;pre&gt;
  You can bind &lt;strong&gt;title&lt;/strong&gt; property like following:
  &lt;code ngNonBindable&gt;
    &amp;lt;div&amp;gt;{{title}}&amp;lt;/div&amp;gt;
  &lt;/code&gt;
&lt;/pre&gt;
</code></pre>
<p>Which renders to the following if you run the application:</p>
<p><img src="images/directives-non-bindable.png" alt="" /></p>
<p>Please note that the <code>NgNonBindable</code> is a very specific directive, and typically you are not going to use it often, if at all.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the &quot;<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/attribute-directives">angular/directives/attribute-directives</a>&quot; folder.</p>
</blockquote>
<h2 id="structural-directives"><a class="header" href="#structural-directives">Structural Directives</a></h2>
<p>Structural directives allow you to control how element renders at run time.</p>
<h3 id="built-in-structural-directives"><a class="header" href="#built-in-structural-directives">Built-in structural directives</a></h3>
<p>Angular provides a few built-in directives you are going to use very often:</p>
<ul>
<li>NgIf</li>
<li>NgFor</li>
<li>NgSwitch</li>
</ul>
<h4 id="ngif"><a class="header" href="#ngif">NgIf</a></h4>
<p>You are going to use <code>NgIf</code> directive when you want to display or hide decorated element based on condition.</p>
<p>The most common usage format for this directive is</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;&lt;condition&gt;&quot;&gt;
  &lt;!-- ... --&gt;
&lt;/element&gt;
</code></pre>
<p>where <code>&lt;condition&gt;</code> is a valid JavaScript expression.</p>
<p>Let's build an example demonstrating conditional inclusion of the template.
Add a boolean property <code>extraContent</code> to your <code>AppComponent</code> component controller class implementation:</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
  extraContent = false;
}
</code></pre>
<p>Next, put a <code>&lt;button&gt;</code> element to the component template, this button should toggle the <code>extraContent</code> value on each click.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;button (click)=&quot;extraContent = !extraContent&quot;&gt;
  Toggle extra content
&lt;/button&gt;
</code></pre>
<p>Finally, let's add some content that should be displayed only when <code>extraContent</code> property value gets set to <code>true</code></p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div *ngIf=&quot;extraContent&quot;&gt;
  &lt;h2&gt;Extra content comes here (ngIf)&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<p>Now if you run the application you should be able to toggle additional content by clicking the button multiple times.</p>
<p><img src="images/directives-ngif-01.png" alt="" /></p>
<p>Very often you may need two different templates within the component based on the condition evaluation.
Traditionally developers are using separate <code>NgIf</code> directives assigned to <code>truthy</code> and <code>falsy</code> results of the same expression:</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;condition&quot;&gt;main content&lt;/element&gt;
&lt;element *ngIf=&quot;!condition&quot;&gt;alternative content&lt;/element&gt;
</code></pre>
<p>The NgIf directive also supports <code>else</code> blocks for showing alternative content when the condition expression evaluates to a falsy value.
In this case, you need to provide a reference to a separate <code>ng-template</code>:</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;condition; else alternative&quot;&gt;
  Main template (condition is truthy)
&lt;/element&gt;

&lt;ng-template #alternative&gt;
  Alternative template (condition is falsy)
&lt;/ng-template&gt;
</code></pre>
<p>To see that on practice return to the project created earlier and add the additional template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ng-template #emptyView&gt;
  &lt;h3&gt;No extra content available&lt;/h3&gt;
&lt;/ng-template&gt;
</code></pre>
<p>Template above can be referenced by <code>emptyView</code> id.
Now update the main element to utilize the newly created template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div *ngIf=&quot;extraContent; else emptyView&quot;&gt;
  &lt;h2&gt;Extra content comes here (ngIf)&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<p>If you run the application right now and click the <code>Toggle extra content</code> button, you should see the content of the <code>emptyView</code> template.</p>
<p><img src="images/directives-ngif-02.png" alt="" /></p>
<p>It is possible to store both templates as external references.
By default, Angular treats inline template as a <code>then</code> block, but you can define it explicitly using the following syntax:</p>
<pre><code class="language-html">&lt;element *ngIf=&quot;condition; then thenBlock else elseBlock&quot;&gt;&lt;/element&gt;
</code></pre>
<p>Now if updated our example can look like the following:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;button (click)=&quot;extraContent = !extraContent&quot;&gt;
  Toggle extra content
&lt;/button&gt;
&lt;div *ngIf=&quot;extraContent; then mainView else emptyView&quot;&gt;&lt;/div&gt;

&lt;ng-template #mainView&gt;
  &lt;h2&gt;Extra content comes here (ngIf)&lt;/h2&gt;
&lt;/ng-template&gt;

&lt;ng-template #emptyView&gt;
  &lt;h3&gt;No extra content available&lt;/h3&gt;
&lt;/ng-template&gt;
</code></pre>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/structural-directives">angular/directives/structural-directives</a></strong> folder.</p>
</blockquote>
<h4 id="ngfor"><a class="header" href="#ngfor">NgFor</a></h4>
<p>The main purpose of <code>NgFor</code> directive is to display iterable collections by utilizing a custom HTML template for each entry.</p>
<h5 id="binding-to-arrays"><a class="header" href="#binding-to-arrays">Binding to arrays</a></h5>
<p>Let's start with a simple example that best demonstrates <code>NgFor</code> directive in action.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let num of [1,2,3,4,5]&quot;&gt;
        &lt;span&gt;{{num}}&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>In the example above we are using <code>NgFor</code> directive with a collection of five numbers to render an unordered (bulleted) list.
Angular treats the content of the list item as a template and repeatedly applies to each array entry.</p>
<p>You should see the following HTML once application compiles and restarts:</p>
<p><img src="images/directives-ngfor-01.png" alt="" /></p>
<p>If you inspect the source code of the page you should see the structure similar to the one below:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;
        &lt;span&gt;1&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;2&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;3&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;4&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;5&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h5 id="binding-to-class-properties-or-functions"><a class="header" href="#binding-to-class-properties-or-functions">Binding to class properties or functions</a></h5>
<p>It is also possible to bind <code>NgFor</code> to class properties or functions.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
    // ...

    users = [
        {
            id: 10,
            firstName: 'John',
            lastName: 'Doe'
        },
        {
            id: 20,
            firstName: 'Joan',
            lastName: 'Doe'
        }
    ];
}
</code></pre>
<p>We are going to have two objects in the <code>users</code> collection.
The list entry template should now look like the next one:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users&quot;&gt;
        &lt;div&gt;{{user.firstName + ' ' + user.lastName}}&lt;/div&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Once your project and compiled and reloaded you should see a list of full user names:</p>
<p><img src="images/directives-ngfor-02.png" alt="" /></p>
<h5 id="using-exported-variables"><a class="header" href="#using-exported-variables">Using exported variables</a></h5>
<p>The <code>NgFor</code>directives exports several values that you can map to the the local template variables:</p>
<ul>
<li><code>index: number</code> holds the numeric position of the current array item</li>
<li><code>first: boolean</code> indicates whether the current array item is the first one</li>
<li><code>last: boolean</code> indicates whether the current array item is the last one</li>
<li><code>even: boolean</code> indicates whether current array item's position index is even</li>
<li><code>odd: boolean</code> indicates whether current array item's position index is odd</li>
</ul>
<p>You can use these additional values to improve the user interface.
For example, let's add row numbers to the user list:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users; let i = index&quot;&gt;
        &lt;div&gt;
            &lt;span&gt;{{i + 1}}: &lt;/span&gt;
            &lt;span&gt;{{user.firstName + ' ' + user.lastName}}&lt;/span&gt;
        &lt;/div&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Note the use of <code>let i = index</code>, this is where you bind <code>index</code> property to a local template variable <code>i</code>.
That allows you displaying it via <code>&lt;span&gt;{{i + 1}}: &lt;/span&gt;</code></p>
<p><img src="images/directives-ngfor-03.png" alt="" /></p>
<p>You can use all local variables for conditional styling and layout.
For example, you may want drawing a table or a list with stripes based on <code>even</code> and <code>odd</code> value,
rendering some header or footer for the <code>first</code> and <code>last</code> items.</p>
<p>It is possible to use all variables at the same time separating them by semicolons:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users; let isFirst = first; let isLast = last;&quot;&gt;
        &lt;span&gt;{{user.firstName + ' ' + user.lastName}}&lt;/span&gt;
        &lt;span *ngIf=&quot;isFirst&quot;&gt;(this is the first item)&lt;/span&gt;
        &lt;span *ngIf=&quot;isLast&quot;&gt;(this is the last item)&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>When running the application, you should notice that first and last items in the list get different text appended to them based on the condition expression.</p>
<p><img src="images/directives-ngfor-04.png" alt="" /></p>
<h5 id="improving-performance-with-trackby"><a class="header" href="#improving-performance-with-trackby">Improving performance with <code>trackBy</code></a></h5>
<p>Every time a collection changes Angular drops existing DOM elements and the renders entire set of new ones.
That is fine when you are dealing with static collections.
However, you may see significant performance drops when using frequently changed arrays,
for example when using dynamic editing or populating collections from the server.
The complexity of item templates can also slow down rendering and affect overall application performance.</p>
<p>Angular provides a special <code>trackBy</code> feature that allows you to track underlying objects by unique <code>id</code> values
and to rebuild DOM elements only for the entries that change.
For many scenarios that often ends up with a huge performance boosts as large portions of the DOM remain unchanged.</p>
<p>The <code>trackBy</code> value should go after the main <code>ngFor</code> expression and must be separated by a semicolon:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ul&gt;
    &lt;li *ngFor=&quot;let user of users; trackBy: trackByUserId&quot;&gt;
        &lt;span&gt;{{user.firstName + ' ' + user.lastName}}&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The <code>trackBy</code> always binds to a component method having a numeric <code>index</code> and a current collection object as parameters:</p>
<pre><code class="language-ts">// src/app/app.component.ts

trackByUserId(index: number, user: any) {
  return user.id;
}
</code></pre>
<p>In the example above we tell Angular to keep track of users in the list based on the <code>id</code> property value
so that it can better detect what item has been added or removed.</p>
<h4 id="ngswitch"><a class="header" href="#ngswitch">NgSwitch</a></h4>
<p>The <code>NgSwitch</code> directive is used for conditional rendering of element templates depending on the expression value.
You can treat it as an advanced <code>NgIf</code> directive with multiple <code>else</code> clauses.</p>
<p>You need three separate directives to make <code>NgSwitch</code> work:</p>
<ul>
<li><code>NgSwitch</code>: an attribute directive holding main expression body</li>
<li><code>NgSwitchCase</code>: a structural directive, renders corresponding template if its condition matches that of the <code>NgSwitch</code> one</li>
<li><code>NgSwitchDefault</code>: a structural directive, works like a fallback mechanism and renders a template if none of the <code>NgSwitchCase</code> values matches the <code>NgSwitch</code> one</li>
</ul>
<p>Here's the basic example of the <code>NgSwitch</code> format:</p>
<pre><code class="language-html">&lt;element [ngSwitch]=&quot;expression&quot;&gt;
    &lt;element *ngSwitchCase=&quot;condition1&quot;&gt;...&lt;/element&gt;
    &lt;element *ngSwitchCase=&quot;condition2&quot;&gt;...&lt;/element&gt;
    &lt;element *ngSwitchDefault&gt;...&lt;/element&gt;
&lt;/element&gt;
</code></pre>
<p>To check how <code>NgSwitch</code> operates in practice let's build a simple component that displays different UI layouts based on the selected role of the user.
Open the <code>app.component.ts</code> and add the <code>roles</code> and <code>selectedRole</code> properties like below:</p>
<pre><code class="language-ts">// src/app/app.component.ts

roles = [
    { id: 0, name: 'empty' },
    { id: 1, name: 'unknown' },
    { id: 2, name: 'user' },
    { id: 3, name: 'guest' },
    { id: 4, name: 'administrator' }
];

selectedRole = 'empty';
</code></pre>
<p>Next place a <code>&lt;select&gt;</code> element to be able to select a role from the dropdown list:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;select [(ngModel)]=&quot;selectedRole&quot;&gt;
    &lt;option *ngFor=&quot;let role of roles&quot;&gt;{{role.name}}&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>Finally we are going to build our simple role template selector:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div [ngSwitch]=&quot;selectedRole&quot;&gt;

    &lt;div *ngSwitchCase=&quot;'administrator'&quot;&gt;
        Special layout for the &lt;strong&gt;administrator&lt;/strong&gt; role
    &lt;/div&gt;

    &lt;div *ngSwitchCase=&quot;'guest'&quot;&gt;
        Special layout for the &lt;strong&gt;guest&lt;/strong&gt; role
    &lt;/div&gt;

    &lt;div *ngSwitchDefault&gt;
        General UI for the roles
    &lt;/div&gt;

&lt;/div&gt;
</code></pre>
<p>As a result, we are going to use dedicated UI templates for <code>administrator</code> and <code>guest</code> roles:</p>
<p><img src="images/directives-ngswitch-01.png" alt="" /></p>
<p>The rest of the roles should receive a generic template.</p>
<p><img src="images/directives-ngswitch-02.png" alt="" /></p>
<p>As you can see from the examples above, the <code>NgSwitch</code> directive is a powerful and flexible way for conditional element rendering in Angular.</p>
<h3 id="creating-a-structural-directive"><a class="header" href="#creating-a-structural-directive">Creating a Structural Directive</a></h3>
<p>Let's create a simple structural directive called <code>RepeatDirective</code> that is going to repeat specified HTML template certain number of times.
You can use Angular CLI to generate a working directive skeleton quickly.</p>
<pre><code class="language-sh">ng g directive repeat
</code></pre>
<p>The command above gives you a basic <code>RepeatDirective</code> implementation and a simple unit test.
It also modifies the main application module <code>app.module.ts</code> to register new directive within module declarations.</p>
<pre><code class="language-text">installing directive
  create src/app/repeat.directive.spec.ts
  create src/app/repeat.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>Here's the content of the <code>repeat.directive.ts</code> we are going to work with:</p>
<pre><code class="language-ts">// src/app/repeat.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appRepeat]'
})
export class RangeDirective {

  constructor() { }

}
</code></pre>
<p>Note that Angular CLI automatically prepends default <code>app</code> prefix to the directive selector value.
This helps us to avoid name conflicts with the existing directives from either standard Angular or third party libraries.</p>
<p>You can use your new directive with any HTML element like the following:</p>
<pre><code class="language-html">&lt;element *appRepeat&gt;...&lt;/element&gt;
</code></pre>
<p>It is also possible to use the plain format without Angular syntactic sugar:</p>
<pre><code class="language-html">&lt;ng-template [appRepeat]&gt;&lt;!--...--&gt;&lt;/ng-template&gt;
</code></pre>
<p>Now let's update our directive to repeat the content.</p>
<pre><code class="language-ts">// src/app/repeat.directive.ts

import { Directive, TemplateRef, ViewContainerRef, Input } from '@angular/core';

@Directive({
  selector: '[appRepeat]'
})
export class RepeatDirective {

  constructor(private templateRef: TemplateRef&lt;any&gt;,
              private viewContainer: ViewContainerRef) { }

  @Input()
  set appRepeat(times: number) {
    for (let i = 0; i &lt; times; i++) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    }
  }

}
</code></pre>
<p>First of all, you get access to the underlying template by injecting <code>TemplateRef</code> instance and using it as a local reference.
You also save a reference to the <code>ViewContainerRef</code> instance as you need it to turn the template reference to a real HTML element.</p>
<p>As a second step, we define an <code>appRepeat</code> setter that is going to receive configuration settings from the directive value.
Note that to map an attribute value to a function parameter the directive setter must have the same name as the HTML selector value.
In our case, it is <code>appRepeat</code> one. That gives you the possibility using the <code>*directive=&quot;expression&quot;</code> format similar to the one below:</p>
<pre><code class="language-html">&lt;element *appRepeat=&quot;5&quot;&gt;...&lt;/element&gt;
</code></pre>
<p>The child content of the decorated element gets treated as a template. 
With the help of <code>ViewContainer</code> and <code>Template</code> references we turn it into the HTML DOM multiple times:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; times; i++) {
  this.viewContainer.createEmbeddedView(this.templateRef);
}
</code></pre>
<p>You can test the directive with the following layout:</p>
<pre><code class="language-html">&lt;div *appRepeat=&quot;5&quot;&gt;
    &lt;div&gt;Hello&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>It is going to render the following output once the application runs:</p>
<pre><code class="language-html">Hello
Hello
Hello
Hello
Hello
</code></pre>
<p>The <code>Hello</code> template is rendered 5 times as we expect it.
However, rendering HTML elements without data context is not very useful.
Let's extend our directive with a custom context set to the position index of the element:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; times; i++) {
  this.viewContainer.createEmbeddedView(this.templateRef, {
    $implicit: i
  });
}
</code></pre>
<p>Now you can define a local variable for your template bound to the data context:</p>
<pre><code class="language-html">&lt;div *appRepeat=&quot;5; let idx&quot;&gt;
  &lt;div&gt;Hello {{idx}}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>You can also change example able to be like the next one:</p>
<pre><code class="language-html">&lt;ng-template [appRepeat]=&quot;5&quot; let-idx&gt;
  &lt;div&gt;Hello {{idx}}&lt;/div&gt;
&lt;/ng-template&gt;
</code></pre>
<p>This time the application output when using any of these formats is going to be as following:</p>
<pre><code class="language-html">Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
</code></pre>
<p>Let's get back to the data context again. Any local variable that has no value defined is going to point to the default <code>$implicit</code> value.
You can define as many variables as needed within your directive implementation.
For example, try to expose <code>first</code> and <code>last</code> variables similar to those of the <code>NgFor</code> directive:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; times; i++) {
    this.viewContainer.createEmbeddedView(this.templateRef, {
        $implicit: i,
        first: i === 0,
        last: i === times - 1
    });
}
</code></pre>
<p>Next you can wire newly created local variables and reuse them within the template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div *appRepeat=&quot;5; let idx; let isFirst = first; let isLast = last;&quot;&gt;
    &lt;div&gt;
      Hello {{idx}}
      &lt;span *ngIf=&quot;isFirst&quot;&gt;(first)&lt;/span&gt;
      &lt;span *ngIf=&quot;isLast&quot;&gt;(last)&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Once the application compiles and runs you should see the following result:</p>
<pre><code class="language-html">Hello 0 (first)
Hello 1
Hello 2
Hello 3
Hello 4 (last)
</code></pre>
<p>You can keep enhancing your directive with more complex layout and behavior.</p>
<h2 id="modifying-host-element-layout"><a class="header" href="#modifying-host-element-layout">Modifying Host Element Layout</a></h2>
<p>Directives can extend or modify host element layout at run time.
Let's create an <code>AttachDirective</code> directive that invokes an open file dialogue, once the user clicks the host element.</p>
<p>Due to security reasons, modern browsers do not allow invoking file dialogues from code,
unless caused by a user action, like clicking a button or hyperlink.
Traditionally developers use a hidden <code>&lt;input type=&quot;file&quot;&gt;</code> element to trigger its native behavior programmatically.
So as part of its implementation, our directive is going to create an additional <code>&lt;input&gt;</code> element and interact with it from code.</p>
<p>Using Angular CLI create a new project to develop and test the directive.</p>
<pre><code class="language-sh">ng new app-attach-directive
cd app-attach-directive/
ng g directive attach
</code></pre>
<p>The commands above result in a new <code>app-attach-directive</code> project containing <code>attach.directive.ts</code>
and <code>attach.directive.spec.ts</code> in the <code>src/app</code> folder.
You can see the content of the new <code>AttachDirective</code> below:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appAttach]'
})
export class AttachDirective {

  constructor() { }

}
</code></pre>
<p>Angular CLI automatically prepended the name with the default <code>app</code> prefix to avoid naming conflicts,
so you are going to use <code>appAttach</code> in HTML.</p>
<p>Before implementing the directive let's prepare the testing environment.
We are going to use main application component to see all the changes in action.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
  title = 'Attach directive';
}
</code></pre>
<p>Add the following block to the application component's template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div appAttach class=&quot;attach-area&quot;&gt;
    &lt;div&gt;
        Click me to upload files
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>For demonstration and testing purposes we also provide some basic styling via <code>attach-area</code> CSS class.
The light blue box on the page shows the 'clickable' area wired with the <code>appAttach</code> directive.</p>
<pre><code class="language-css">/* src/app/app.component.css */

.attach-area {
  width: 200px;
  height: 50px;
  background-color: lightblue;
  cursor: pointer;
}
</code></pre>
<p>Now you can run the app with</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>The application compiles and runs inside your default browser.</p>
<p><img src="images/app-attach-directive-01.png" alt="" /></p>
<p>You can leave the terminal running in the background.
Angular CLI keeps watching for files and automatically recompiles and reloads application upon any changes.</p>
<p>Now provide the initial directive implementation like the following:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

import { Directive, OnInit, ElementRef, Renderer, HostListener } from '@angular/core';

@Directive({
  selector: '[appAttach]'
})
export class AttachDirective implements OnInit {
    private upload: HTMLInputElement;

    constructor(
        private el: ElementRef, 
        private renderer: Renderer) {
    }

    ngOnInit(): void {
        this.upload = this.renderer.createElement(
            this.el.nativeElement.parentNode, 'input') 
            as HTMLInputElement;

        this.upload.type = 'file';
        this.upload.style.display = 'none';
    }
}
</code></pre>
<p>First of all, you reserve a private property <code>upload</code> to store reference on the original <code>&lt;input&gt;</code> element.
The directive also needs a reference to its host element and an instance of the <code>Renderer</code> class, to modify HTML layout.
We inject both in the constructor and store as private properties <code>el</code> and <code>renderer</code>.</p>
<p>Once directive gets initialized it creates a new hidden <code>&lt;input type=&quot;file&quot;&gt;</code> HTML element next to the host one.
You can invoke its methods from the code, for example, a <code>click</code> event that causes a file dialogue to appear.
Let's listen to the host's <code>click</code> event and redirect it to the hidden input element like below:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

@HostListener('click', ['$event'])
onClick(event: Event) {
    if (this.upload) {
        event.preventDefault();
        this.upload.click();
    }
}
</code></pre>
<p>Once the user selects a file in the dialogue, our directive should know about that.
We can achieve that by listening to the <code>change</code> event of the input element and accessing the file list as soon as the event occur.</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

ngOnInit(): void {
    // ...
    this.upload.addEventListener('change', e =&gt; this.onAttachFiles(e));
}

private onAttachFiles(e: Event): void {
    const input = (&lt;HTMLInputElement&gt;e.currentTarget);
    const files = this.getFiles(input.files);
    this.raiseEvent(files);
}
</code></pre>
<p>Inside the handler, you extract the list of File objects from the event using the <code>getFiles</code> method with the following implementation:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

private getFiles(fileList: FileList): File[] {
    const result: File[] = [];

    if (fileList &amp;&amp; fileList.length &gt; 0) {
        for (let i = 0; i &lt; fileList.length; i++) {
            result.push(fileList[i]);
        }
    }
    
    return result;
}
</code></pre>
<p>Typically you may want to create an array of Model classes based on the File instances, or wrapping files into some other components.
For the sake of simplicity let's just return File objects as they are.</p>
<p>There can be multiple approaches to handling file uploads.
The directive might be doing all the upload work itself, it could be triggering some application service,
or it can raise DOM events for other components react on them.
We are going to take the latter approach and raise a custom <code>attach-files</code> event.</p>
<p>The <code>raiseEvent</code> method receives an array of <code>File</code> instances and raises <code>attach-files</code> event like below:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts

private raiseEvent(files: File[]): void {
    if (files.length &gt; 0) {
        const event = new CustomEvent('attach-files', {
            detail: {
                sender: this,
                files: files
            },
            bubbles: true
        });

        this.el.nativeElement.dispatchEvent(event);
    }
}
</code></pre>
<p>You can now handle this custom event from either host element or any other HTML element up against the parent hierarchy.
Let's create a list of files the user attaches using our directive.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div class=&quot;attach-area&quot; appAttach 
    (attach-files)=&quot;onAttachFiles($event)&quot;&gt;
    &lt;div&gt;
        Click me to upload files
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;Files attached&lt;/h3&gt;
&lt;ul&gt;
    &lt;li *ngFor=&quot;let file of files&quot;&gt;
        {{file.name}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>As you can see from the layout above, we wire <code>attach-files</code> event with the <code>onAttachFiles</code>
method of main application component class and are going to store attached files in the <code>files</code> collection.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent {
    title = 'Attach directive';

    files: File[];

    onAttachFiles(e: CustomEvent) {
        this.files = e.detail.files || [];
    }
}
</code></pre>
<p>Once application recompiles and reloads you can to test new behavior by attaching a file to see its name appear in the list:</p>
<p><img src="images/app-attach-directive-02.png" alt="" /></p>
<p>Another feature you may want to add to the directive is the ability to toggle single and multiple file selection support.
The standard <code>&lt;input type=&quot;file&quot;&gt;</code> element allows this via the <code>multiple</code> HTML attribute.</p>
<p>We can introduce the same property for the directive and propagate its value to the enclosed <code>upload</code> element like this:</p>
<pre><code class="language-ts">// src/app/attach.directive.ts
// ...

export class AttachDirective implements OnInit {
    // ...

    @Input()
    multiple: boolean;

    ngOnInit(): void {
        // ...
        
        if (this.multiple) {
            this.upload.setAttribute('multiple', '');
        }
    }
}
</code></pre>
<p>That allows us binding to or setting <code>[multiple]</code> property value on an HTML element alongside <code>appAttach</code> directive.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div class=&quot;attach-area&quot; appAttach [multiple]=&quot;true&quot; 
    (attach-files)=&quot;onAttachFiles($event)&quot;&gt;
    &lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<p>Now if you run the application you should be able to select multiple files in the file dialogue.
The list at the bottom should display names for all of them.</p>
<p><img src="images/app-attach-directive-03.png" alt="" /></p>
<p>So we got a directive that attaches to an HTML element, alters its behavior
and even redirects user events to an additional hidden content.
You can keep extending the implementation if needed, for example adding new properties,
or controlling the types of files to be selected.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/app-attach-directive">angular/directives/app-attach-directive</a></strong> folder.</p>
</blockquote>
<h2 id="walkthrough-upload-directive"><a class="header" href="#walkthrough-upload-directive">Walkthrough: Upload Directive</a></h2>
<p>In this walkthrough, we are going to create a directive that turns its host element into a drop target for files.</p>
<p>Our directive itself does not upload files to a server, but instead,
it is going to be responsible for detecting dropped Files and raising special DOM events.
Other parts of the application (components, directives, services) can then react on those events
and perform additional actions if needed.</p>
<p>Let's start by generating a new application and calling it <code>app-upload-directive</code>:</p>
<pre><code class="language-sh">ng new app-upload-directive
cd app-upload-directive/
</code></pre>
<p>You can test application was created successfully by running it with the default browser:</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p>Now let's create an <code>upload</code> directive from the Angular CLI blueprint:</p>
<pre><code class="language-sh">ng g directive directives/upload
</code></pre>
<p>The <code>ng</code> tool should put the code and unit tests into the <code>src/app/directives</code> folder,
and should also update main application module.</p>
<pre><code class="language-text">installing directive
  create src/app/directives/upload.directive.spec.ts
  create src/app/directives/upload.directive.ts
  update src/app/app.module.ts
</code></pre>
<p>Angular CLI generates the following code for the new directive:</p>
<pre><code class="language-ts">// upload.directive.ts

import { Directive } from '@angular/core';

@Directive({
  selector: '[appUpload]'
})
export class UploadDirective {

  constructor() { }

}
</code></pre>
<p>All application and directive tests should be working properly</p>
<pre><code class="language-sh">ng test
</code></pre>
<p>There should be an additional test for UploadDirective class: <code>should create an instance</code>.
This test is a good starting point for unit testing your future directive.</p>
<p><img src="images/upload-directive-initial-test.png" alt="Initial Test" /></p>
<p>We are going to decorate a simple <code>&lt;div&gt;</code> element and turn it into a file drop area.</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;div class=&quot;my-drop-area&quot;&gt;
  &lt;span&gt;Drop your files here...&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>As it is a <code>&lt;div&gt;</code> element let's add some style to be able distinguishing it.
Setting fixed size and background colour should be more than enough for now.</p>
<pre><code class="language-css">/* app.component.css */

.my-drop-area {
  width: 150px;
  height: 50px;
  background-color: lightgray;
}
</code></pre>
<p>The main application page now should look like the following:</p>
<p><img src="images/upload-directive-drop-area.png" alt="Drag and Drop Area" /></p>
<pre><code class="language-ts">// upload.directive.ts

import { /*...,*/ HostBinding, HostListener } from '@angular/core';

export class UploadDirective {

    @HostBinding('class.app-upload__dragover')
    isDragOver: boolean;    

}
</code></pre>
<p>Every time <code>isDragOver</code> becomes <code>true</code> the host element gets a CSS class <code>app-upload__dragover</code> applied to it.
Once it is set back to <code>false</code> the CSS class is automatically removed.</p>
<p>Now add the following code to the directive implementation:</p>
<pre><code class="language-ts">// upload.directive.ts

@HostListener('dragenter')
onDragEnter() {
  this.isDragOver = true;
}

@HostListener('dragover', ['$event'])
onDragOver(event: Event) {
  if (event) {
    event.preventDefault();
  }
  this.isDragOver = true;
}

@HostListener('dragleave')
onDragLeave() {
  this.isDragOver = false;
}
</code></pre>
<p>The code above performs a simple drag management to update <code>isDragOver</code> state and so host element style.
For <code>dragenter</code> and <code>dragover</code> events we are going to enable additional styles, and disable on <code>dragleave</code>.</p>
<p>In order to turn host element into a drop zone you also need handling <code>drop</code> event:</p>
<pre><code class="language-ts">// upload.directive.ts

@HostListener('drop', ['$event'])
onDrop(event: DragEvent) {
  event.preventDefault();
  event.stopPropagation();
  this.isDragOver = false;
}
</code></pre>
<p>Keep in mind that directive only adds <code>app-upload__dragover</code> class to the host element,
it does not modify element's style attributes directly.
Developers that are using your directive should be able to define look and feel of the decorated element at the application level.</p>
<p>Traditionally file drop areas use dashed borders when being dragged over,
let's make our element draw a thin blue border and also change background colour:</p>
<pre><code class="language-css">/* app.component.css */

.app-upload__dragover {
  border: 1px dashed blue;
  background-color: white;
}
</code></pre>
<p>And you need decorating <code>div</code> element with the directive to see it in action:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;div class=&quot;my-drop-area&quot; appUpload&gt;
  &lt;span&gt;Drop your files here...&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>The element should be changing the style when you drag a file over its area:</p>
<p><img src="images/upload-directive-drag-over.png" alt="Drag Over" /></p>
<p>Now that we have <code>drag</code> events wired with element styles, it is time to implement <code>drop</code> handling.
Find the <code>onDrop</code> method we have introduced earlier and replace with the following code:</p>
<pre><code class="language-ts">// upload.directive.ts

@HostListener('drop', ['$event'])
onDrop(event: DragEvent) {
  event.preventDefault();
  event.stopPropagation();
  this.isDragOver = false;

  const files = this.collectFiles(event.dataTransfer);
  console.log(files);
  this.onFilesDropped(files);
}
</code></pre>
<p>Once user drops files on the host element, the directive is going extract information on files from the DataTransfer instance (<code>collectFiles</code>),
and pass discovered files to the <code>onFilesDropped</code> method to raise corresponding DOM events.</p>
<blockquote>
<p><strong>DataTransfer</strong></p>
<p>The DataTransfer object is used to hold the data that is being dragged during a drag and drop operation.
It may hold one or more data items, each of one or more data types.</p>
<p>For more information see <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer">DataTransfer</a> article.</p>
</blockquote>
<p>Essentially we need to extract <code>File</code> objects into a separate collection in a safe manner:</p>
<pre><code class="language-ts">// upload.directive.ts

private collectFiles(dataTransfer: DataTransfer): File[] {
    const result: File[] = [];

    if (dataTransfer) {
      const items: FileList = dataTransfer.files;

      if (items &amp;&amp; items.length &gt; 0) {
        for (let i = 0; i &lt; items.length; i++) {
          result.push(items[i]);
        }
      }
    }

    return result;
}
</code></pre>
<p>Finally, we need to raise an <code>upload-files</code> event to allow other components handling it.
We are going to create an instance of the <code>CustomEvent</code> for that purpose.</p>
<blockquote>
<p><strong>CustomEvent</strong></p>
<p>The CustomEvent interface represents events initialized by an application for any purpose.</p>
<p>For more information see <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">CustomEvent</a> article.</p>
</blockquote>
<p>The directive also needs access to the native DOM element of the host to raise a custom event,
so importing <code>ElementRef</code> instance for the constructor is required.
Reference to the native HTML element should be injected as a constructor parameter and used as private property <code>el</code>.</p>
<pre><code class="language-ts">// upload.directive.ts

import { /*...,*/ ElementRef } from '@angular/core';

export class UploadDirective {
    // ...

    constructor(private el: ElementRef) {}

    // ...
}
</code></pre>
<p>You need using <code>Element.dispatchEvent()</code> to raise the <code>upload-files</code> event.
As part of the <code>CustomEvent</code> interface, we can define custom <code>detail</code> value,
so that external event handlers can get additional information.</p>
<p>We are going to provide an object containing a list of files (<code>files</code>) the user has dropped on the host element,
and reference to the directive (<code>sender</code>) instance that raised the event.</p>
<pre><code class="language-ts">// upload.directive.ts
private onFilesDropped(files: File[]) {
    if (files &amp;&amp; files.length &gt; 0) {
        this.el.nativeElement.dispatchEvent(
            new CustomEvent('upload-files', {
                detail: {
                    sender: this,
                    files: files
                },
                bubbles: true
            })
        );
    }
}
</code></pre>
<p>Note the <code>bubbles</code> property being set to <code>true</code> to enable event bubbling.
It indicates whether the given event bubbles up through the DOM or not.
In our case we allow any HTML element up the visual tree handle this event or stop its propagation.</p>
<p>You can get more details on custom events in the article <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events">Creating and triggering events</a>.</p>
<p>Now it is time to handle <code>upload-files</code> event at the application level.
Open the <code>app.component.html</code> file and add <code>onUploadFiles</code> event handler like shown below:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;div class=&quot;my-drop-area&quot; appUpload (upload-files)=&quot;onUploadFiles($event)&quot;&gt;
  &lt;span&gt;Drop your files here...&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>Given that our event supports bubbling any element in the parent hierarchy can handle it.
You could also define the handler as following:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;

&lt;div (upload-files)=&quot;onUploadFiles($event)&quot;&gt;
  &lt;div class=&quot;my-drop-area&quot; appUpload&gt;
    &lt;span&gt;Drop your files here...&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>To see the content of the event, we are going to put the <code>console.log</code> for now:</p>
<pre><code class="language-ts">// app.component.ts

onUploadFiles(event: CustomEvent) {
  console.log(event);
}
</code></pre>
<p>Now if you compile and run the web application, and drop one or multiple files on the drop are,
the console output should be similar to the following one:</p>
<p><img src="images/upload-directive-event.png" alt="" /></p>
<p>As you may see from the picture above, the handler is getting <code>CustomEvent</code> that holds <code>details</code> value
with a <code>File</code> collection, reference to the directive instance, and several standard properties.</p>
<p>Let's try adding some visualization and display a list of previously uploaded files on the main page.
Append the following HTML to the <code>app.component.html</code> file content:</p>
<pre><code class="language-html">&lt;!-- app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;div&gt;
    &lt;h3&gt;Uploaded files:&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let file of uploadedFiles&quot;&gt;
        {{file}}
      &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>List element binds to the <code>uploadedFiles</code> collection holding uploaded file names.
The <code>upload-files</code> event handler just collects the file names and fills the collection.</p>
<pre><code class="language-ts">// app.component.ts

export class AppComponent {
    // ...
    uploadedFiles: string[] = [];

    onUploadFiles(event: CustomEvent) {
        console.log(event);
        const files: File[] = event.detail.files;
        if (files) {
            for (const file of files) {
                this.uploadedFiles.push(file.name);
            }
        }
    }
}
</code></pre>
<p>Now run your web application or switch to the browser if running the live development server,
and try dropping one or multiple files several times.
You should see file names appear in the list below the drop area like shown on the picture below:</p>
<p><img src="images/upload-directive-file-list.png" alt="" /></p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/directives/app-upload-directive">angular/directives/app-upload-directive</a></strong> folder.</p>
</blockquote>
<p>When working on your Angular web application, you may want some other component or service handle the <code>upload-files</code> event
and perform actual uploading to a backend server, preferably by utilizing the injectable service.</p>
<p>It is always a good practice splitting functionality into small interchangeable building blocks, each doing one thing at a time.</p>
<h1 id="pipes"><a class="header" href="#pipes">Pipes</a></h1>
<p>Pipes transform template data into display values at runtime.</p>
<p>There are many cases when you may want to perform minor changes to the values that users see when the application is running.
Text transformation is an excellent example.</p>
<p>Imagine that you need to display a text label or field in the upper case, regardless of how the user originally typed it.
You can do that with the help of CSS by wrapping the text into some HTML element with style or class applied.</p>
<p>Alternatively, you can use the <code>UpperCasePipe</code>, a built-in Angular pipe that transforms text values to upper case.</p>
<p>Pipes have the following usage formats:</p>
<pre><code class="language-html">&lt;element&gt;{{ &lt;expression&gt; | &lt;pipe&gt; }}&lt;/element&gt;
&lt;element [propertyName]=&quot;&lt;expression&gt; | &lt;pipe&gt;&quot;&gt;&lt;/element&gt;
</code></pre>
<p>You append the name of the pipe to the expression separating them with the <strong>pipe operator</strong> ( | ).</p>
<p>Let's now build a quick example to see the <code>UpperCasePipe</code> in action:</p>
<pre><code class="language-html">&lt;h2&gt;Uppercase&lt;/h2&gt;
&lt;div&gt;
  {{'Hello world' | uppercase }}
&lt;/div&gt;
</code></pre>
<p>The <code>Hello world</code> example above renders to the following result at runtime:</p>
<p><img src="images/pipes-uppercase.png" alt="" /></p>
<p>No matter how you define the text value, for instance, &quot;hEllo worlD&quot; or &quot;hello WOLRD&quot;,
it is going to be <code>uppercased</code> when the application runs.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/pipes/standard-pipes">angular/pipes/standard-pipes</a></strong> folder.</p>
</blockquote>
<h2 id="pipes-with-parameters"><a class="header" href="#pipes-with-parameters">Pipes with Parameters</a></h2>
<p>The pipes in Angular can also have input parameters. That allows passing options to pipes is they support multiple output transformations.
You define pipe parameters by appending a <strong>colon</strong> (<strong>:</strong>) symbol to the pipe name followed by the parameter value:</p>
<pre><code class="language-html">&lt;element&gt;{{ &lt;expression&gt; | &lt;pipe&gt;:&lt;parameter&gt; }}&lt;/element&gt;
</code></pre>
<p>It is also possible to provide multiple parameters given the pipe supports that.
In this case you are going to separate all values by a <strong>colon</strong> ( <strong>:</strong> ) symbol, for example:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;expression&gt; | &lt;pipe&gt;:&lt;parameter-1&gt;:&lt;parameter-2&gt;:&lt;parameter-N&gt; }}
&lt;/element&gt;
</code></pre>
<p>The simplest example is date value conversion.
There are many different formats you can choose to display a date on the HTML page.</p>
<p>Angular provides a <code>DatePipe</code> pipe out of the box that helps you converting dates to various string representations.</p>
<p>Add the following <code>currentDate</code> property to the <code>AppComponent</code> class in the <code>app.component.ts</code>:</p>
<pre><code class="language-ts">// ...

export class AppComponent {
    // ...

    currentDate: number = Date.now();
}
</code></pre>
<p>The property holds the current date value evaluated with the <code>Date.now()</code> function.
You can take the next HTML template to display the date:</p>
<pre><code class="language-html">&lt;h2&gt;Date&lt;/h2&gt;
&lt;div&gt;
    Date: {{ currentDate | date }}
&lt;/div&gt;
</code></pre>
<p>We transform <code>currentDate</code> value with a <code>DatePipe</code> pipe using default parameters.
If you run the application right now the output should be similar to the following one:</p>
<p><img src="images/pipes-date-01.png" alt="Date Pipe" /></p>
<p>Note that the value of the date depends on your current date.</p>
<p>Typically you may want to render dates in short or long forms, or even with a custom format.
For that purpose the <code>DatePipe</code> in Angular supports <code>format</code> parameter to fine-tune the resulting output.</p>
<p>Let's add two more examples to the page:</p>
<pre><code class="language-html">&lt;div&gt;
  Short date: {{ currentDate | date:'shortDate' }}
&lt;/div&gt;

&lt;div&gt;
  Long date: {{ currentDate | date:'longDate' }}
&lt;/div&gt;
</code></pre>
<p><img src="images/pipes-date-02.png" alt="Date Pipe Format" /></p>
<h2 id="chaining-pipes"><a class="header" href="#chaining-pipes">Chaining Pipes</a></h2>
<p>You can use multiple value transformations by chaining pipes together.
The pipes are combined by utilizing the same <strong>pipe operator</strong> ( <strong>|</strong> ),
and every pipe can optionally have own properties to alter its behavior.</p>
<pre><code class="language-html">&lt;element&gt;{{ &lt;expression&gt; | &lt;pipe-1&gt; | &lt;pipe-2&gt; | &lt;pipe-N&gt; }}&lt;/element&gt;
</code></pre>
<p>The simple use case to demonstrate the chaining is using <code>Date</code> and <code>Uppercase</code> pipes at the same time.</p>
<p>Append the following code to the main application template:</p>
<pre><code class="language-html">&lt;div&gt;
  Long date (uppercase): {{ currentDate | date:'fullDate' | uppercase }}
&lt;/div&gt;
</code></pre>
<p>The main page now looks like below:</p>
<p><img src="images/pipes-date-03.png" alt="Chaining Pipes" /></p>
<p>So you can have quite powerful combinations of pipes transforming your data values as you need them to be.</p>
<h2 id="built-in-pipes"><a class="header" href="#built-in-pipes">Built-in Pipes</a></h2>
<p>Angular provides a set of handy pipes out of the box.
All of them can save your time and significantly reduce coding efforts related to values transformation and formatting.</p>
<p>You can notice that many pipes have similar usage format, so it should be pretty easy to remember most of the use cases.
Let's start with simple pipes and proceed to more complex by the end of this chapter.</p>
<h3 id="uppercase"><a class="header" href="#uppercase">UpperCase</a></h3>
<p>The <code>UpperCasePipe</code> pipe transforms text to upper case and has the following usage format:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;string_expression&gt; | uppercase }}
&lt;/element&gt;
</code></pre>
<p>You can use it with text expressions inside HTML element body or property binding:</p>
<pre><code class="language-html">&lt;h2&gt;Uppercase&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;'Hello world' =&gt; {{ 'Hellow world' | uppercase }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>You can see the result of the rendering below:</p>
<p><img src="images/pipes-uppercase-01.png" alt="Uppercase Pipe" /></p>
<p>This pipe does not have any additional parameters.</p>
<h3 id="lowercase"><a class="header" href="#lowercase">LowerCase</a></h3>
<p>The <code>LowerCasePipe</code> pipe transforms text to lower case and has the following usage format:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;string_expression&gt; | lowercase }}
&lt;/element&gt;
</code></pre>
<p>Here's the basic example of using <code>LowerCasePipe</code> in practice:</p>
<pre><code class="language-html">&lt;h2&gt;Lowercase&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;'hELLO wORLD' =&gt; {{ 'hELLO wORLD' | lowercase }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Which gives you the following result once application runs:</p>
<p><img src="images/pipes-lowercase-01.png" alt="LowerCase Pipe" /></p>
<p>This pipe does not have any additional parameters.</p>
<h3 id="titlecase"><a class="header" href="#titlecase">TitleCase</a></h3>
<p>The <code>TitleCasePipe</code> converts input text to the title case.
That means that first character gets converted to upper case while the rest of the string becomes lowercased.</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;text_expression&gt; | titlecase }}
&lt;/element&gt;
</code></pre>
<p>Converting to title case becomes handy when dealing with usernames.</p>
<p>Your application may have an input form, like a personal profile, where users can enter their first and last names for instance.
Regardless of the actual value, whether it is &quot;john&quot; or &quot;jOHN&quot;, you can render it like a &quot;John&quot; at run time:</p>
<pre><code class="language-html">&lt;h2&gt;Titlecase&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;'jOHN' =&gt; {{ 'jOHN' | titlecase }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>That turns into the following once your application runs:</p>
<p><img src="images/pipes-titlecase-01.png" alt="TitleCase Pipe" /></p>
<p>This pipe does not have any additional parameters.</p>
<h3 id="date"><a class="header" href="#date">Date</a></h3>
<p>You have already seen the <code>DatePipe</code> usage earlier in this chapter.
This pipe allows you to format a date value using a custom or one of the predefined locale rules.</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;date_expression&gt; | date[:format] }}
&lt;/element&gt;
</code></pre>
<p>Where <code>date_expression</code> is date represented by an <code>object</code>, a <code>number</code> holding amount of milliseconds since UTC epoch,
an <a href="https://www.w3.org/TR/NOTE-datetime">ISO string</a>, or a function or method call evaluating to these values at run time.</p>
<h4 id="custom-formatting-rules"><a class="header" href="#custom-formatting-rules">Custom formatting rules</a></h4>
<p>According to the Angular documentation you can provide a custom date format based on the following rules:</p>
<table><thead><tr><th align="left">Component</th><th align="center">Symbol</th><th align="center">Narrow</th><th align="center">Short</th><th align="center">Long</th><th align="center">Numeric</th><th align="center">2-digit</th></tr></thead><tbody>
<tr><td align="left">era</td><td align="center">G</td><td align="center">G (A)</td><td align="center">GGG (AD)</td><td align="center">GGGG (Anno Domini)</td><td align="center">---</td><td align="center">---</td></tr>
<tr><td align="left">year</td><td align="center">y</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">y (2015)</td><td align="center">yy (15)</td></tr>
<tr><td align="left">month</td><td align="center">M</td><td align="center">L (S)</td><td align="center">MMM (Sep)</td><td align="center">MMMM (September)</td><td align="center">M (9)</td><td align="center">MM (09)</td></tr>
<tr><td align="left">day</td><td align="center">d</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">d (3)</td><td align="center">dd (03)</td></tr>
<tr><td align="left">weekday</td><td align="center">E</td><td align="center">E (S)</td><td align="center">EEE (Sun)</td><td align="center">EEEE (Sunday)</td><td align="center">---</td><td align="center">---</td></tr>
<tr><td align="left">hour</td><td align="center">j</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">j (13)</td><td align="center">jj (13)</td></tr>
<tr><td align="left">hour12</td><td align="center">h</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">h (1 PM)</td><td align="center">hh (01 PM)</td></tr>
<tr><td align="left">hour24</td><td align="center">H</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">H (13)</td><td align="center">HH (13)</td></tr>
<tr><td align="left">minute</td><td align="center">m</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">m (5)</td><td align="center">mm (05)</td></tr>
<tr><td align="left">second</td><td align="center">s</td><td align="center">---</td><td align="center">---</td><td align="center">---</td><td align="center">s (9)</td><td align="center">ss (09)</td></tr>
<tr><td align="left">timezone</td><td align="center">z</td><td align="center">---</td><td align="center">---</td><td align="center">z (Pacific Standard Time)</td><td align="center">---</td><td align="center">---</td></tr>
<tr><td align="left">timezone</td><td align="center">Z</td><td align="center">---</td><td align="center">Z (GMT-8:00)</td><td align="center">---</td><td align="center">---</td><td align="center">---</td></tr>
<tr><td align="left">timezone</td><td align="center">a</td><td align="center">---</td><td align="center">a (PM)</td><td align="center">---</td><td align="center">---</td><td align="center">---</td></tr>
</tbody></table>
<p>As you can see from the table above, there may be plenty of different combinations depending on how you want a date and time presented.
If you want to get a year portion as a full 4-digit value you are going to take <code>y</code> symbol (<code>2017</code>), or <code>yy</code> for a 2-digit only (<code>17</code>).
Some of the date components support multiple presentations.</p>
<p>Assuming your browser is set to <code>en-UK</code> locale, for example,
you can display <code>September</code> month as <code>S</code> using its narrow form via <code>L</code> symbol,
short form <code>Sep</code> using <code>MMM</code> symbol, long <code>September</code> form with <code>MMMM</code>, or numeric forms <code>9</code>
and double-digit <code>09</code> by means of <code>M</code> and <code>MM</code> symbols respectively.</p>
<p>Note that you can use any other symbol as a date component separator, for instance:</p>
<ul>
<li>dd/MM/yy =&gt; 13/04/79</li>
<li>dd-MM-yy =&gt; 13-04-79</li>
<li>dd=MM=yy =&gt; 13=04=79</li>
</ul>
<p>Here's a basic example you can try with the main application component:</p>
<pre><code class="language-ts">export class AppComponent {
  // ...
  
  birthday = new Date(1879, 3, 14);
}
</code></pre>
<pre><code class="language-html">&lt;h2&gt;Date (custom formats)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;{{'1879-03-14' | date:'yMMMdjms'}}&lt;/li&gt;
  &lt;li&gt;dd/MM/yy: {{ birthday | date:'dd/MM/yy' }}&lt;/li&gt;
  &lt;li&gt;EEE, MMMM dd, yyyy: {{ birthday | date:'EEE, MMMM dd, yyyy' }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The result should be something like the following:</p>
<p><img src="images/pipes-date-05.png" alt="" /></p>
<p>The <code>Date</code> pipe is going to use the end user's locale when formatting time zones.
Note that when you use an <a href="https://www.w3.org/TR/NOTE-datetime">ISO string</a> with no time portion,
for example, <code>1879-03-14</code>, the pipe does not apply time zone offset.</p>
<pre><code class="language-html">&lt;element{{'1879-03-14' | date:'yMMMdjms'}}&lt;/element&gt;
&lt;!-- Mar 14, 1879, 12:00:00 AM --&gt;
</code></pre>
<blockquote>
<p><strong>Internationalisation API</strong></p>
<p>This pipe is using Internationalisation API that may not be fully supported by all modern browsers.
You can use <a href="https://cdn.polyfill.io/v2/docs/">Polyfill.io</a> service
to get the <code>Intl</code> polyfill only if your user's current browser needs it.</p>
<p>Also, you can see details and additional options at the project side: <a href="https://github.com/andyearnshaw/Intl.js/">Intl.js</a></p>
</blockquote>
<h4 id="predefined-formatting-rules"><a class="header" href="#predefined-formatting-rules">Predefined formatting rules</a></h4>
<p>The <code>DatePipe</code> pipe comes with the following predefined rules to help you formatting the dates:</p>
<table><thead><tr><th>Name</th><th>Value</th><th>Example output (<code>en-UK</code>)</th></tr></thead><tbody>
<tr><td>medium</td><td>yMMMdjms</td><td><code>Apr 13, 1879, 11:00:00 PM</code></td></tr>
<tr><td>short</td><td>yMdjm</td><td><code>4/13/1879, 11:00 PM</code></td></tr>
<tr><td>fullDate</td><td>yMMMMEEEEd</td><td><code>Sunday, April 13, 1879</code></td></tr>
<tr><td>longDate</td><td>yMMMMd</td><td><code>April 13, 1879</code></td></tr>
<tr><td>mediumDate</td><td>yMMMd</td><td><code>Apr 13, 1879</code></td></tr>
<tr><td>shortDate</td><td>yMd</td><td><code>4/13/1879</code></td></tr>
<tr><td>mediumTime</td><td>jms</td><td><code>11:00:00 PM</code></td></tr>
<tr><td>shortTime</td><td>jm</td><td><code>11:00 PM</code></td></tr>
</tbody></table>
<p>You can use the following HTML template and corresponding component property <code>birthday</code> to test all the rules:</p>
<pre><code class="language-html">&lt;h2&gt;Date (predefined formats)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;medium: {{ birthday | date:'medium' }}&lt;/li&gt;
  &lt;li&gt;short: {{ birthday | date:'short' }}&lt;/li&gt;
  &lt;li&gt;fullDate: {{ birthday | date:'fullDate' }}&lt;/li&gt;
  &lt;li&gt;longDate: {{ birthday | date:'longDate' }}&lt;/li&gt;
  &lt;li&gt;mediumDate: {{ birthday | date:'mediumDate' }}&lt;/li&gt;
  &lt;li&gt;shortDate: {{ birthday | date:'shortDate' }}&lt;/li&gt;
  &lt;li&gt;mediumTime: {{ birthday | date:'mediumTime'}}&lt;/li&gt;
  &lt;li&gt;shortTime: {{ birthday | date:'shortTime' }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="language-ts">export class AppComponent {
  // ...
  
  birthday = new Date(1879, 3, 14);
}
</code></pre>
<p>So that should give you the following result at run time:</p>
<p><img src="images/pipes-date-04.png" alt="" /></p>
<h2 id="decimal"><a class="header" href="#decimal">Decimal</a></h2>
<p>The <code>DecimalPipe</code> pipe formats a number as text, taking into account user's locale and optionally custom display format.</p>
<p>The usage format of the pipe is as follows:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;number_expression&gt; | number[:digitFormat] }}
&lt;/element&gt;
</code></pre>
<p>Where the <code>digitFormat</code> value is represented by the following formatting rule:</p>
<pre><code class="language-text">minIntegerDigits.minFractionDigits-maxFractionDigits
</code></pre>
<table><thead><tr><th>Component</th><th align="center">Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>minIntegerDigits</td><td align="center">1</td><td>Minimum number of digits to use when converting to text.</td></tr>
<tr><td>minFractionDigits</td><td align="center">0</td><td>Minimum number of digits after fraction.</td></tr>
<tr><td>maxFractionDigits</td><td align="center">3</td><td>Maximum number of digits after fraction.</td></tr>
</tbody></table>
<blockquote>
<p><strong>Minimum Numbers</strong></p>
<p>By setting the minimum numbers like <code>minIntegerDigits</code> and <code>minFractionDigits</code>, you enforce resulting value to have a certain size.
The pipe automatically adds leading or trailing zeros if the actual value is less than expected.</p>
<p>For example applying a minimum number of <code>3</code> to the value <code>1</code> results in <code>003</code> text rendered by the pipe.</p>
</blockquote>
<p>Let's now see how this pipe works in practice.
Open existing or create a new Angular application and put the following block to the main application component template:</p>
<pre><code class="language-html">&lt;h2&gt;Decimal (12.123456)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;number =&gt; {{ 12.123456 | number }}&lt;/li&gt;
  &lt;li&gt;number:'2.1-2' =&gt; {{ 12.123456 | number:'2.1-2' }}&lt;/li&gt;
  &lt;li&gt;number:'3.0-0' =&gt; {{ 12.123456 | number:'3.0-0' }}&lt;/li&gt;
  &lt;li&gt;number:'3.10-15' =&gt; {{ 12.123456 | number:'3.10-15' }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The example above renders to the following:</p>
<p><img src="images/pipes-decimal-01.png" alt="" /></p>
<p>Please note the last case in the example above.
It demonstrates how leading, and trailing zeros get added to the output based on conditions.</p>
<blockquote>
<p><strong>Internationalization API</strong></p>
<p>This pipe is using Internationalization API that may not be fully supported by all modern browsers.
You can use <a href="https://cdn.polyfill.io/v2/docs/">Polyfill.io</a> service to get the <code>Intl</code> polyfill only if your user's current browser needs it.</p>
<p>Also, you can see details and additional options at the project side: <a href="https://github.com/andyearnshaw/Intl.js/">Intl.js</a></p>
</blockquote>
<h3 id="currency"><a class="header" href="#currency">Currency</a></h3>
<p>The <code>CurrencyPipe</code> pipe formats a number as a currency text, taking into account user's locale and optionally custom display format.</p>
<p>You can use this pipe with three optional parameters by utilizing the following format:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;number_expression&gt; | currency[:code[:symbol[:digitFormat]]] }}
&lt;/element&gt;
</code></pre>
<p>The <code>code</code> is a parameter of <code>string</code> type that refers to <a href="https://en.wikipedia.org/wiki/ISO_4217">ISO 4217</a> currency code.
For example, you can use <code>GBP</code> for the Great Britain Pound Sterling, or <code>USD</code> for United States Dollar.</p>
<p>The <code>symbol</code> parameter holds <code>boolean</code> value to indicate whether pipe needs to render currency symbol like Â£ or just use the currency code value, in this case, <code>GBP</code>.
This parameter defaults to <code>false</code> and <code>CurrencyPipe</code> is going to use currency codes if <code>symbol</code> parameter is not defined explicitly.</p>
<p>Finally, the <code>digitFormat</code> value is the same as of the <code>DecimalPipe</code>, and is represented by the following formatting rule:</p>
<pre><code class="language-text">minIntegerDigits.minFractionDigits-maxFractionDigits
</code></pre>
<table><thead><tr><th>Component</th><th align="center">Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>minIntegerDigits</td><td align="center">1</td><td>Minimum number of digits to use when converting to text.</td></tr>
<tr><td>minFractionDigits</td><td align="center">0</td><td>Minimum number of digits after fraction.</td></tr>
<tr><td>maxFractionDigits</td><td align="center">3</td><td>Maximum number of digits after fraction.</td></tr>
</tbody></table>
<blockquote>
<p><strong>Minimum Numbers</strong></p>
<p>By setting the minimum numbers like <code>minIntegerDigits</code> and <code>minFractionDigits</code>, you enforce resulting value to have a certain size.
The pipe automatically adds leading or trailing zeros if the actual value is less than expected.</p>
<p>For example applying a minimum number of <code>3</code> to the value <code>1</code> results in <code>003</code> text rendered by the pipe.</p>
</blockquote>
<p>Below is a set of examples to demonstrate the pipe in action:</p>
<pre><code class="language-html">&lt;h2&gt;Currency&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;GBP (code): {{ 150 | currency:'GBP' }}&lt;/li&gt;
  &lt;li&gt;GBP (symbol): {{ 150 | currency:'GBP':true }}&lt;/li&gt;
  &lt;li&gt;USD: {{ 0.9876 | currency:'USD':true:'2.2-2' }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Once your application starts you should see the following output:</p>
<p><img src="images/pipes-currency-01.png" alt="" /></p>
<blockquote>
<p><strong>Internationalization API</strong></p>
<p>This pipe is using Internationalization API that may not be fully supported by all modern browsers.
You can use <a href="https://cdn.polyfill.io/v2/docs/">Polyfill.io</a> service to get the <code>Intl</code> polyfill only if your user's current browser needs it.</p>
<p>Also, you can see details and additional options at the project side: <a href="https://github.com/andyearnshaw/Intl.js/">Intl.js</a></p>
</blockquote>
<h3 id="percent"><a class="header" href="#percent">Percent</a></h3>
<p>The <code>PercentPipe</code> formats a number input as a percentage, where &quot;1&quot; corresponds to &quot;100%&quot;,
and &quot;0.5&quot; for instance corresponds to &quot;50%&quot;.
This pipe also takes into account user's locale and allows you to customize resulting numeric format if needed.</p>
<p>The usage format is similar to that of the <code>DecimalPipe</code>, <code>CurrencyPipe</code>
and many other number-based pipes Angular provides out of the box:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;number_expression&gt; | percent[:digitFormat] }}
&lt;/element&gt;
</code></pre>
<p>Where the <code>digitFormat</code> value is represented by the following formatting rule:</p>
<pre><code class="language-text">minIntegerDigits.minFractionDigits-maxFractionDigits
</code></pre>
<table><thead><tr><th>Component</th><th align="center">Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>minIntegerDigits</td><td align="center">1</td><td>Minimum number of digits to use when converting to text.</td></tr>
<tr><td>minFractionDigits</td><td align="center">0</td><td>Minimum number of digits after fraction.</td></tr>
<tr><td>maxFractionDigits</td><td align="center">3</td><td>Maximum number of digits after fraction.</td></tr>
</tbody></table>
<blockquote>
<p><strong>Minimum Numbers</strong></p>
<p>By setting the minimum numbers like <code>minIntegerDigits</code> and <code>minFractionDigits</code>, you enforce resulting value to have a certain size.
The pipe automatically adds leading or trailing zeros if the actual value is less than expected.</p>
<p>For example applying a minimum number of <code>3</code> to the value <code>1</code> results in <code>003</code> text rendered by the pipe.</p>
</blockquote>
<p>Now create a new Angular project or open an existing one and append the following block to the main application component template:</p>
<pre><code class="language-html">&lt;h2&gt;Percent&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1.0 equals to {{ 1.0 | percent }}&lt;/li&gt;
  &lt;li&gt;0.5 equals to {{ 0.5 | percent }}&lt;/li&gt;
  &lt;li&gt;0.123456 equals to {{ 0.123456 | percent }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>If you run the application with the code above you should see the following output:</p>
<p><img src="images/pipes-percent-01.png" alt="Percent Pipe" /></p>
<p>Notice that by default <code>PercentPipe</code> displays three digits after the fraction, so <code>0.123456</code> gets rounded and shown as <code>12.346</code>.</p>
<p>As with other number conversion pipes, you are also able to control how <code>PercentPipe</code> displays digits after fraction.
For example, let's make the transformed output more precise and render five numbers instead of the default three:</p>
<pre><code class="language-html">&lt;h2&gt;Percent&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;0.123456 corresponds to {{ 0.123456 | percent:'1.1-5' }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>This time we should see the full number as we define it initially, and without rounding:</p>
<p><img src="images/pipes-percent-02.png" alt="Formatted Percent Pipe" /></p>
<p>It is also possible to add leading zero to the final output by putting a minimum threshold for the number of digits:</p>
<pre><code class="language-html">&lt;h2&gt;Percent&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;0.025 corresponds to {{ 0.025 | percent:'2.1' }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The example above shows how to force <code>PercentPipe</code> always to use two numbers during conversion,
so you are going to get a leading zero for small values.</p>
<p><img src="images/pipes-percent-03.png" alt="Forced Formatting for Percent Pipe" /></p>
<blockquote>
<h2 id="internationalization-api"><a class="header" href="#internationalization-api">Internationalization API</a></h2>
<p>This pipe is using Internationalization API that may not be fully supported by all modern browsers.
You can use <a href="https://cdn.polyfill.io/v2/docs/">Polyfill.io</a> service to get the <code>Intl</code> polyfill only if your user's current browser needs it.</p>
<p>Also, you can see details and additional options at the project side: <a href="https://github.com/andyearnshaw/Intl.js/">Intl.js</a></p>
</blockquote>
<h3 id="json"><a class="header" href="#json">Json</a></h3>
<p>The <code>JsonPipe</code> pipe often helps with debugging your Angular code.
Its main purpose is converting JavaScript objects into JSON strings.</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;object_expression&gt; | json }}
&lt;/element&gt;
</code></pre>
<p>You are going to use this pipe if you want to peek inside a payload or response object coming from HTTP service call for instance.
Let's start by adding a <code>complexObject</code> property to the main application component:</p>
<pre><code class="language-ts">export class AppComponent {
  // ...

  complexObject = {
    name: {
      firstName: 'Joan',
      lastName: 'Doe'
    },
    email: 'joan.doe@mail.com'
  };
  
}
</code></pre>
<p>As you see the property holds a User object with some nested properties. You can now render it using the <code>JsonPipe</code> pipe as below:</p>
<pre><code class="language-html">&lt;h2&gt;Json&lt;/h2&gt;
&lt;pre&gt;{{ complexObject | json }}&lt;/pre&gt;
</code></pre>
<p>That gives you the following output once application reloads:</p>
<p><img src="images/pipes-json-01.png" alt="JSON Pipe" /></p>
<p>This pipe does not have any additional parameters.</p>
<h3 id="slice"><a class="header" href="#slice">Slice</a></h3>
<p>The <code>SlicePipe</code> pipe extracts a section of a string or array into a new object.
It performs a selection from a &quot;begin&quot; to an <code>end</code> index where the <code>end</code> does not get included in the resulting set.
Note that the original string or array is not modified.</p>
<blockquote>
<p><strong>Slice Behavior</strong></p>
<p>The implementation of this pipe is based on the standard <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">Array.prototype.slice()</a>
method for JavaScript Arrays, and <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/slice">String.prototype.slice()</a> method for
JavaScript Strings.</p>
<p>If needed, please refer to the corresponding API documentation for more details on how <code>slice</code> gets performed.</p>
</blockquote>
<h4 id="using-with-arrays"><a class="header" href="#using-with-arrays">Using with Arrays</a></h4>
<p>The format when using the pipe with arrays and collections is the following:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ array_expression | slice:begin[:end] }}
&lt;/element&gt;
</code></pre>
<p>First, add an initial collection of numbers to the main application component class, to be able testing the pipe:</p>
<pre><code class="language-ts">// ...
export class AppComponent {
  // ...
  
  numberCollection = [0, 1, 2, 3, 4, 5, 6];
}
</code></pre>
<p>As the next, try displaying first three items from the array by setting <code>begin</code> index to <code>0</code>
to point to the start of the collection, and the <code>end</code> index to 3.</p>
<pre><code class="language-html">&lt;h2&gt;Slice (arrays)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    First 3 items:
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let num of numberCollection | slice:0:3&quot;&gt;{{num}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Given the ending index is not included, the resulting subset should have the following items rendered: 0, 1, 2</p>
<p><img src="images/pipes-slice-01.png" alt="" /></p>
<p>You can also count items from the end of the array. For this purpose, you are going to use negative values for the <code>start</code> option.
For example value <code>3</code> signals the pipe to start taking items from the third position from the beginning. 
Using value <code>-3</code> makes the pipe count items from the end of the array. </p>
<p>Let's now try negative values in action and display last 3 items from the numbers collection:</p>
<pre><code class="language-html">&lt;h2&gt;Slice (arrays)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    Last 3 items:
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let num of numberCollection | slice:-3&quot;&gt;{{num}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>This time we do not need to specify the <code>end</code> index as we are going to take
all array values starting with the third one from the end.</p>
<p><img src="images/pipes-slice-02.png" alt="" /></p>
<p>Feel free to experiment with <code>start</code> and <code>end</code> index values more
to see how <code>SlicePipe</code> works with arrays depending on your conditions.</p>
<h4 id="using-with-strings"><a class="header" href="#using-with-strings">Using with Strings</a></h4>
<p>The format when using the pipe with strings is identical to that of the arrays.
The <code>SlicePipe</code> pipe treats strings as arrays of characters,
so you can apply the same <code>begin</code> and <code>end</code> parameters as you did earlier.</p>
<pre><code class="language-html">&lt;element&gt;
  {{ string_expression | slice:begin[:end] }}
&lt;/element&gt;
</code></pre>
<p>Let's test this pipe with the &quot;Hello world!&quot; string and extract the first word:</p>
<pre><code class="language-html">&lt;h2&gt;Slice (strings)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    First word of 'Hello world!':
    {{ 'Hello world!' | slice:0:5 }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Upon application start, you should see that pipe successfully transformed the string value and rendered only the word &quot;Hello&quot;.</p>
<p><img src="images/pipes-slice-03.png" alt="" /></p>
<p>We can also take the last word by using negative number for the <code>begin</code> parameter value:</p>
<pre><code class="language-html">&lt;h2&gt;Slice (strings)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    Last word of 'Hello world!':
    {{ 'Hello world!' | slice:-6:-1 }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>You should see the word &quot;world&quot; rendered by the pipe as soon as your application reloads.</p>
<p><img src="images/pipes-slice-04.png" alt="" /></p>
<p>Note that we use <code>-1</code> for the <code>end</code> value because sentence ends with an exclamation mark
that we want to exclude from the final output.
Otherwise, you can omit the <code>end</code> setting entirely and leave just <code>-6</code> for the <code>start</code> value.</p>
<h3 id="i18nselect"><a class="header" href="#i18nselect">I18nSelect</a></h3>
<p>For the time being the <code>I18nSelectPipe</code> is an experimental pipe that allows you
to render different strings from the object depending on the input value.</p>
<blockquote>
<p><strong>Experimental</strong></p>
<p>Please note that this pipe is an experimental one and its functionality may change.
We are going to update this section with new features for the <code>I18nSelectPipe</code> if they appear,
or remove this warning if the pipe gets updated to the stable state.</p>
</blockquote>
<p>The usage format for this pipe is the following:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;expression&gt; | i18nSelect:mapping }}
&lt;/element&gt;
</code></pre>
<p>The <code>mapping</code> is an object literal with properties.</p>
<p>To see that in action you need to create two properties <code>titleMode</code> and <code>titleValues</code>.
The <code>titleMode</code> property should be responsible for different title rendering modes,
while <code>titleValues</code> contains different values for title content.</p>
<pre><code class="language-ts">export class AppComponent {
  titleMode = 'primary';
  titleValues = {
    primary: 'This is a primary title',
    secondary: 'This is a secondary title',
    other: 'This is an alternative title'
  };
}
</code></pre>
<p>Now we can wire both properties together in the component HTML template as below:</p>
<pre><code class="language-html">&lt;h2&gt;I18nSelect&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;{{ titleMode | i18nSelect:titleValues }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Based on settings above there are four different values you can see on the screen at runtime:</p>
<ul>
<li><code>titleValues.primary</code> if <code>titleMode</code> property value equals to <code>primary</code>;</li>
<li><code>titleValues.secondary</code> if <code>titleMode</code> property value equals to <code>secondary</code>;</li>
<li><code>titleValues.other</code> as a fallback value if <code>titleMode</code> does not contain any of the values above;</li>
<li>empty string, if <code>titleValues</code> object literal does not have <code>other</code> property defined, and <code>titleMode</code> contains &quot;unknown&quot; value;</li>
</ul>
<p>Given that by default <code>titleMode</code> property value is set to <code>primary</code>,
you should see the following content once the application starts:</p>
<p><img src="images/pipes-i18nselect-01.png" alt="" /></p>
<p>Now try changing the value of the <code>titleMode</code> property to <code>secondary</code> like in the example below:</p>
<pre><code class="language-ts">export class AppComponent {
  
  titleMode = 'secondary';
  
  // ...
}
</code></pre>
<p>This time <code>I18nSelectPipe</code> is going to select and display <code>titleValues.secondary</code> value:</p>
<p><img src="images/pipes-i18nselect-02.png" alt="" /></p>
<p>For the next experiment, let's try setting <code>titleMode</code> to something <code>titleValues</code> does not contain a property for.
For example, change the value to a &quot;something else&quot; string.</p>
<pre><code class="language-ts">export class AppComponent {
  
  titleMode = 'something else';
  
  //...
}
</code></pre>
<p>As soon as your page reloads you can see that <code>I18nSelectPipe</code> this time takes the <code>titleMode.other</code> content as a fallback value.</p>
<p><img src="images/pipes-i18nselect-03.png" alt="" /></p>
<p>Another good scenario for <code>I18nSelectPipe</code> is rendering text that gets adopted to some input criteria,
for instance, <code>gender</code> value of the current user can be a good example:</p>
<pre><code class="language-ts">export class AppComponent {
  gender: string = 'male';
  inviteMap: any = {
    'male': 'Invite him.', 
    'female': 'Invite her.', 
    'other': 'Invite them.'
  };
}
</code></pre>
<p>Your component may display different user interface and content based on the <code>gender</code> value at run time.</p>
<p>Finally, you an use the <code>I18nSelectPipe</code> pipe for localising text, the <code>i18n</code> prefix in its name stands for <code>internationalization</code>.
Imagine you are implementing a colour picker button component, and you need to support multiple languages.
You can easily split the translation support into two pieces: <code>currentLanguage</code> property holding currently used language code
and a <code>buttonLabels</code> object containing all supported translations.</p>
<p>Let's see that in practice by providing tree &quot;Pick colour&quot; labels translated into
British English (<code>en-GB</code>), American English (<code>en-US</code>) and Ukrainian (<code>uk</code>).
For all other languages that our component does not support out of the box,
we are going to use <code>en-GB</code> locale via <code>other</code> property as a fallback option.</p>
<pre><code class="language-ts">export class AppComponent {
  currentLanguage = 'en-GB';
  buttonLabels = {
    'en-US': 'Pick a color',
    'en-GB': 'Pick a colour',
    'uk': 'Ð’Ð¸Ð±Ñ€Ð°Ñ‚Ð¸ ÐºÐ¾Ð»iÑ€',
    'other': 'Pick a colour'
  };
}
</code></pre>
<p>Now switch to the HTML template of your application component or any other component
you are using for testing purposes, and add the following content:</p>
<pre><code class="language-html">&lt;h2&gt;I18nSelect&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;button&gt;{{ currentLanguage | i18nSelect:buttonLabels }}&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>You should see the <code>en-GB</code> translation by default as per <code>currentLanguage</code> property value we set earlier:</p>
<p><img src="images/pipes-i18nselect-04.png" alt="" /></p>
<p>Now if you change the <code>currentLanguage</code> to &quot;uk&quot; code the button should have the following content rendered by <code>I18nSelectPipe</code>:</p>
<p><img src="images/pipes-i18nselect-05.png" alt="" /></p>
<p>Finally, if you change your <code>currentLanguage</code> property value to something
that is not supported by default, like &quot;fr&quot; or &quot;it&quot; for instance,
the pipe is going to switch to the &quot;other&quot; value at run time.</p>
<h3 id="i18nplural"><a class="header" href="#i18nplural">I18nPlural</a></h3>
<p>This pipe helps you with pluralizing your string values based on a number input value and optionally taking into account the current user's locale.</p>
<blockquote>
<p><strong>Experimental</strong></p>
<p>Please note that this pipe is an experimental one and its functionality may change.
We are going to update this section with new features for the <code>I18nPluralPipe</code> if they appear,
or remove this warning if the pipe gets updated to the stable state.</p>
</blockquote>
<p>The usage format for the <code>I18nPluralPipe</code> is as following:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;number_expression&gt; | i18nPlural:mapping }}
&lt;/element&gt;
</code></pre>
<p>The <code>mapping</code> is an object literal with properties, represented in TypeScript
by a dictionary containing key/value pairs of a string type.</p>
<p>Let's imagine we have a list of posts to render on the page.
Each post may also contain comments, so we are also going to show a list of comment instances in a user-friendly manner.</p>
<p>Create a new application with Angular CLI or open an existing one,
and append the following content to the main application controller:</p>
<pre><code class="language-ts">export class AppComponent {
  // ...
  
  posts = [
    {
      content: 'Post 1 content',
      commentsCount: 0,
    },
    {
      content: 'Post 2 content',
      commentsCount: 1
    },
    {
      content: 'Post 3 content',
      commentsCount: 10
    }
  ];
}
</code></pre>
<p>We have a collection of three simple posts with comment counters as <code>commentsCount</code> properties holding different number values.</p>
<p>There are at least three different cases for display value formatting in our case:</p>
<ul>
<li>0 comments: special message for zero values</li>
<li>1 comment: singular form of the message</li>
<li>2+ comments: plural form of the message</li>
</ul>
<p>Now let's create a mapping dictionary to hold string values for all the use cases above:</p>
<pre><code class="language-ts">export class AppComponent {
  // ...

  commentLabels: { [key: string]: string } = {
    '=0': 'There are no comments for this post.',
    '=1': 'There is one comment for this post.',
    'other': 'There are # comments for this post.'
  };
}
</code></pre>
<p>Finally we are ready to see <code>I18nPluralPipe</code> in action.
Append the following HTML to the component template:</p>
<pre><code class="language-html">&lt;h2&gt;I18nPluralPipe&lt;/h2&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let post of posts&quot;&gt;
    {{ post.content }}
    &lt;ul&gt;
      &lt;li&gt;{{ post.commentsCount | i18nPlural: commentLabels }}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>So this is how the output result should look like when the application starts:</p>
<p><img src="images/pipes-i18nPlural-01.png" alt="" /></p>
<h3 id="async"><a class="header" href="#async">Async</a></h3>
<p>The <code>AsyncPipe</code> pipe subscribes to an instance of a <code>Promise</code> or <code>Observable</code>
and transforms the underlying value upon every change.</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;expression&gt; | async }}
&lt;/element&gt;
</code></pre>
<p>The <code>expression</code> can take a value of either <code>Observable</code> or a <code>Promise</code> type.</p>
<blockquote>
<p><strong>Unsubscribing</strong></p>
<p>When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.</p>
</blockquote>
<h4 id="using-with-ngfor-directive"><a class="header" href="#using-with-ngfor-directive">Using with NgFor directive</a></h4>
<p>Let's try to display a list of comments based on an <code>Observable</code>.
First, create a <code>comments</code> property in your application component class:</p>
<pre><code class="language-ts">export class AppComponent {
  // ...
  
  comments: Observable&lt;string[]&gt;;
}
</code></pre>
<p>We are going to render an unordered list of comments; we also need a button to fetch comments from the server
and update <code>comments</code> observable with new values.</p>
<p>Open the HTML template of the main application component and append the following:</p>
<pre><code class="language-html">&lt;h2&gt;Async&lt;/h2&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let comment of comments | async&quot;&gt;
    {{ comment }}
  &lt;/li&gt;
&lt;/ul&gt;
&lt;button (click)=&quot;checkComments()&quot;&gt;Check comments&lt;/button&gt;
</code></pre>
<p>For the sake of simplicity, we are not going to make any HTTP calls on the <code>checkComments</code> call.
Let's just return a predefined set of comments after a short delay to emulate delays with a response.</p>
<pre><code class="language-ts">export class AppComponent {
  // ...
  
  comments: Observable&lt;string[]&gt;;

  checkComments() {
    this.comments = new Observable(observer =&gt; {
      observer.next([
        'Comment 1',
        'Comment 2',
        'Comment 3'
      ]);
    }).delay(1000);
  }
}
</code></pre>
<p>The <code>checkComments</code> method sets <code>comments</code> variable value to an observable that evaluates with 1-second delay
and returns a set of sample comments.</p>
<p>For testing purposes you can also add a button to reset comments:</p>
<pre><code class="language-html">&lt;button (click)=&quot;resetComments()&quot;&gt;Reset comments&lt;/button&gt;
</code></pre>
<p>The corresponding <code>resetComments</code> method is going to just set the <code>comments</code> value to <code>null</code>.</p>
<pre><code class="language-ts">export class AppComponent {
  // ...
  
  resetComments() {
    this.comments = null;
  }
}
</code></pre>
<p>If you now run the application the main page should look like the following:</p>
<p><img src="images/pipes-async-03.png" alt="" /></p>
<p>Try clicking the <code>Check comments</code> button and the results should get displayed in 1 second:</p>
<p><img src="images/pipes-async-01.png" alt="" /></p>
<h4 id="using-with-date-object"><a class="header" href="#using-with-date-object">Using with Date object</a></h4>
<p>Another good example to demonstrate the <code>AsyncPipe</code> in action is  displaying current time on the page.
Our component needs to implement standard <code>OnInit</code> interface to setup <code>currentTime</code> observable once it is ready.</p>
<pre><code class="language-ts">import { /*...,*/ OnInit } from '@angular/core';

export class AppComponent implements OnInit {
  // ...

  currentTime: Observable&lt;Date&gt;;

  ngOnInit() {
    this.currentTime = new Observable&lt;Date&gt;(observer =&gt; {
      setInterval(_ =&gt; observer.next(new Date()), 1000);
    });
  }
}
</code></pre>
<p>Upon initialization, the component assigns an <code>Observable</code> of <code>Date</code> type to the <code>currentTime</code> property.
The Observable instance updates the underlying value to a new <code>Date</code> object every second,
that causes <code>AsyncPipe</code> to render new date automatically.</p>
<p>As Angular allows chaining multiple pipes together, you can also use a <code>DatePipe</code> to format resulting output
to display only the time portion of the date.</p>
<p>You can get the basic HTML template for the application component below:</p>
<pre><code class="language-html">&lt;h2&gt;Async (date/time)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    Current time: {{ currentTime | async | date:'mediumTime' }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Once application compiles and starts you should get a time value updated every second:</p>
<p><img src="images/pipes-async-02.png" alt="" /></p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/pipes/standard-pipes">angular/pipes/standard-pipes</a></strong> folder.</p>
</blockquote>
<h2 id="custom-pipes"><a class="header" href="#custom-pipes">Custom Pipes</a></h2>
<p>Besides providing a set of standard out-of-box pipes the Angular framework provides support for creating your custom ones.</p>
<p>To create a custom pipe you need to import the <code>@Pipe</code> decorator and apply it to your class.</p>
<pre><code class="language-ts">import { Pipe } from '@angular/core';

@Pipe({
  name: 'customDate'
})
export class CustomDatePipe {
  // ...
}
</code></pre>
<p>You can give your class any name you want.
The Angular is going to use the <code>@Pipe</code> decorator metadata when parsing component templates, in our case the pipe gets used as <code>customDate</code>:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ &lt;expression&gt; | customDate }}
&lt;/element&gt;
</code></pre>
<p>Also, your class should implement a <code>PipeTransform</code> interface with a <code>transform</code> method:</p>
<pre><code class="language-ts">interface PipeTransform {
  transform(value: any, ...args: any[]) : any
}
</code></pre>
<p>At runtime, the Angular calls your pipe's transform method providing original input value together with optional pipe parameters.
For example, if your <code>myPipe</code> pipe expects to receive 3 additional parameters you can declare your <code>transform</code> method like the following:</p>
<pre><code class="language-ts">transform(value: string, p1: number, p2: number, p3: number) : string {
  return value;
}
</code></pre>
<p>To get type checking support from TypeScript, you can also provide type definitions for your parameters and method return type.</p>
<p>You can now use your pipe in HTML templates like in the example below:</p>
<pre><code class="language-html">&lt;element&gt;
  {{ 'hello world' | myPipe:1:2:3 }}
&lt;/element&gt;
</code></pre>
<h3 id="implementing-custom-pipe"><a class="header" href="#implementing-custom-pipe">Implementing Custom Pipe</a></h3>
<p>We are going to create a simple pipe that takes a numeric input value for a size of the file in bytes 
and produces a user-friendly output by transforming it to Kilobytes, Megabytes or greater units.</p>
<p>Let's start creating a custom pipe with a new project <code>custom-pipes</code> by utilizing the Angular CLI tool.</p>
<pre><code class="language-sh">ng new custom-pipes
</code></pre>
<p>You can use Angular CLI to generate the <code>file-size</code> pipe scaffold.</p>
<pre><code class="language-sh">ng g pipe pipes/file-size
</code></pre>
<p>The command above generates a pipe, basic unit test and updates main application module
so that you can use this pipe across all the application components.</p>
<pre><code class="language-text">installing pipe
  create src/app/pipes/file-size.pipe.spec.ts
  create src/app/pipes/file-size.pipe.ts
  update src/app/app.module.ts
</code></pre>
<p>The default pipe scaffold already contains a <code>@Pipe</code> decorator applied and inherits the <code>PipeTransform</code> interface:</p>
<pre><code class="language-ts">// src/app/pipes/file-size.pipe.ts

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'fileSize'
})
export class FileSizePipe implements PipeTransform {

  transform(value: any, args?: any): any {
    return null;
  }

}
</code></pre>
<p>First, let's change the signature of the <code>transform</code> method to accept <code>bytes</code> and <code>decimals</code> parameters of a <code>number</code> type.
We also make both of them optional by providing default values and change the return type of the method to a <code>string</code>.</p>
<pre><code class="language-ts">// src/app/pipes/file-size.pipe.ts

@Pipe({
  name: 'fileSize'
})
export class FileSizePipe implements PipeTransform {

  transform(bytes: number = 0, decimals: number = 2): string {
    return null;
  }

}
</code></pre>
<blockquote>
<p><strong>Converting Bytes</strong></p>
<p>There are many different ways to convert a file size from bytes to other units of measurement.</p>
<p>For this example we are going to take the accepted answer from the following Stackoverflow question:
<a href="https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript">Correct way to convert size in bytes to KB, MB, GB in Javascript</a></p>
</blockquote>
<p>You can see the final implementation of the pipe below:</p>
<pre><code class="language-ts">@Pipe({
  name: 'fileSize'
})
export class FileSizePipe implements PipeTransform {

  transform(bytes: number = 0, decimals: number = 2): string {
    if (bytes === 0) {
      return '0 Bytes';
    }
    const k = 1024,
       dm = decimals || 2,
       sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
       i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

}
</code></pre>
<p>If no <code>bytes</code> value provided the pipe returns a &quot;0 Bytes&quot; string,
for all other cases if converts input number to the most appropriate measuring unit.
The <code>transform</code> method also takes into account the number of decimals to use after the point,
provided within the second <code>decimals</code> parameter.
By default, it is going to take two numbers.</p>
<p>In order to see the pipe in action open the main application component template and append the following HTML block:</p>
<pre><code class="language-html">&lt;h2&gt;fileSize&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;520.12345 =&gt; {{ 520.12345 | fileSize }}&lt;/li&gt;
  &lt;li&gt;520.12345 =&gt; {{ 520.12345 | fileSize:4 }}&lt;/li&gt;
  &lt;li&gt;1024 =&gt; {{ 1024 | fileSize }}&lt;/li&gt;
  &lt;li&gt;5,347,737.6 =&gt; {{ 5347737.6 | fileSize }}&lt;/li&gt;
  &lt;li&gt;1,288,490,188.8 =&gt; {{ 1288490188.8 | fileSize }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Now run the application with <code>ng serve --open</code> command and you should see the following output:</p>
<p><img src="images/pipes-filesize-01.png" alt="" /></p>
<h2 id="pure-and-impure-pipes"><a class="header" href="#pure-and-impure-pipes">Pure And Impure Pipes</a></h2>
<p>Angular supports two different categories of pipes - &quot;pure&quot; and &quot;impure&quot;.
Every custom pipe is <code>pure</code> by default, but you can change that when using the <code>@Pipe</code> decorator:</p>
<pre><code class="language-ts">@Pipe({
  name: 'myCustomPipe',
  pure: false
})
</code></pre>
<p>Before diving into details on category differences, let's prepare the testing project.</p>
<p>We are going to display a list of short blog posts filtered by a <code>pure</code> or <code>impure</code> pipe
and allow creating a new simple blog post entry with various properties like creation date, content or public state.</p>
<h3 id="preparing-project"><a class="header" href="#preparing-project">Preparing Project</a></h3>
<p>Use Angular CLI to generate a new project called &quot;pure-impure&quot;.</p>
<pre><code class="language-sh">ng new pure-impure
cd pure-impure
</code></pre>
<p>As we are going to filter and display Posts let's create a <code>Post</code> interface that defines the main attributes of a Post instance.
You can do that by utilizing Angular CLI that supports generating interface classes as well.</p>
<pre><code class="language-sh">ng g interface post
</code></pre>
<p>The Angular CLI puts interfaces classes to the <code>src/app</code> folder by default:</p>
<pre><code class="language-text">installing interface
  create src/app/post.ts
</code></pre>
<p>The bare minimum of properties we need to visualize a post is:</p>
<ul>
<li>the text content of the post</li>
<li>creation date</li>
<li>a flag indicating whether the post is public or private</li>
</ul>
<p>Open the newly generated <code>post.ts</code> file and update it according to the list above:</p>
<pre><code class="language-ts">// src/app/post.ts

export interface Post {
  created: Date;
  content: string;
  isPublic: boolean;
}
</code></pre>
<p>For the next step let's update the main application component class.
We need a <code>posts</code> property to hold a collection of created <code>Post</code> instances.
Also, the <code>newPostContent</code> and <code>newPostPublic</code> properties of <code>string</code> and <code>boolean</code>
types are going to power our simple post editor.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Post } from './post';

@Component({/*...*/})
export class AppComponent {
  // ... 

  posts: Post[] = [];

  newPostContent = '';
  newPostPublic = true;

  createPost(): void {
    if (this.newPostContent) {
      const newPost = &lt;Post&gt; {
        content: this.newPostContent,
        isPublic: this.newPostPublic,
        created: new Date()
      };
      this.posts.push(newPost);
      this.newPostContent = '';
    }
  }
}
</code></pre>
<p>The <code>createPost</code> method performs some basic validation for content to be defined and creates a new post.
The creation date is assigned automatically to current date and time.
Upon pushing the new post to the <code>posts</code> collection, our <code>createPost</code> method also clears the input field.</p>
<p>Note that <code>posts</code> collection is defined and initialized with an empty array by default.
We add items to it via <code>createPost</code> method, but the initial collection is always the same.
To better demonstrate capabilities of both pipes we also need to change the object reference for the <code>posts</code> collection,
for example creating a new collection of Post instances, or resetting it by assigning an empty array value.</p>
<p>For the sake of simplicity let's just be making a copy of the existing collection and reassigning <code>posts</code> property,
all we need so far is changing the object reference.
Append the following <code>mutateArray</code> method to the main application component class:</p>
<pre><code class="language-ts">@Component({ /*...*/ })
export class AppComponent {
  // ...

  mutateArray() {
    this.posts = this.posts.concat();
  }
}
</code></pre>
<p>Finally edit the component template and add the following HTML content:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Posts&lt;/h2&gt;
&lt;div&gt;
  &lt;textarea [(ngModel)]=&quot;newPostContent&quot;&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;label&gt;
    &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;newPostPublic&quot;&gt;
    Is Public
  &lt;/label&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;button (click)=&quot;createPost()&quot;&gt;post&lt;/button&gt;
  &lt;button (click)=&quot;mutateArray()&quot;&gt;mutate array&lt;/button&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li *ngFor=&quot;let post of posts&quot;&gt;
    {{ post.content }} ({{ post.created | date:'short' }})
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>The layout above is pretty simple.
You get a text area element to enter a content for a new post, a checkbox to toggle the public state,
and two buttons <code>post</code> and <code>mutate array</code>.
Under the post editor there is a list of previously created posts, by default it is empty.</p>
<p>Once you compile and start the application you should see the following:</p>
<pre><code class="language-sh">ng serve --open
</code></pre>
<p><img src="images/pipes-pure-impure-01.png" alt="" /></p>
<p>Now you are ready testing <code>pure</code> and <code>impure</code> pipes in action.</p>
<h3 id="pure-pipes"><a class="header" href="#pure-pipes">Pure Pipes</a></h3>
<p>A &quot;pure pipe&quot; is a pipe that gets executed by Angular only when a &quot;pure change&quot; happens to the underlying input value, for example:</p>
<ul>
<li>a &quot;primitive&quot; value changes, for example of a <code>String</code>, <code>Number</code>, <code>Boolean</code> or other <code>primitive</code> types;</li>
<li>object reference changes, for instance an entire <code>Array</code>, <code>Date</code>, <code>Object</code> and other reference-based types;</li>
</ul>
<p>When you use a &quot;pure pipe&quot;, the Angular ignores all changes to the complex objects it gets as input parameters for the pipe.
For example, when using with arrays, the pipe renders data if your component class initializes default collection of items.
However, the pipe does not update the view if you add new items to the collection at run time.</p>
<blockquote>
<p><strong>Object Reference Checks</strong></p>
<p>Concerning performance and memory consumption, it is much faster for Angular to perform an object reference check
rather than initiating a deep check for complex object differences.</p>
<p>So &quot;pure&quot; pipes are extremely fast if you deal with primitives or change entire input value in your component.
Angular change detection mechanisms take care of values and execute pipes when needed.</p>
</blockquote>
<p>Let's use Angular CLI to generate our simple pure pipe and call it &quot;public-posts&quot;.</p>
<pre><code class="language-sh">ng g pipe pipes/public-posts
</code></pre>
<p>You should get your pipe scaffold and a basic unit test in the <code>src/app/pipes</code> folder:</p>
<pre><code class="language-text">installing pipe
  create src/app/pipes/public-posts.pipe.spec.ts
  create src/app/pipes/public-posts.pipe.ts
  update src/app/app.module.ts
</code></pre>
<p>Edit the <code>public-posts.pipe.ts</code> according to the following example:</p>
<pre><code class="language-ts">// src/app/pipes/public-posts.pipe.ts

import { Pipe, PipeTransform } from '@angular/core';
import { Post } from '../post';

@Pipe({
  name: 'publicPosts'
})
export class PublicPostsPipe implements PipeTransform {

  transform(posts: Post[]): any {
    return posts.filter(p =&gt; p.isPublic);
  }

}
</code></pre>
<p>Essentially the pipe takes a collection of <code>Post</code> instances as an input parameter <code>posts</code>
and returns a filtered result using <code>isPublic</code> property.</p>
<blockquote>
<p><strong>Pipe Name</strong></p>
<p>Note that your pipe's public name is going to be <code>publicPosts</code>.
You can give the component class any name you want, in our case, it is <code>PublicPostsPipe</code>,
but Angular is going to use <code>@Pipe</code> metadata when parsing component templates.</p>
</blockquote>
<p>Now let's add a couple of initial posts for our pipe to filter at run time:</p>
<pre><code class="language-ts">@Component({ /*...*/ })
export class AppComponent {

  posts: Post[] = [
    &lt;Post&gt; { 
      content: 'default public post', 
      isPublic: true, 
      created: new Date() 
    },
    &lt;Post&gt; { 
      content: 'default private post', 
      isPublic: false, 
      created: new Date() 
    }
  ];

}
</code></pre>
<p>The first post is going to be public while the second one is configured to be private by default.</p>
<p>For the next step, please update the application component template to show the <code>posts</code> collection,
filtered by our <code>publicPosts</code> pipe, in a separate unstructured list element.</p>
<pre><code class="language-html">&lt;h3&gt;Public posts (pure)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let post of posts | publicPosts&quot;&gt;
    {{ post.content }} ({{ post.created | date:'short' }})
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;All posts&lt;/h3&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let post of posts&quot;&gt;
    {{ post.content }} ({{ post.created | date:'short' }})
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>If you run your application right now, you should see one entry in the &quot;Public posts&quot; list and two entries in the &quot;All posts&quot; one.</p>
<p><img src="images/pipes-pure-01.png" alt="" /></p>
<p>So the pipe is working with predefined data as we expect it.
Now try adding couple more posts by entering content into the input area and clicking the &quot;post&quot; button.
Please ensure that &quot;Is Public&quot; checkbox element is set to &quot;checked&quot; state.</p>
<p>You should see the &quot;All posts&quot; list is getting updated, while &quot;Public posts&quot; one remains the same.
That is the expected behavior as we are modifying a complex object, in this case, an array of Post instances,
without actually changing object reference for the pipe.</p>
<p><img src="images/pipes-pure-02.png" alt="" /></p>
<p>The &quot;All posts&quot; list uses the <code>ngFor</code> directive, so Angular detects the change and updates it accordingly.
During the preparation phase, we have created a &quot;mutate array&quot; button that modifies <code>posts</code>
by replacing the collection with its copy.</p>
<p>If you click this button right now the &quot;Public posts&quot; should instantly update the view with new values:</p>
<p><img src="images/pipes-pure-03.png" alt="" /></p>
<h3 id="impure-pipes"><a class="header" href="#impure-pipes">Impure Pipes</a></h3>
<p>An &quot;impure pipe&quot; is a pipe that gets executed by Angular during every component change detection cycle.
All custom pipes are &quot;pure&quot; by default, in order to change its state to &quot;impure&quot;
you need to explicitly define that in the <code>@Pipe</code> decorator metadata:</p>
<pre><code class="language-ts">@Pipe({
  name: 'myCustomPipe',
  pure: false
})
</code></pre>
<blockquote>
<p><strong>Performance</strong></p>
<p>A single component may cause many change detection cycles based on various factors,
for example, user interaction, keyboard or mouse events.</p>
<p>Keep in mind that you pipe may affect overall application performance if it is slow,
or not optimized for frequent runs (data caching for instance).</p>
</blockquote>
<p>Let's create another pipe scaffold called &quot;public-posts-impure&quot; in the same project using Angular CLI:</p>
<pre><code class="language-sh">ng g pipe pipes/public-posts-impure
</code></pre>
<p>The command above should produce a new pipe next to the existing one in the <code>src/app/pipes</code> folder.</p>
<pre><code class="language-text">installing pipe
  create src/app/pipes/public-posts-impure.pipe.spec.ts
  create src/app/pipes/public-posts-impure.pipe.ts
  update src/app/app.module.ts
</code></pre>
<p>Next, update the pipe code like in the example below:</p>
<pre><code class="language-ts">// src/app/pipes/public-posts-impure.pipe.ts

import { Pipe, PipeTransform } from '@angular/core';
import { Post } from '../post';

@Pipe({
  name: 'publicPostsImpure',
  pure: false
})
export class PublicPostsImpurePipe implements PipeTransform {

  transform(posts: Post[]): any {
    return posts.filter(p =&gt; p.isPublic);
  }

}
</code></pre>
<p>The implementation of the pipe is pretty much the same we used before.
It takes a collection of posts as an input and returns a filtered result based on public state via <code>isPublic</code> property values.</p>
<p>We are going to use this pipe as &quot;publicPostsImpure&quot; in the HTML templates,
and we also explicitly set the <code>pure</code> property value in the <code>@Pipe</code> decorator metadata to false:</p>
<pre><code class="language-ts">@Pipe({
  name: 'publicPostsImpure',
  pure: false
})
</code></pre>
<p>Finally extend the main application component template with the list showing all public posts
filtered by the <code>publicPostsImpure</code> pipe:</p>
<pre><code class="language-html">&lt;h3&gt;Public posts (impure)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let post of posts | publicPostsImpure&quot;&gt;
    {{ post.content }} ({{ post.created | date:'short' }})
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>This time if you run the application and add several posts with &quot;Is Public&quot; element checked,
you should see the &quot;Public posts (impure)&quot; list gets updated at real-time.
That happens because our custom <code>publicPostsImpure</code> pipe gets executed by Angular during each change detection cycle.</p>
<p><img src="images/pipes-impure-01.png" alt="" /></p>
<h1 id="global-application-configuration"><a class="header" href="#global-application-configuration">Global Application Configuration</a></h1>
<p>In this chapter, we are going to focus on application settings and configuration files.</p>
<p>If you are building a large application or an application that performs the server side or RESTful APIs calls,
sooner or later you will come across the need to store global application settings somewhere.
For example the APIs URL string, you may hardcode it somewhere in the application or service,
but that will require rebuilding and redeploying your application every time the URL value needs changes.</p>
<p>It is much easier storing and loading configuration parameters in a separate file
that developers can maintain without changing the main application code.</p>
<p>Let's create an Application Configuration service that loads global settings from the external server-side file
before all other services get loaded, and provides access to configuration properties
for all other application components and services.</p>
<h2 id="preparing-the-configuration-file"><a class="header" href="#preparing-the-configuration-file">Preparing the Configuration File</a></h2>
<p>We are going to use the JSON format for configuration files. The name of the file can be anything as we need only the content.</p>
<p>As a first step, create an <code>app.config.json</code> file in the <code>src</code> folder with the following content:</p>
<p><strong>src/app.config.json</strong>:</p>
<pre><code class="language-json">{
  &quot;title&quot;: &quot;My application&quot;
}
</code></pre>
<blockquote>
<p><strong>Configuration Content</strong></p>
<p>Theoretically, you could even dynamically generate the file if necessary,
for example building the output based on some database values.</p>
</blockquote>
<p>In our case, we just store the custom application title in the config file to see the basic flow in action.
You can extend the file content later on with more properties and values.</p>
<p>We also need configuring Angular CLI to copy the newly created file to the application output directory upon every build.
Edit the <code>apps</code> section of the <code>angular.json</code> file and append the name of the settings file
to the &quot;assets&quot; collection like in the example below:</p>
<p><strong>angular.json</strong>:</p>
<pre><code class="language-json">{
    &quot;apps&quot;: {
        &quot;assets&quot;: [
            &quot;app.config.json&quot;
        ]
    }
}
</code></pre>
<blockquote>
<p><strong>Updating File Content</strong></p>
<p>One of the greatest features of Angular CLI is automatic rebuilding and live-reloading upon file changes.</p>
<p>If you start your application in the development mode, the runner should also be watching for the <code>app.config.json</code> changes,
and automatically reloading your application every time you update your settings.</p>
</blockquote>
<h2 id="creating-the-configuration-service"><a class="header" href="#creating-the-configuration-service">Creating the Configuration Service</a></h2>
<p>We now need two things to be created: an <code>AppConfig</code> interface to provide a type-safe access to our configuration properties,
and <code>AppConfigService</code> service that is going to load the remote file, store the resulting settings
and expose them to external components and services.</p>
<p>Use the following commands to generate both an interface and a service scaffolds:</p>
<pre><code class="language-sh">ng g interface app-config
ng g service app-config
</code></pre>
<blockquote>
<p>Don't forget to register the newly generated service with the main application module,
as Angular CLI does not do that by default.</p>
</blockquote>
<p>Now, edit the <code>AppConfig</code> interface and add the &quot;title&quot; property we have declared
in the server-side config earlier in this chapter:</p>
<pre><code class="language-ts">// src/app/app-config.ts

export interface AppConfig {

  title?: string;

}
</code></pre>
<p>Next, let's wire our <code>AppConfigService</code> with the <code>Http</code> service to be able making HTTP calls and fetching remote files:</p>
<pre><code class="language-ts">// src/app/app-config.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Injectable({ providedIn: 'root' })
export class AppConfigService {

  constructor(private http: HttpClient) {}

}
</code></pre>
<p>We are now ready to load the configuration from the server.</p>
<h2 id="loading-server-side-configuration-file"><a class="header" href="#loading-server-side-configuration-file">Loading Server-Side Configuration File</a></h2>
<p>Let's introduce the <code>load</code> method that fetches the <code>app.config.json</code> file and exposes its content as a <code>data</code> property.</p>
<p>For the convenience purposes, the method is going to return a <code>Promise</code> instance
that resolves to the loaded configuration file or falls back to the default values upon loading errors.
We also provide support for the optional default values that you can pass as part of the <code>load</code> call.</p>
<p>Below you can see the full code for the service implementation:</p>
<pre><code class="language-ts">// src/app/app-config.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { AppConfig } from './app-config';

@Injectable({ providedIn: 'root' })
export class AppConfigService {

  data: AppConfig = {};

  constructor(private http: HttpClient) {}

  load(defaults?: AppConfig): Promise&lt;AppConfig&gt; {
    return new Promise&lt;AppConfig&gt;(resolve =&gt; {
      this.http.get('app.config.json').subscribe(
        response =&gt; {
          console.log('using server-side configuration');
          this.data = Object.assign({}, defaults || {}, response || {});
          resolve(this.data);
        },
        () =&gt; {
          console.log('using default configuration');
          this.data = Object.assign({}, defaults || {});
          resolve(this.data);
        }
      );
    });
  }

}
</code></pre>
<p>As you can see from the code above, we also add a basic debugging output to the browser console log.
It should help us to see whether the application is using an external configuration file or fallback values.</p>
<p>Logging to console is a fully optional step, and you may want to remove that code at the later stages.</p>
<h2 id="registering-configuration-service"><a class="header" href="#registering-configuration-service">Registering Configuration Service</a></h2>
<p>Next, we need registering our configuration service with the main application module.
However, given that many other services and components may depend on the external settings,
we should ensure the application configuration service gets the <code>app.config.json</code> file loaded and applied before others.</p>
<p>The Angular framework provides a special injection token called <code>APP_INITIALIZER</code>
that you should use to execute your code during the application startup.
That also helps to register providers and to use provider factories.</p>
<p>For the sake of simplicity the example below shows only the newly added content:</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { /*...,*/ APP_INITIALIZER } from '@angular/core';
import { HttpClientModule } from '@angular/common/http';

export function setupAppConfigServiceFactory(
  service: AppConfigService
): Function {
  return () =&gt; service.load();
}

@NgModule({
  imports: [
    // ...,
    HttpClientModule
  ],
  providers: [
    {
        provide: APP_INITIALIZER,
        useFactory: setupAppConfigServiceFactory,
        deps: [
            AppConfigService
        ],
        multi: true
    }
  ]
})
export class AppModule { }
</code></pre>
<p>So how the code above works and how do we load an external configuration at the application startup?</p>
<p>First of all, we declare the <code>AppConfigService</code> in the <code>providers</code> section of the module.
Then we use the <code>APP_INITIALIZER</code> injection token to declare a custom provider based on the <code>setupAppConfigServiceFactory</code> factory;
the provider also references the <code>AppConfigService</code> as a dependency to inject when the factory gets invoked.</p>
<p>At the runtime, the Angular resolves and creates an instance of the <code>AppConfigService</code>,
and then uses it when calling the <code>setupAppConfigServiceFactory</code>.
The factory itself calls the &quot;load&quot; method to fetch the &quot;app.config.json&quot; file.</p>
<p>If you run the web application right now the browser console output should be as following:</p>
<pre><code class="language-text">using server-side configuration
</code></pre>
<p>The settings service is up and running correctly, and we are now able to use configuration settings in the components.</p>
<h2 id="using-configuration-settings"><a class="header" href="#using-configuration-settings">Using Configuration Settings</a></h2>
<p>It is now time to see the application configuration service in action.
Let's use the <code>title</code> value to update the similar property in the main application component.</p>
<p>We get the following controller class generated by the Angular CLI:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app';
}
</code></pre>
<p>All we need at this point is to inject the <code>AppConfigService</code> as an <code>appConfig</code> parameter
and assign the title property to the <code>appConfig.data.title</code> value.</p>
<blockquote>
<p>Don't forget that at this point the JSON file is already loaded and configuration properties are ready for use.</p>
</blockquote>
<pre><code class="language-ts">import { AppConfigService } from './app-config.service';

@Component({/*...*/})
export class AppComponent {
  title = 'app';

  constructor(appConfig: AppConfigService) {
    this.title = appConfig.data.title;
  }
}
</code></pre>
<p>If you run the web application now, the main page should contain the title value fetched from the external file.</p>
<p>Try editing the <code>title</code> value in the <code>app.config.json</code> and you should see the Angular CLI automatically reload the page.
The page automatically reflects new values.</p>
<p><img src="images/app-config-01.png" alt="" /></p>
<p>We just got a working example of the configuration service.
We have also checked the external settings being successfully fetched and applied to component properties.
The examples in the chapter should help you building configuration support for your applications.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code as an Angular CLI project in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/app-settings">angular/app-settings</a></strong> folder.</p>
</blockquote>
<h1 id="internationalization-i18n"><a class="header" href="#internationalization-i18n">Internationalization (i18n)</a></h1>
<p>In this chapter, we are going to build a simple multi-language support for an application.
We are about to create services to translate application strings, switch languages based on user interactions,
and also using third-party libraries for more sophisticated translation scenarios.</p>
<p>For a basic multi-language support we need at least three blocks:</p>
<ul>
<li>language files, preferably in the JSON format</li>
<li>Angular service to load one or multiple language files</li>
<li>Angular pipe for a convenient mapping of resource keys to translated values</li>
</ul>
<p>We start with generating a new Angular application called <code>app-i18n</code>:</p>
<pre><code class="language-sh">ng new app-i18n
cd app-i18n
</code></pre>
<p>Let's also use Angular CLI to generate our translation layer blocks, the <code>TranslateService</code> and the <code>TranslatePipe</code>:</p>
<pre><code class="language-sh">ng g service translate
ng g pipe translate
</code></pre>
<p>We also need at least a single language file to demonstrate the translation process in action,
and optionally use as a default or fallback locale.
Create a new <code>i18n</code> folder in the <code>src/assets</code> one, and put an <code>en.json</code> file there with the following content:</p>
<p><strong>src/assets/i18n/en.json</strong>:</p>
<pre><code class="language-json">{
  &quot;TITLE&quot;: &quot;My i18n Application (en)&quot;
}
</code></pre>
<h2 id="creating-translate-service"><a class="header" href="#creating-translate-service">Creating Translate Service</a></h2>
<p>As a second step, we need to make our <code>TranslateService</code> load the language file.</p>
<p>We are going to implement a <code>use</code> method that performs the loading process over the HTTP.
It takes the <code>lang</code> parameter holding the name of the locale and falls back to the <code>en</code> value.</p>
<pre><code class="language-ts">// src/app/translate.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Injectable({ providedIn: 'root' })
export class TranslateService {

  data: any = {};

  constructor(private http: HttpClient) {}

  use(lang: string): Promise&lt;{}&gt; {
    return new Promise&lt;{}&gt;(resolve =&gt; {
      const langPath = `assets/i18n/${lang || 'en'}`;

      this.http.get(langPath).subscribe(
        response =&gt; {
          this.data = response || {};
          resolve(this.data);
        },
        err =&gt; {
          this.data = {};
          resolve(this.data);
        }
      );
    });
  }
}
</code></pre>
<blockquote>
<p><strong>Loading server-side files</strong></p>
<p>The process of loading of the translation file is very similar to that of the global configuration files we have used earlier in this book.</p>
<p>Please refer to the <a href="ch10-00-global-application-configuration.html">Global Application Configuration</a> chapter for more details and examples.</p>
</blockquote>
<p>Next, let's register our service provider and a custom factory that triggers the <code>TranslateService</code>
to load default or predefined locale file before all other services and components get created.
That helps us ensure that all other elements of the application get access to translation feature at startup.</p>
<pre><code class="language-ts">// src/app/app.module.ts

export function setupTranslateServiceFactory(
    service: TranslateService): Function {
  return () =&gt; service.use('en');
}

@NgModule({
  providers: [
    TranslateService,
    {
      provide: APP_INITIALIZER,
      useFactory: setupTranslateServiceFactory,
      deps: [
        TranslateService
      ],
      multi: true
    }
  ]
})
export class AppModule { }
</code></pre>
<p>Now we can have a quick test to ensure the file got loaded and translation service has the data preserved.
Inject the service into the main application component and dump the entire data set to the browser console output.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { TranslateService } from './translate.service';

@Component({/*...*/})
export class AppComponent {
  title = 'app';

  constructor(translateService: TranslateService) {
    console.log(translateService.data);
  }
}
</code></pre>
<p>Once you run the web application and head to the browser console, you should see the following output:</p>
<p><img src="images/app-i18n-01.png" alt="" /></p>
<p>We got the translation service working as expected; now we can proceed to create the corresponding pipe.</p>
<h2 id="creating-translate-pipe"><a class="header" href="#creating-translate-pipe">Creating Translate Pipe</a></h2>
<p>The pipe we have generated at the beginning of this chapter needs to inject
the translation service instance in the constructor like in the code below:</p>
<pre><code class="language-ts">// src/app/translate.pipe.ts

import { Pipe, PipeTransform } from '@angular/core';
import { TranslateService } from './translate.service';

@Pipe({
  name: 'translate'
})
export class TranslatePipe implements PipeTransform {

  constructor(private translate: TranslateService) {}

  transform(value: any, args?: any): any {
    return null;
  }

}
</code></pre>
<p>Now the pipe needs to map the key to the underlying resource string.</p>
<p>Let's get also provide a fallback behavior and return the resource key if the corresponding translation is missing.
That should help you to identify the problems with translation earlier.</p>
<pre><code class="language-ts">// src/app/translate.pipe.ts

@Pipe({/*...*/})
export class TranslatePipe implements PipeTransform {
  // ...

  transform(key: any): any {
    return this.translate.data[key] || key;
  }

}
</code></pre>
<p>Don't forget that your newly created pipe needs to be present in the main application module.
The Angular CLI tool automatically registers it, if you have added the pipe manually then see the following code for example:</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { TranslatePipe } from './translate.pipe';

@NgModule({
  declarations: [
    // ...,
    
    TranslatePipe
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<h2 id="using-translate-pipe"><a class="header" href="#using-translate-pipe">Using Translate Pipe</a></h2>
<p>It is time to see our translation pipe in action.
Let's update the main application controller class and set the <code>title</code> property value to the <code>TITLE</code> resource key like below:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {

  title = 'TITLE';

  // ...
}
</code></pre>
<p>If you open the <code>app.component.html</code> template file, you should see the <code>title</code> property referenced in the welcome message:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h1&gt;
    Welcome to {{ title }}!
&lt;/h1&gt;
</code></pre>
<p>We can just append the pipe to the <code>title</code> value to enable automatic translation of the value
based on the resource strings in the translation file.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h1&gt;
    Welcome to {{ title | translate }}!
&lt;/h1&gt;
</code></pre>
<p>Once you compile and run the web application, you should see the welcome message getting the text directly from the language file.</p>
<p><img src="images/app-i18n-02.png" alt="" /></p>
<h2 id="switching-languages"><a class="header" href="#switching-languages">Switching Languages</a></h2>
<p>We have the default locale working so far, but switching languages at runtime require some extra configuration steps.</p>
<p>First, let's create an additional file <code>ua.json</code> in the <code>assets/i18n</code> folder.
For testing purposes, you can just copy the contents of the <code>en.json</code> file
and slightly modify the strings to be able to see the difference at runtime.</p>
<p><strong>src/assets/i18n/ua.json</strong>:</p>
<pre><code class="language-json">{
  &quot;TITLE&quot;: &quot;My i18n Application (ua)&quot;
}
</code></pre>
<p>The main application controller class needs a new <code>setLang</code> method
so that we can switch to a different language with, for instance, a button click.</p>
<p>With our current <code>TranslateService</code> implementation, we need just the name of the locale:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {
  title = 'TITLE';

  constructor(private translateService: TranslateService) {
    console.log(translateService.data);
  }

  setLang(lang: string) {
    this.translateService.use(lang);
  }
}
</code></pre>
<p>Get back to the application component template and add a couple of buttons
to switch between the languages like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;div&gt;
  &lt;button (click)=&quot;setLang('ua')&quot;&gt;Language: UA&lt;/button&gt;
  &lt;button (click)=&quot;setLang('en')&quot;&gt;Language: EN&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>If you try running the application right now, you should notice that buttons do not work.
If you run the Dev Tools and inspect the Network tab, you are going to see that a corresponding language file is,
in fact, fetched every time you click the buttons.</p>
<p>You do not see the changes on the page because of how the pipes in Angular work by default.
For the performance reasons, they cache the result once the value is transformed and always use evaluated values in subsequent calls.</p>
<p>In our particular case, we need the pipe to refresh, so the caching needs to be switched off.
You can achieve that by setting the &quot;pure&quot; attribute of the <code>@Pipe</code> decorator metadata to &quot;false&quot;.</p>
<pre><code class="language-ts">// src/app/translate.pipe.ts

@Pipe({
  name: 'translate',
  pure: false
})
export class TranslatePipe implements PipeTransform {

 // ...

}
</code></pre>
<blockquote>
<p><strong>Pure and Impure Pipes</strong></p>
<p>You can get more details in the <strong><a href="ch09-00-pipes.html">Pipes</a></strong> chapter,
specifically in the <strong><a href="ch09-05-pure-and-impure-pipes.html">Pure And Impure Pipes</a></strong> section.</p>
</blockquote>
<p>Try rerunning your web application, and clicking the buttons to switch between languages.
You should see the label text getting updated each time the button gets clicked.</p>
<p><img src="images/app-i18n-03.png" alt="" /></p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>You just have got a basic lightweight multi-language functionality that you can use in your web application.</p>
<p>Note, however, that translation layer may require many code enhancements and performance optimizations,
for you to be ready to use it for production purposes.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code as an Angular CLI project in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/app-i18n">angular/i18n</a></strong> folder.</p>
</blockquote>
<p>You can also check out one of my Angular projects <strong><a href="https://www.npmjs.com/package/@ngstack/translate">@ngstack/translate</a></strong>
that provides i18n-features for Angular applications and components.
That library can save a lot of your time and effort required to build a multi-lingual web application.</p>
<h1 id="reusable-component-libraries"><a class="header" href="#reusable-component-libraries">Reusable Component Libraries</a></h1>
<p>We have already used the Angular CLI to generate applications.
For the time being the CLI does not support creating the reusable libraries,
so we are going to use &quot;<a href="https://github.com/dherges/ng-packagr">ng-packagr</a>&quot; tool for this purpose.</p>
<p>The &quot;ng-packagr&quot; transpiles your component libraries
using the &quot;<a href="https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/preview">Angular Package Format</a>&quot;.
Resulting bundles are ready to be consumed by Angular CLI, Webpack, or SystemJS.
For more details on the features, please refer to the project page.</p>
<p>In this chapter, we are going to use Angular CLI to create a new Angular application and two reusable component libraries:
a header and a sidebar components. Both libraries can be built and published to NPM separately.</p>
<p>Also, the application is going to be linked with the component libraries locally.
That allows developing and testing components with the main application.</p>
<h2 id="creating-new-application"><a class="header" href="#creating-new-application">Creating New Application</a></h2>
<p>Let's use Angular CLI to create a new application and call it <code>ng-framework</code>.
You can use that application to test components before building and publishing them to NPM, or redistributing via other resources.</p>
<pre><code class="language-sh">ng new ng-framework
</code></pre>
<p>For convenience purposes, you can change the &quot;start&quot; script to also launch the application in the browser.
To do that, open the <code>package.json</code> file and append <code>--open</code> argument to the <code>start</code> command:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;ng serve --open&quot;
    }
}
</code></pre>
<p>Next, you need to install the <code>ng-packagr</code> library as a development dependency.</p>
<pre><code class="language-sh">npm install ng-packagr --save-dev
</code></pre>
<p>At this point, the project setup is complete, and you are ready to start building reusable component libraries.</p>
<h2 id="creating-component-libraries"><a class="header" href="#creating-component-libraries">Creating Component Libraries</a></h2>
<p>Now, we are going to create two separate projects with the <code>header</code> and <code>sidebar</code> components.
That should be more than enough to demonstrate publishing and consuming multiple component libraries.</p>
<p>In the root project folder, run the following commands to create an initial folder structure.</p>
<pre><code class="language-sh">mkdir -p modules/header/src
mkdir -p modules/sidebar/src
</code></pre>
<p>As you can see, the <code>modules</code> folder contains all the component projects as subfolders.</p>
<p>Let's start with the <code>header</code> component first, and you can then perform similar steps to implement the <code>sidebar</code>.</p>
<p>First, create a component class and give it a unique selector to avoid clashes at runtime.
The value can be anything of your choice, for this guide we are going to use <code>ngfw-header</code>.</p>
<pre><code class="language-ts">// modules/header/src/header.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'ngfw-header',
  templateUrl: './header.component.html',
  styleUrls: ['./header.component.css']
})
export class HeaderComponent {}
</code></pre>
<p>The template is going to be very simple. An <code>h1</code> element wrapping the <code>ng-content</code> is the minimal implementation we need right now.
You can always extend it later with the more sophisticated layout and behavior.</p>
<pre><code class="language-html">&lt;!-- modules/header/src/header.component.html --&gt;

&lt;h1&gt;
  &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/h1&gt;
</code></pre>
<p>Add some CSS to be sure the styles are also loaded from the package when we start using it with the application.
In our case, the colour of the header is going to be red.</p>
<pre><code class="language-css">/* modules/header/src/header.component.css */

h1 {
  color: red;
}
</code></pre>
<p>Finally, as per Angular architecture, we need to have a module
that imports all necessary dependencies and provides declarations and exports.</p>
<p>The most important part of our scenario is to put the <code>HeaderComponent</code> to the <code>exports</code> collection.</p>
<pre><code class="language-ts">// modules/header/src/header.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HeaderComponent } from './header.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [
    HeaderComponent
  ],
  exports: [
    HeaderComponent
  ]
})
export class HeaderModule { }
</code></pre>
<p>As the <code>header</code> component it planned to be published as a separate library, we need to provide a <code>package.json</code> file.</p>
<p>Below is a simple set of details that needs to be in <code>package.json</code> for a library before publishing.
Note that you can also use NPM scopes to have unique library names associated with your NPM account for instance.</p>
<p><strong>modules/header/package.json</strong>:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;@denysvuika/ng-framework-header&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;author&quot;: &quot;Denys Vuika &lt;denys.vuika@gmail.com&gt;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;private&quot;: false,
  &quot;peerDependencies&quot;: {
    &quot;@angular/common&quot;: &quot;^5.0.0&quot;,
    &quot;@angular/core&quot;: &quot;^5.0.0&quot;
  }
}
</code></pre>
<pre><code class="language-ts">// modules/header/public_api.ts

export * from './src/header.module';
</code></pre>
<p>Now you can repeat the steps above to implement the second <code>sidebar</code> component.
The only difference is the name of the project in the <code>package.json</code> file.</p>
<p><strong>modules/sidebar/package.json</strong>:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;@denysvuika/ng-framework-sidebar&quot;,
}
</code></pre>
<p>Also, let's also change the colour to <code>green</code>, just to see we are dealing with two different stylesheets at runtime.</p>
<pre><code class="language-css">/* modules/sidebar/src/sidebar.component.css */

h1 {
  color: green;
}
</code></pre>
<h2 id="building-the-packages"><a class="header" href="#building-the-packages">Building the Packages</a></h2>
<p>To build the project and produce bundles we need to create a <code>ng-package.json</code> file for the <code>ng-packagr</code>.
The file should live next to the <code>package.json</code> in the library root folder.</p>
<p><strong>modules/header/ng-package.json</strong>:</p>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;../../node_modules/ng-packagr/ng-package.schema.json&quot;,
  &quot;lib&quot;: {
    &quot;entryFile&quot;: &quot;public_api.ts&quot;
  }
}
</code></pre>
<p>Note that the same file should be present in both our library root folders.
Feel free to copy and paste it, since the file does not contain any project-specific content at this point.</p>
<p>To build a project with <code>ng-packagr</code>, we can provide a path to the configuration file.
That also allows us to build more than one project from the NPM scripts.</p>
<p>You can refer to the example below, with only the change needed for the build, for the sake of simplicity.</p>
<p><strong>package.json</strong>:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;build:modules&quot;: &quot;ng-packagr -p ./modules/header/ng-package.json &amp;&amp; ng-packagr -p ./modules/sidebar/ng-package.json&quot;
    }
}
</code></pre>
<p>Now go to the root folder and execute the following command to build our libraries:</p>
<pre><code class="language-sh">npm run build:modules
</code></pre>
<p>You should see the output similar to the following:</p>
<pre><code class="language-text">$ ng-packagr -p ./modules/header/ng-package.json
Building Angular library
Generating bundle for @denysvuika/ng-framework-header
Cleaning bundle build directory
Processing assets
Running ngc
Compiling to FESM15
Compiling to FESM5
Compiling to UMD
Minifying UMD bundle
Remapping source maps
Copying staged files
Writing package metadata
Built Angular bundle for @denysvuika/ng-framework-header

Building Angular library
Generating bundle for @denysvuika/ng-framework-sidebar
Cleaning bundle build directory
Processing assets
Running ngc
Compiling to FESM15
Compiling to FESM5
Compiling to UMD
Minifying UMD bundle
Remapping source maps
Copying staged files
Writing package metadata
</code></pre>
<p>The resulting bundles are in the <code>dist</code> folder for every compiled project.
Try expanding the one for the <code>header</code> component, and you should see the structure similar to that in the screenshot below:</p>
<p><img src="images/ng-libraries-01.png" alt="" /></p>
<h2 id="publishing-to-npm"><a class="header" href="#publishing-to-npm">Publishing to NPM</a></h2>
<p>You need to have an <a href="https://www.npmjs.com/">NPM</a> account to publish libraries.
Once you get it, the process is relatively simple.</p>
<p>You need to run the <code>npm publish</code> command from within every <code>dist</code> folder the <code>ng-packagr</code> creates.
If you publish the very first version of the library, the <code>access</code> attribute needs to be present as well, for example:</p>
<pre><code class="language-sh">cd modules/header/dist
npm publish --access public
</code></pre>
<blockquote>
<p><strong>Package Scope</strong></p>
<p>You will need to change the scope of your package to be able to publish the project under your account.</p>
</blockquote>
<h2 id="integrating-with-the-application"><a class="header" href="#integrating-with-the-application">Integrating with the Application</a></h2>
<p>Developing components can take time, and you also need to test them
and get running in some demo application before publishing to NPM.
For this case, we need to link the projects as if they got installed from the public source.</p>
<p>First, we modify the root <code>tsconfig.json</code> file to map component namespaces to the corresponding <code>dist</code> folders.
That should also enable code completion support and type checking in your IDE.</p>
<p><strong>tsconfig.json</strong>:</p>
<pre><code class="language-json">{
    &quot;compileOnSave&quot;: false,
    &quot;compilerOptions&quot;: {
        ...,

        &quot;baseUrl&quot;: &quot;.&quot;,
        &quot;paths&quot;: {
            &quot;@denysvuika/ng-framework-header&quot;: [ &quot;modules/header/dist&quot; ],
            &quot;@denysvuika/ng-framework-sidebar&quot;: [ &quot;modules/sidebar/dist&quot; ]
        }
    }
}
</code></pre>
<p>So now, every time you reference the <code>@denysvuika/ng-framework-header</code> namespace,
the application is going to fetch the code from the <code>modules/header/dist</code> folder instead of the <code>node_modules</code> one.</p>
<p>Similar behavior is going to be for the <code>sidebar</code> component as well. You can map as many paths as you need.</p>
<p>For the second step, you need to update the <code>tsconfig.app.json</code> file
and map the namespaces to the corresponding <code>public_api.ts</code> files.
We define the mappings for both <code>compilerOptions</code> and <code>angularCompilerOptions</code> as in the next example:</p>
<p><strong>src/tsconfig.app.json</strong>:</p>
<pre><code class="language-json">{
  &quot;extends&quot;: &quot;../tsconfig.json&quot;,
  &quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;../out-tsc/app&quot;,
    &quot;baseUrl&quot;: &quot;./&quot;,
    &quot;module&quot;: &quot;es2015&quot;,
    &quot;types&quot;: [],
    &quot;paths&quot;: {
      &quot;@denysvuika/ng-framework-header&quot;: [ &quot;../modules/header/public_api.ts&quot; ],
      &quot;@denysvuika/ng-framework-sidebar&quot;: [ &quot;../modules/sidebar/public_api.ts&quot; ]
    }
  },
  &quot;exclude&quot;: [
    &quot;test.ts&quot;,
    &quot;**/*.spec.ts&quot;
  ],
  &quot;angularCompilerOptions&quot;: {
    &quot;paths&quot;: {
      &quot;@denysvuika/ng-framework-header&quot;: [ &quot;../modules/header/public_api.ts&quot; ],
      &quot;@denysvuika/ng-framework-sidebar&quot;: [ &quot;../modules/sidebar/public_api.ts&quot; ]
    }
  }
}
</code></pre>
<p>Finally, let's use our libraries in the application as if they got installed from the NPM.
Import the <code>HeaderModule</code> and <code>SidebarModule</code> from the corresponding namespaces into the main application module.</p>
<pre><code class="language-ts">// src/app/app.module.ts

import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { HeaderModule } from '@denysvuika/ng-framework-header';
import { SidebarModule } from '@denysvuika/ng-framework-sidebar';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HeaderModule,
    SidebarModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>Replace the content of the main application component template with the next markup:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;ngfw-header&gt;Header&lt;/ngfw-header&gt;
&lt;ngfw-sidebar&gt;Sidebar&lt;/ngfw-sidebar&gt;
</code></pre>
<p>Serve the application with &quot;npm start&quot;, and you should see the following output:</p>
<p><img src="images/ng-libraries-02.png" alt="" /></p>
<p>The configuration is complete. You are now ready to build, test and publish component libraries.</p>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<p><a href="https://medium.com/@ngl817/building-an-angular-4-component-library-with-the-angular-cli-and-ng-packagr-53b2ade0701e">Building an Angular 4 Component Library with the Angular CLI and ng-packagr</a></p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the <strong><a href="https://gitlab.com/DenysVuika/ng-framework">ng-framework</a></strong> repository.</p>
<p>Don't forget to change the package names and NPM scopes if you intend publishing projects to NPM.</p>
</blockquote>
<h1 id="dynamic-content-in-angular"><a class="header" href="#dynamic-content-in-angular">Dynamic Content in Angular</a></h1>
<blockquote>
<p>Warning: this chapter was written using the earlier versions of Angular and needs review.</p>
</blockquote>
<p>In this section, we are going to see in practice different ways
of dynamically creating and modifying content in Angular at runtime.</p>
<p>You are about to get examples of custom entry templates in a List component,
see how <code>Component</code> and <code>Module</code> compilation works.</p>
<h2 id="list-item-templates"><a class="header" href="#list-item-templates">List Item Templates</a></h2>
<p>In this part, we are going to see how you can enrich Angular components with custom templating support.
We start by building a simple List component that supports external entry templates
that a developer defines as part of the application.</p>
<h3 id="list-component"><a class="header" href="#list-component">List component</a></h3>
<p>First, let's create a simple component to render an unordered list of bound items, and call it <code>TemplatedListComponent</code>.</p>
<p>With the Angular CLI the command should look like the following:</p>
<pre><code class="language-text">ng g component templated-list
</code></pre>
<p>The Angular CLI generates all required scaffold for your component and updates main application module,
so you are strongly recommended using it to save your time.</p>
<p>As you can remember from the <a href="ch04-00-angular-cli.html">Angular CLI</a> chapter,
all generated artifacts should have prefixes to avoid conflicts with standard HTML elements or third party components.
In our case, the Angular CLI tool automatically prepends the default <code>app-</code> prefix to the component selector value:</p>
<pre><code class="language-ts">// src/app/templated-list/templated-list.component.ts

@Component({
  selector: 'app-templated-list',
  templateUrl: './templated-list.component.html',
  styleUrls: ['./templated-list.component.css']
})
export class TemplatedListComponent { ... }
</code></pre>
<p>For now, the only property that our newly created list needs is an array of items to display.
Every item must have at least a <code>title</code> property, so we use a generic Array type with the corresponding constraints.</p>
<pre><code class="language-ts">// src/app/templated-list/templated-list.component.ts

@Component({/*...*/})
export class TemplatedListComponent {

  @Input()
  items: Array&lt;{title: string}&gt; = [];

}
</code></pre>
<p>Note that array is empty by default.
By our design, the items are not hard coded into the component and should be coming from the application instead.</p>
<p>For the template part, a simple unordered list with <code>ngFor</code> directive should be more than enough to demonstrate the content:</p>
<pre><code class="language-html">&lt;!-- src/app/templated-list/templated-list.component.html --&gt;

&lt;ul&gt;
  &lt;li *ngFor=&quot;let item of items&quot;&gt;
    {{ item.title }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Next, let's provide our List with some data and see it working.
Edit your main application component class and add the <code>listItems</code> property with some basic entries:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {
    // ...

    listItems: Array&lt;{title: string}&gt; = [
        { title: 'item 1' },
        { title: 'item 2' },
        { title: 'item 3' }
    ]
}
</code></pre>
<p>Don't forget to modify the HTML template of the component and declare the <code>&lt;app-templated-list&gt;</code> component
with the corresponding bindings:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Templated List&lt;/h2&gt;
&lt;app-templated-list [items]=&quot;listItems&quot;&gt;
&lt;/app-templated-list&gt;
</code></pre>
<p>If you run your web application right now you should see the HTML unordered list element
with three entries like on the picture below:</p>
<p><img src="images/dynamic-content-01.png" alt="" /></p>
<h3 id="row-templates"><a class="header" href="#row-templates">Row Templates</a></h3>
<p>So we got a simple list component that binds to an array of objects and renders standard unordered HTML element
where every entry binds its content to the <code>title</code> property of the underlying object.</p>
<p>Now let's update the code to provide support for external templates.</p>
<p>First, you need a property to hold custom template reference.
That requires importing a <code>@ContentChild</code> decorator and <code>TemplateRef</code> type.</p>
<pre><code class="language-ts">// src/app/templated-list/templated-list.component.ts

import { /*...,*/ ContentChild, TemplateRef } from '@angular/core';

@Component({/*...*/})
export class TemplatedListComponent {

    @ContentChild(TemplateRef)
    template: TemplateRef&lt;any&gt;;

    @Input()
    items: Array&lt;{title: string}&gt; = [];

}
</code></pre>
<p>The @ContentChild decorator helps you to bind the property value to the first child element
of the specific type in out List component at run time.
In our particular case, we are instructing decorator to look for the first <code>&lt;ng-template&gt;</code> instance
exposed via TemplateRef reference.</p>
<p>For example:</p>
<pre><code class="language-html">&lt;app-templated-list&gt;
  &lt;ng-template&gt;
    &lt;!-- ... --&gt;
  &lt;/ng-template&gt;
&lt;/app-templated-list&gt;
</code></pre>
<p>For the next step, let's update our List component template to use provided template property value for each entry.</p>
<pre><code class="language-html">&lt;!-- src/app/templated-list/templated-list.component.html --&gt;

&lt;ul&gt;
    &lt;ng-template ngFor [ngForOf]=&quot;items&quot; [ngForTemplate]=&quot;template&quot;&gt;
    &lt;/ng-template&gt;
&lt;/ul&gt;
</code></pre>
<p>Now the <code>TemplatedListComponent</code> expects a <code>template</code> instance as its child element in the form of <code>&lt;ng-template&gt;</code>.</p>
<p>It then takes the content of the template and applies to each <code>*ngFor</code> entry.
So application developers can define entire row template like the following:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Templated List&lt;/h2&gt;
&lt;app-templated-list [items]=&quot;listItems&quot;&gt;
    &lt;ng-template&gt;
        &lt;li&gt;
            List item template content
        &lt;/li&gt;
    &lt;/ng-template&gt;
&lt;/app-templated-list&gt;
</code></pre>
<p>If you now run your web app you should see the following output:</p>
<p><img src="images/dynamic-content-02.png" alt="" /></p>
<p>As you can see on the picture above the template works as expected.
We define a static content and see it rendered three times.
Now to see the data change across the list entries update component template like in the next example:</p>
<pre><code class="language-html">&lt;h2&gt;Templated List&lt;/h2&gt;
&lt;app-templated-list [items]=&quot;listItems&quot;&gt;
    &lt;ng-template let-item=&quot;$implicit&quot; let-i=&quot;index&quot;&gt;
        &lt;li&gt;[{{i}}] Hello: {{item.title}}&lt;/li&gt;
    &lt;/ng-template&gt;
&lt;/app-templated-list&gt;
</code></pre>
<p>Upon building the elements, the &quot;ngFor&quot; directive takes each object in the collection
and uses it as a data context for every corresponding list item and its custom template.
To get direct access to this object we are using the <code>let-item=&quot;$implicit&quot;</code> attribute.
That reads as &quot;bind the object to the template variable called 'item'&quot;.</p>
<p>You can omit the &quot;$implicit&quot; value and use just the <code>let-item</code> attribute if you like.
You can also give the template variable any name; it can be <code>let-data</code>, <code>let-context</code> or any name of your choice.</p>
<p>The <code>ngFor</code> directive provides us with the numeric index for each item in the collection.
We bind it inside the template to the <code>i</code> variable using the <code>let-i=&quot;index&quot;</code> syntax.</p>
<p>So to demonstrate both data context bindings, we used the following list item template:</p>
<pre><code class="language-html">&lt;ng-template let-item=&quot;$implicit&quot; let-i=&quot;index&quot;&gt;
    &lt;li&gt;[{{i}}] Hello: {{item.title}}&lt;/li&gt;
&lt;/ng-template&gt;
</code></pre>
<p>Once your web application runs you should see the following result:</p>
<p><img src="images/dynamic-content-03.png" alt="" /></p>
<p>We are now able to see index value, static &quot;Hello&quot; text and &quot;title&quot; property of the underlying object.</p>
<h3 id="typical-use-cases"><a class="header" href="#typical-use-cases">Typical use cases</a></h3>
<p>You are going to use the above approach when building list-like or grid-like components
that hide all complexity from the developers but at the same time allow customizing entries or rows using templates.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/dynamic-content">angular/components/dynamic-content</a></strong> folder.</p>
</blockquote>
<h2 id="dynamic-components"><a class="header" href="#dynamic-components">Dynamic Components</a></h2>
<p>Another interesting scenario involves changing the content of the component based on some condition evaluation result.
For example, rendering different child component depending on the value of the <code>type</code> property:</p>
<pre><code class="language-html">&lt;component type=&quot;my-type-1&quot;&gt;&lt;/component&gt;
&lt;component type=&quot;my-type-2&quot;&gt;&lt;/component&gt;
</code></pre>
<p>Let's start with a component scaffold generated by the Angular CLI using the following command:</p>
<pre><code class="language-text">ng g component dynamic-content
</code></pre>
<p>For the first step, update the HTML template of the newly generated component with the following one:</p>
<pre><code class="language-html">&lt;!-- src/app/dynamic-content/dynamic-content.component.html --&gt;

&lt;div&gt;
  &lt;div #container&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Note how we declare a separate <code>&lt;div&gt;</code> element with the <code>#container</code> id.</p>
<p>We are going to use it as the injection point. All dynamic content should get inserted in the DOM below this element.
The component maps it to the <code>container</code> property of the <code>ViewContainerRef</code> type
to allow you access container element from the code.</p>
<pre><code class="language-ts">import { /*...,*/ Input, ViewChild, ViewContainerRef } from '@angular/core';

@Component({/*...*/})
export class DynamicContentComponent {

  @ViewChild('container', { read: ViewContainerRef })
  container: ViewContainerRef;

  @Input()
  type: string;

}
</code></pre>
<p>Later on, you should be able to use this component similar to the following example:</p>
<pre><code class="language-html">&lt;dynamic-content type=&quot;some-value&quot;&gt;&lt;/dynamic-type&gt;
</code></pre>
<p>Now let's introduce two more components to display depending on the <code>type</code> property value.
We also are going to need an additional <code>fallback</code> component to use for all the <code>unknown</code> types.</p>
<p>For the sake of simplicity, you can append new components to the same <code>dynamic-content</code> component file.</p>
<pre><code class="language-ts">// src/app/dynamic-content/dynamic-content.component.ts

@Component({
  selector: 'app-dynamic-sample-1',
  template: `&lt;div&gt;Dynamic sample 1&lt;/div&gt;`
})
export class DynamicSample1Component {}

@Component({
  selector: 'app-dynamic-sample-2',
  template: `&lt;div&gt;Dynamic sample 2&lt;/div&gt;`
})
export class DynamicSample2Component {}

@Component({
  selector: 'app-unknown-component',
  template: `&lt;div&gt;Unknown component&lt;/div&gt;`
})
export class UnknownDynamicComponent {}
</code></pre>
<p>Developers are going to use the &quot;type&quot; property that has the type of <code>string</code>
and gets used as an alias for real component types.</p>
<p>You are going to need some mapping of string values to types,
either in the form of separate injectable service (recommended approach)
or just a part of the component implementation like in the example below:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class DynamicContentComponent {
  // ...

  private mappings = {
    'sample1': DynamicSample1Component,
    'sample2': DynamicSample2Component
  };

  getComponentType(typeName: string) {
    const type = this.mappings[typeName];
    return type || UnknownDynamicComponent;
  }

}
</code></pre>
<p>As you can see from the code above, for <code>sample1</code> and <code>sample2</code> values the newly introduced components
<code>DynamicSample1Component</code> and <code>DynamicSample2Component</code> are returned.</p>
<p>For all other cases, we are going to take the <code>UnknownDynamicComponent</code> component.</p>
<p>Finally, we are ready to create components dynamically.
Below is the simplified version of component class implementation that shows the main blocks of interest:</p>
<pre><code class="language-ts">import {
    // ...,
    OnInit, OnDestroy,
    ComponentRef, ComponentFactoryResolver
} from '@angular/core';

@Component({/*...*/})
export class DynamicContentComponent implements OnInit, OnDestroy {
  // ...

  private componentRef: ComponentRef&lt;{}&gt;;

  constructor(private resolver: ComponentFactoryResolver) { }

  ngOnInit() {
    if (this.type) {
      const componentType = this.getComponentType(this.type);
      const factory = this.resolver.resolveComponentFactory(componentType);
      
      this.componentRef = this.container.createComponent(factory);
    }
  }

  ngOnDestroy() {
    if (this.componentRef) {
      this.componentRef.destroy();
      this.componentRef = null;
    }
  }

}
</code></pre>
<p>We inject the <code>ComponentFactoryResolver</code> into the component at runtime
and use it to build the dynamic content upon initialization,
and tear down when our parent component gets destroyed.</p>
<p>The process of content creation is quite straightforward.
First, we resolve the component type by the string value.
Second, we resolve a component factory for the given component type.
Finally, we use that factory to build a component.
Newly created content gets automatically appended to the DOM after the <code>#container</code> element.</p>
<p>Please note that you must register every component you create dynamically within the <code>entryComponents</code> section of your module.
That instructs the Angular framework to maintain corresponding factories at runtime.</p>
<pre><code class="language-ts">// src/app.module.ts

@NgModule({
  imports: [ /*...*/ ],
  declarations: [ /*...*/ ],
  entryComponents: [
    DynamicSample1Component,
    DynamicSample2Component,
    UnknownDynamicComponent
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>You can now test all three cases with the following layout:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h2&gt;Dynamic Content&lt;/h2&gt;
&lt;app-dynamic-content type=&quot;sample1&quot;&gt;&lt;/app-dynamic-content&gt;
&lt;app-dynamic-content type=&quot;sample2&quot;&gt;&lt;/app-dynamic-content&gt;
&lt;app-dynamic-content type=&quot;some-other-type&quot;&gt;&lt;/app-dynamic-content&gt;
</code></pre>
<p>The main application page should look like the following:</p>
<p><img src="images/dynamic-content-04.png" alt="" /></p>
<h3 id="runtime-context"><a class="header" href="#runtime-context">Runtime context</a></h3>
<p>The easiest way to maintain different types of dynamic components in the code
is to build a common interface or an abstract class with a shared API.
For example:</p>
<pre><code class="language-ts">abstract class DynamicComponent {
  
  context: any;

}
</code></pre>
<p>Note that for the sake of simplicity we are declaring <code>context</code> property of <code>any</code> type.</p>
<blockquote>
<p>In real-life scenarios, however, you may want to use some particular type
to benefit from the static checks the Typescript compiler provides.</p>
</blockquote>
<p>Now you can update all previously created components to expose the <code>DynamicComponent</code> class and take <code>context</code> into account.</p>
<pre><code class="language-ts">@Component({
  selector: 'app-dynamic-sample-1',
  template: `&lt;div&gt;Dynamic sample 1 ({{context?.text}})&lt;/div&gt;`
})
export class DynamicSample1Component extends DynamicComponent {}

@Component({
  selector: 'app-dynamic-sample-2',
  template: `&lt;div&gt;Dynamic sample 2 ({{context?.text}})&lt;/div&gt;`
})
export class DynamicSample2Component extends DynamicComponent {}

@Component({
  selector: 'app-unknown-component',
  template: `&lt;div&gt;Unknown component ({{context?.text}})&lt;/div&gt;`
})
export class UnknownDynamicComponent extends DynamicComponent {}
</code></pre>
<p>Next, the <code>DynamicContentComponent</code> needs updates to receive the value of the <code>context</code> from the outside using bindings,
and pass it to the underlying child component.</p>
<pre><code class="language-ts">export class DynamicContentComponent implements OnInit, OnDestroy {
    // ...

    @Input()
    context: any;

    ngOnInit() {
        if (this.type) {
            // ...
            
            let instance = &lt;DynamicComponent&gt; this.componentRef.instance;
            instance.context = this.context;
        }
    }
}
</code></pre>
<p>That is it, and we are ready to test the whole flow.
Add a simple object to the main application component class to use as a <code>context</code> value for the dynamic elements:</p>
<pre><code class="language-ts">// src/app.component.ts

export class AppComponent {

  context: { text: string } = {
    text: 'test'
  }

}
</code></pre>
<p>Now bind this context to all three components we declared earlier in the template:</p>
<pre><code class="language-html">&lt;!-- src/app.component.html --&gt;

&lt;h3&gt;Context: &lt;input type=&quot;text&quot; [(ngModel)]=&quot;context.text&quot;&gt;&lt;/h3&gt;
&lt;app-dynamic-content type=&quot;sample1&quot; [context]=&quot;context&quot;&gt;&lt;/app-dynamic-content&gt;
&lt;app-dynamic-content type=&quot;sample2&quot; [context]=&quot;context&quot;&gt;&lt;/app-dynamic-content&gt;
&lt;app-dynamic-content type=&quot;some-other-type&quot; [context]=&quot;context&quot;&gt;&lt;/app-dynamic-content&gt;
</code></pre>
<p>To demonstrate &quot;live updates&quot; feature, we add an input element to the page.
The element is using &quot;two-way&quot; binding to the <code>context.text</code> property.
According to our setup, all dynamically created components should automatically reflect the new value as we type.</p>
<p>Note that to use <code>ngModel</code> directive you need to import and reference the <code>FormModule</code>
within your main application module like in the example below:</p>
<pre><code class="language-ts">// src/app/app.module.ts
// ...

import { FormsModule } from '@angular/forms';

@NgModule({
  // ...
  
  imports: [
    BrowserModule,
    FormsModule
  ],
  
  // ...
})
export class AppModule { }
</code></pre>
<p>The setup is ready, and you can run your web application to see it in action.
By default, it should be displaying the <code>test</code> value within each dynamically created component.</p>
<p>Try typing some text in the <code>context</code> input to see all of those components' titles change on the fly.</p>
<p><img src="images/dynamic-content-05.png" alt="" /></p>
<h3 id="typical-use-cases-1"><a class="header" href="#typical-use-cases-1">Typical use cases</a></h3>
<p>Dynamic forms and form persistence is the best example of where you might need the features we tried above.</p>
<p>If you need displaying a form or a complex component based on some definition file (JSON, XML, or other),
you may end up creating a dynamic component that builds final content based on the schema and/or persisted state,
and a form component built from multiple dynamic content containers.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/dynamic-content">angular/components/dynamic-content</a></strong> folder.</p>
</blockquote>
<h2 id="runtime-compilation"><a class="header" href="#runtime-compilation">Runtime Compilation</a></h2>
<p>For some advanced scenarios, you might want to take full control over Angular component and template compilation.</p>
<p>In this part, we are going to implement the following features:</p>
<ul>
<li>allow a user to define the component template</li>
<li>compile a <code>Component</code> on the fly  with user defined template and the underlying class</li>
<li>compile a <code>NgModule</code> on the fly with the component created in the previous step</li>
<li>display newly created component on the page</li>
</ul>
<p>Let's start by generating a separate scaffold for the component by utilizing the Angular CLI tools:</p>
<pre><code class="language-sh">ng g component runtime-content
</code></pre>
<p>You can take initial implementation from the <code>DynamicContentComponent</code> we created in previous chapters.</p>
<p>The component template needs a predefined injection point:</p>
<pre><code class="language-html">&lt;!-- src/app/runtime-content/runtime-content.component.html --&gt;

&lt;div&gt;
  &lt;div #container&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Also, we map <code>#container</code> element to the underlying <code>container</code> property of the component class.</p>
<pre><code class="language-ts">// src/app/runtime-content/runtime-content.component.ts

import { /*...,*/ ViewChild, ViewContainerRef } from '@angular/core';

@Component({/*...*/})
export class RuntimeContentComponent {

  @ViewChild('container', { read: ViewContainerRef })
  container: ViewContainerRef;

}
</code></pre>
<p>The main idea behind the new component we introduce is to allow a user to define HTML template on the fly.
So let's add a basic UI for editing:</p>
<pre><code class="language-html">&lt;!-- src/app/runtime-content/runtime-content.component.html --&gt;

&lt;div&gt;
  &lt;h3&gt;Template&lt;/h3&gt;
  &lt;div&gt;
    &lt;textarea rows=&quot;5&quot; [(ngModel)]=&quot;template&quot;&gt;&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;button (click)=&quot;compileTemplate()&quot;&gt;Compile&lt;/button&gt;

  &lt;h3&gt;Output&lt;/h3&gt;
  &lt;div #container&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Note that to use <code>ngModel</code> directive you must import a <code>FormsModule</code> into your main application module.
You should have it already configured from the previous part of the chapter where we created the <code>DynamicContent</code> component.</p>
<p>Set the default template value to something the user can compile without typing beforehand.
That should help us testing the flow as well:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class RuntimeContentComponent {
  // ...

  template = '&lt;div&gt;\nHello, {{name}}\n&lt;/div&gt;';

}
</code></pre>
<p>When the main page gets rendered it should look similar to the following:</p>
<p><img src="images/dynamic-content-06.png" alt="" /></p>
<p>Now the most important part of the component implementation, the runtime compilation:</p>
<pre><code class="language-ts">// src/app/runtime-content/runtime-content.component.ts

import { /*...,*/ Compiler, ComponentFactory, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({/*...*/})
export class RuntimeContentComponent {
  // ...

  private createComponentFactorySync(
    compiler: Compiler,
    metadata: Component,
    componentClass: any
  ): ComponentFactory&lt;any&gt; {

    const cmpClass = componentClass || class RuntimeComponent {
      name = 'Denys'
    };
    const decoratedCmp = Component(metadata)(cmpClass);

    @NgModule({
      imports: [CommonModule],
      declarations: [decoratedCmp] }
    )
    class RuntimeComponentModule { }

    const module = compiler.compileModuleAndAllComponentsSync(
      RuntimeComponentModule
    );

    return module.componentFactories.find(
      f =&gt; f.componentType === decoratedCmp
    );
  }

}
</code></pre>
<p>The code above takes custom metadata and optionally a component class reference via the <code>componentClass</code> parameter.</p>
<p>If you do not provide the class as part of the <code>createComponentFactorySync</code> call,
the fallback <code>RuntimeComponent</code> one gets used instead.</p>
<p>The fallback class also has a <code>name</code> property predefined.
That is what we are going to use for testing.</p>
<pre><code class="language-ts">const cmpClass = componentClass || class RuntimeComponent {
    name = 'Denys'
};
</code></pre>
<p>The resulting component also gets decorated with the metadata we provide:</p>
<pre><code class="language-ts">const decoratedCmp = Component(metadata)(cmpClass);
</code></pre>
<p>Next, a component gets created with the predefined <code>CommonModule</code> import.</p>
<p>You may extend the list if you want to support more functionality.
We also put our component as part of the module's <code>declarations</code> section as per Angular requirements.</p>
<p>Finally, the function uses Angular <code>Compiler</code> service to compile the module and all included components.
Compiled module provides access to the underlying component factories, and this is exactly the feature we need.</p>
<p>For the last step, we need to wire the <code>Compile</code> button with the following method:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class RuntimeContentComponent {
  // ...

  compileTemplate() {

    const metadata = {
      selector: `runtime-component-sample`,
      template: this.template
    };

    const factory = this.createComponentFactorySync(
      this.compiler,
      metadata,
      null
    );

    if (this.componentRef) {
      this.componentRef.destroy();
      this.componentRef = null;
    }
    
    this.componentRef = this.container.createComponent(factory);

  }
}
</code></pre>
<p>Every time the user clicks the <code>Compile</code> button our <code>RuntimeContentComponent</code> component takes the template value,
compiles it to a new component backed by the <code>RuntimeComponent</code> class (with the predefined <code>name</code> property), and renders:</p>
<p><img src="images/dynamic-content-07.png" alt="" /></p>
<p>To fully test the flow in action now change the default HTML template value and provide some custom content,
for example changing the colour style of the root <code>div</code> element to <code>blue</code>.
Modify the text content as well.</p>
<p>Click <code>Compile</code> button once again, and you should see the following result now:</p>
<p><img src="images/dynamic-content-08.png" alt="" /></p>
<h3 id="binding-events"><a class="header" href="#binding-events">Binding events</a></h3>
<p>Your component users are not limited to user property bindings.
The template supports event binding as well.</p>
<p>All event handlers have to be defined in the underlying class or be present
in the <code>RuntimeComponent</code> class we use as a fallback value.</p>
<p>To see events in action let's modify the fallback class and add the <code>onClick</code> method like in the following example:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class RuntimeContentComponent {
  // ...

  private createComponentFactorySync(/*...*/): ComponentFactory&lt;any&gt; {

    const cmpClass = componentClass || class RuntimeComponent {
      name = 'Denys';

      onClick() {
        alert('Clicked');
      }
    };

      // ...
  }
}
</code></pre>
<p>Now you can wire the click events in the template with the <code>onClick</code> method like in the next picture:</p>
<p><img src="images/dynamic-content-09.png" alt="" /></p>
<p>If you press the <code>Compile</code> button once again and then click the <code>div</code> element you should see the browser alert dialogue:</p>
<p><img src="images/dynamic-content-10.png" alt="" /></p>
<h3 id="typical-use-cases-2"><a class="header" href="#typical-use-cases-2">Typical use cases</a></h3>
<p>The best scenario for this feature is when you want to store component templates somewhere in the external storage,
and then build components on the fly, similar to how it gets performed in various RAD environments,
online layout builders, and other design tools.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/dynamic-content">angular/components/dynamic-content</a></strong> folder.</p>
</blockquote>
<h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<blockquote>
<p>Warning: this chapter was written using the earlier versions of Angular and needs review.</p>
</blockquote>
<p>Plugins are used to allow third-party developers extend your application
by utilizing the redistributable extensions that provide new features for the application
without recompiling its code.</p>
<p>In this section, we are going to use multiple ways to extend your application,
starting from the string-based configurations to build and compose components at runtime,
and finishing with the complete drop-in plugins you can put into the folder
to add new features to the running application.</p>
<h2 id="preparing-new-project"><a class="header" href="#preparing-new-project">Preparing new project</a></h2>
<p>Use the following Angular CLI command to generate a project with initial Routing support.</p>
<pre><code class="language-sh">ng new plugins --routing
</code></pre>
<p>It is essential to have Routing enabled as later in this section
we are also going to see how to create new routes dynamically at runtime,
and how a plugin can contribute new application routes with external content presented to a user.</p>
<p>Edit the main application component template and replace the HTML markup
that Angular CLI generates by default with the following one:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h1&gt;Plugins&lt;/h1&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<p>That is pretty much all to get started with extensibility.
You can test the project by running the <code>ng start --open</code> command,
to see that everything compiles and runs fine.
After that, proceed to the next section below.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/plugins">angular/plugins</a></strong> folder.</p>
</blockquote>
<h2 id="building-components-based-on-string-names"><a class="header" href="#building-components-based-on-string-names">Building components based on string names</a></h2>
<p>The first thing we are going to start with is related to creating components
based on their string names, either types or aliases.</p>
<p>This feature allows to you have configurable configuration files or custom layout definitions
that instruct your application what components to use for the particular scenarios.</p>
<p>A good example is a dynamic sidebar that can contain various components
or mini-widgets based on the configuration file.
Users or developers can change the settings to display only individual components,
like a &quot;weather widget&quot; or &quot;notification panel&quot;, can provide a different order of rendering,
and many other options.</p>
<p>The example above is not a fully-fledged plugin approach,
as our application still &quot;knows&quot; about all possible component types,
and all components and templates get compiled and bundled as part of the application.
However, we are taking that scenario as a simplified case to see how to use the Angular compiler at runtime.
That should give us a base experience for more advanced scenarios
that we are going to implement later in this chapter.</p>
<p>I strongly recommend creating a separate module that contains all the configurable components that you plan to create at runtime.
That should significantly simplify future maintenance and discovery of such components,
and you are going to see that shortly in practice.</p>
<p>Let's use Angular CLI once again to generate a new flat module and call it <code>plugins</code>:</p>
<pre><code class="language-sh">ng g module plugins --flat --module=app
</code></pre>
<p>Note the <code>--module=app</code> switch we are using in this case.
It instructs Angular CLI to also include our newly generated module into the main application module.</p>
<p>The <code>--flat</code> switch forces the CLI to generate module file in the application source folder,
without creating a separate subfolder as it does for components, directives and other Angular entities.</p>
<p>The console output in your case should look similar to the next example:</p>
<pre><code class="language-text">create src/app/plugins.module.ts (191 bytes)
update src/app/app.module.ts (465 bytes)
</code></pre>
<p>While we are at the command line, let's also create two components <code>page1</code> and <code>page2</code>.
These are the components we would like to create dynamically.
Moreover, you can save some time by using the <code>--module</code> switch
to include both components into the &quot;plugins&quot; module like in the code below:</p>
<pre><code class="language-sh">ng g component page1 --module=plugins
ng g component page2 --module=plugins
</code></pre>
<p>Now, feel free to inspect what you have as a result in the <code>plugins</code> module
that should reside in the <code>src/app</code> folder and contain references to both
<code>Page1Component</code> and <code>Page2Component</code> components.</p>
<p>The Angular CLI also imports the most frequently used <code>CommonModule</code> module for you:</p>
<pre><code class="language-ts">// src/app/plugins.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Page1Component } from './page1/page1.component';
import { Page2Component } from './page2/page2.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [Page1Component, Page2Component]
})
export class PluginsModule { }
</code></pre>
<p>Both <code>page</code> component classes should be almost identical and look similar to the following:</p>
<pre><code class="language-ts">// src/app/page1/page1.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-page1',
  templateUrl: './page1.component.html',
  styleUrls: ['./page1.component.css']
})
export class Page1Component implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}
</code></pre>
<p>The Angular CLI provides dummy HTML templates in the form of <code>&lt;component-name&gt; works!</code> for every component it generates.
That saves much time when you are preparing project structure or have a quick prototyping phase.</p>
<p>As we focus on the architecture and dynamic compilation, it is not very important what templates component have.
Let's leave the default values for now, and you can revisit that later.</p>
<p>Next, we need to create a couple of buttons to trigger component creation,
and a placeholder to insert the newly compiled content.</p>
<p>Update the main application component template like in the example below.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;h1&gt;Plugins&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;button (click)=&quot;createView('app-page1')&quot;&gt;page 1&lt;/button&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;button (click)=&quot;createView('app-page2')&quot;&gt;page 2&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div #content&gt;&lt;/div&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<p>Pay attention to the empty <code>div</code> element: <code>&lt;div #content&gt;&lt;/div&gt;</code>.
That is the place we are going put our dynamic components.</p>
<p>You can put this element to any other places, as long as it has the <code>content</code> Angular reference name,
the component controller is going to find it.</p>
<p>Now, if you run the application, the main page should look like in the next picture:</p>
<p><img src="images/ng-plugins-01.png" alt="List of plugins" /></p>
<p>We also need to finish the component controller preparation.
The class should get the reference to the <code>content</code> placeholder and have the <code>createView</code> handler for the buttons:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Component, Compiler, ViewChild, ViewContainerRef } from '@angular/core';
import { PluginsModule } from './plugins.module';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  @ViewChild('content', { read: ViewContainerRef })
  content: ViewContainerRef;

  constructor(private compiler: Compiler) {
  }

  createView(name: string) {
  }
}
</code></pre>
<p>Note that we also import the <code>PluginsModule</code>, as it contains all the components
we would like to find and create according to our initial scenario.</p>
<p>We inject the instance of the <code>Compiler</code> class into the component constructor
and use it to compile the <code>PluginsModule</code> on the fly.
The private <code>module</code> variable is going to hold the resulting instance
so that we do not compile the module more times than it is needed.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Component, Compiler, ViewChild, ViewContainerRef } from '@angular/core';
import { PluginsModule } from './plugins.module';

@Component({/*...*/})
export class AppComponent {

  @ViewChild('content', { read: ViewContainerRef })
  content: ViewContainerRef;

  private module;

  constructor(private compiler: Compiler) {
    this.module = this.compiler.compileModuleAndAllComponentsSync(
      PluginsModule
    );
  }

  createView(name: string) {
    const factory = this.module.componentFactories.find(
      f =&gt; f.selector === name
    );

    this.content.clear();
    this.content.createComponent(factory);
  }
}
</code></pre>
<p>As you can see above, as long as we have the compiled module instance,
we can perform searches to find a component factory based on specific metadata.
In the particular case, we are interested in the selector names.</p>
<p>As soon as factory got found, we can clear the <code>content</code> placeholder,
and create a new instance of the component in that place.</p>
<p>Run the application and click the first button <code>page 1</code> on the main page.
You should see the <code>page1 works!</code> label immediately appear at the bottom of the page.</p>
<p><img src="images/ng-plugins-02.png" alt="Plugin 1" /></p>
<p>Now click the second button, and this time the placeholder content
is replaced with the <code>page2 works!</code> text that comes with the <code>Page2Component</code>
instance our application component creates on the fly.</p>
<p><img src="images/ng-plugins-03.png" alt="Plugin 2" /></p>
<p>Congratulations on having the first step complete.</p>
<p>You are now able to take a string, map it to the component selector,
and build the corresponding component at runtime.</p>
<h3 id="loading-configuration-from-external-sources"><a class="header" href="#loading-configuration-from-external-sources">Loading configuration from external sources</a></h3>
<p>The whole idea of string to component type mapping usually arises
when the exact values are coming from the external sources, like configuration files.
Otherwise, you could just declare the needed component tags in the HTML template without any compilation.</p>
<p>As we have started this chapter with the example of the configurable Sidebar component,
let's go ahead and introduce a base implementation that takes external
<code>plugins.config.json</code> file as a configuration, and builds a set of components.</p>
<p>Below is our configuration file that is going to reside in the <code>src/assets</code> folder.
Upon startup, the Angular server automatically exposes this folder to the application access
and also copies its content to the output directory during production builds.</p>
<p><strong>src/assets/plugins.config.json</strong>:</p>
<pre><code class="language-json">{
  &quot;sidebar&quot;: {
    &quot;components&quot;: [
      &quot;app-page1&quot;,
      &quot;app-page2&quot;
    ]
  }
}
</code></pre>
<p>So we got the <code>sidebar</code> with two components <code>app-page1</code> and <code>app-page2</code> defined by default.
Let's now generate the corresponding component by utilizing the following command:</p>
<pre><code class="language-sh">ng g component sidebar --module=app
</code></pre>
<p>As we now have more than one module, we need to tell Angular CLI where to put the resulting component.
In our case, it is <code>app</code> that corresponds to the <code>app.module.ts</code> file.</p>
<p>In the main application template, append the <code>Configurable Sidebar</code> header element
together with the newly introduced <code>app-sidebar</code> tag:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;h1&gt;Configurable Sidebar&lt;/h1&gt;
&lt;app-sidebar&gt;&lt;/app-sidebar&gt;
</code></pre>
<p>You also need to import the <code>HttpClientModule</code> to allow your application components
and services make Http calls with the help of the <code>HttpClient</code> instance.</p>
<pre><code class="language-ts">// src/app/app.module.ts
//...

import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    /*...,*/
    
    SidebarComponent
  ],
  imports: [
    /*...,*/
    
    HttpClientModule
  ],
  entryComponents: [/*...*/],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>Next, edit the <code>SidebarComponent</code> template, and update the default auto-generated content with the following snippet:</p>
<pre><code class="language-html">&lt;!-- src/app/sidebar/sidebar.component.html --&gt;

&lt;p&gt;
  Sidebar
&lt;/p&gt;

&lt;div #content&gt;&lt;/div&gt;
</code></pre>
<p>Similar to previous examples, we have the placeholder <code>div</code> element that we reference as <code>content</code>,
and we compile the <code>PluginsModule</code> module to get access to all its factories at the runtime:</p>
<pre><code class="language-ts">// src/app/sidebar/sidebar.component.ts

import {
  /*...,*/
  ViewChild, ViewContainerRef, AfterViewInit, Compiler
} from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { PluginsModule } from '../plugins.module';

@Component({/*...*/})
export class SidebarComponent implements AfterViewInit {

  @ViewChild('content', { read: ViewContainerRef })
  content: ViewContainerRef;

  private module;

  constructor(private http: HttpClient,
              private compiler: Compiler) {
    this.module = compiler.compileModuleAndAllComponentsSync(
      PluginsModule
    );
  }

  ngAfterViewInit() {
  }

}
</code></pre>
<p>We use the <code>ngAfterViewInit</code> lifecycle hook as we need access to the <code>content</code> placeholder.
You can also mark the handler as <code>async</code> to get the benefits of the <code>async / await</code> support that Typescript provides:</p>
<pre><code class="language-ts">// src/app/sidebar/sidebar.component.ts

export class SidebarComponent implements AfterViewInit {
    /*...*/

    async ngAfterViewInit() {
        const url = '/assets/plugins.config.json';
        const config = await this.http.get(url).toPromise();

        console.log(config);
    }
}
</code></pre>
<blockquote>
<p><strong>Optimization</strong></p>
<p>Typically you should be aiming to have a separate application service to deal with HTTP and configuration loading.</p>
<p>In that case, you do not repeat the same calls in every component,
get a better separation of concerns and improved unit testing support.</p>
</blockquote>
<p>If you now switch to the browser tab with your application and run the developer tools,
the console output should be similar to the next one:</p>
<p><img src="images/ng-plugins-06.png" alt="Configuration file" /></p>
<p>I strongly recommend introducing a separate interface that describes the content of the configuration file.
In the long run, it is going to help you with type checks, addresses typos and errors at early stages.</p>
<p>For the sake of simplicity, let's create an interface called <code>AppConfig</code> in the same <code>sidebar.component.ts</code> file.
You can later extract it to a separate file if there's more than one place to use it.</p>
<pre><code class="language-ts">interface AppConfig {

  sidebar: {
    components: string[]
  };

}
</code></pre>
<p>Now you can use this interface with <code>HttpClient</code> like this:</p>
<pre><code class="language-ts">export class SidebarComponent implements AfterViewInit {
    // ...

    async ngAfterViewInit() {
        const url = '/assets/plugins.config.json';
        const config = await this.http.get&lt;AppConfig&gt;(url).toPromise();

        console.log(config);
    }
}
</code></pre>
<p>As a bonus, you are going to get automatic completion for your configuration files when working with typed variables:</p>
<p><img src="images/ng-plugins-07.png" alt="Automatic completion in VS Code" /></p>
<p>We have already covered how to search for the component factories using selector values;
this can be easily used now with the external configuration to build multiple components
and inject them into the placeholder in the specific order:</p>
<pre><code class="language-ts">export class SidebarComponent implements AfterViewInit {
    // ...

    async ngAfterViewInit() {
        const url = '/assets/plugins.config.json';
        const config = await this.http.get&lt;AppConfig&gt;(url).toPromise();

        this.createSidebarComponents(config.sidebar.components);
    }

    private createSidebarComponents(selectors: string[]) {
        this.content.clear();

        for (let i = 0; i &lt; selectors.length; i++) {
            const factory = this.module.componentFactories.find(
                f =&gt; f.selector === selectors[i]
            );
            this.content.createComponent(factory, i);
        }
    }
}
</code></pre>
<p>The <code>ViewContainerRef.createComponent</code> method handles the correct positioning of all generated instances.
It accepts the exact index of the entry as the second parameter.</p>
<p>Run or reload the project and you are going to see the following content on the main page:</p>
<p><img src="images/ng-plugins-08.png" alt="Sidebar with Components" /></p>
<p>Let's try to test the configuration is indeed dynamic.
Edit the JSON file and change the order of the components like in the following example:</p>
<pre><code class="language-json">{
  &quot;sidebar&quot;: {
    &quot;components&quot;: [
      &quot;app-page2&quot;,
      &quot;app-page1&quot;
    ]
  }
}
</code></pre>
<p>Next, reload the application page or wait till the Angular CLI web server automatically reloads.
You should now see components created in the order we configured:</p>
<p><img src="images/ng-plugins-09.png" alt="Different order in config" /></p>
<p>That means you are now ready to build composite components driven by the external configuration.
With the approach above, you can quickly create applications that change the layout without rebuilding and re-deploying new version to the server.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/plugins">angular/plugins</a></strong> folder.</p>
</blockquote>
<h2 id="dynamically-changing-application-routes"><a class="header" href="#dynamically-changing-application-routes">Dynamically changing application routes</a></h2>
<p>If you are building a scalable web application, then you are most probably
already using routing feature and application Router that Angular provides.</p>
<p>Besides the navigation patterns, Angular Router provides a way to partition your application into smaller chunks,
load them on demand using Lazy Loading feature. We are going to dwell on Lazy Loading in the separate chapter,
and meanwhile, let's see how you can extend the router on the fly, and inject new,
or modify existing routes in the running application.</p>
<p>If you remember, at the beginning of the chapter, we have enabled the routing support via the <code>--routing</code> switch.
With that switch, Angular CLI automatically generates a separate <code>AppRoutingModule</code> module file
with the necessary scaffold, stored in the <code>app-routing.module.ts</code> file.</p>
<p>Let's generate a couple of components to use for navigation. We are going to call them <code>Home</code> and <code>About</code>:</p>
<pre><code class="language-sh">ng g component home --module=app
ng g component about --module=app
</code></pre>
<p>Now edit the <code>app-routing.module.ts</code> file and introduce new routes backed by the components we have just generated.
The <code>about</code> route corresponds to the <code>/about</code> URL and displays the <code>AboutComponent</code> component.</p>
<p>By default, when the application starts, it is going to render the <code>HomeComponent</code>.</p>
<pre><code class="language-ts">// src/app/app-routing.module.ts

import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

const routes: Routes = [
  {
    path: '',
    component: HomeComponent
  },
  {
    path: 'about',
    component: AboutComponent
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
</code></pre>
<p>Next, we create the links on the home page to allow the users navigate to the corresponding pages.
Find the <code>router-outlet</code> tag on the main application template, and replace it with the following snippet:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;h1&gt;Routes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
      &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<p>Start the application, and you should see two links together with the label <code>home works!</code> underneath.
That is our default <code>Home</code> component already loaded in the router outlet area.</p>
<p><img src="images/ng-plugins-04.png" alt="Basic routes" /></p>
<p>Click the <code>About</code> link to see the <code>AboutComponent</code>, that proves the router is up and running,
and ready for our further customizations.</p>
<p>For the next step, we need one more component that we are going to create dynamically at runtime.
Let's imagine that we have a configuration switch or settings that allows us to enable the <code>Settings</code> feature for our application.</p>
<p>Use Angular CLI to create a new <code>SettingsComponent</code> and automatically declare it within the <code>App</code> module:</p>
<pre><code class="language-sh">ng g component settings --module=app
</code></pre>
<p>Note that <code>Settings</code> component is part of the application, but it gets created dynamically.</p>
<p>According to Angular rules we need to register in the module's <code>entryComponents</code> section
all the components that we are going to create dynamically by using their factories.</p>
<p>Update the main application module according to the example of the code below:</p>
<pre><code class="language-ts">// src/app/app.module.ts
// ...

import { SettingsComponent } from './settings/settings.component';

@NgModule({
  declarations: [
    /*...,*/
    SettingsComponent
  ],
  imports: [ /*...*/ ],
  entryComponents: [
    SettingsComponent
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p>We also need a way to render and test all dynamic routes.</p>
<p>Let's create the collection variable to hold the information we need to create the list of links on the main page,
similar to the <code>Home</code> and <code>About</code> that we have created earlier.</p>
<p>Our main component class also needs importing and injecting the Router instance.</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...

import { Router } from '@angular/router';

@Component({/*...*/})
export class AppComponent {

  // ...

  links: { text: string, path: string }[] = [];

  constructor(/*...,*/ private router: Router) {
    // ...
  }

  // ...
}
</code></pre>
<p>To display a link, we need a title and a route path value.</p>
<p>For a minimal Router entry, we also need the type of the component to associate with the given route.
That means we can create the following method to register a new route and also fill the <code>links</code> collection:</p>
<pre><code class="language-ts">// src/app/app.component.ts

createRoute(text: string, path: string, componentType: any) {
    this.router.config.unshift({
        path: path,
        component: componentType
    });

    this.links.push({ text, path });
}
</code></pre>
<p>The main point of interest for us, in this case, is the <code>router.config</code> property
that holds a collection of all registered routes available to the application and Router.
The &quot;createRoute&quot; method inserts a new record containing a path and the component Type.</p>
<p>Why is it essential to use <code>unshift</code> instead of the <code>push</code>  method for the routes array?
Very often the last route in the collection is a <code>catch-all</code> fallback path
that handles missing pages and redirects to some error or <code>page not found</code> component,
like in the following example:</p>
<pre><code class="language-ts">const appRoutes: Routes = [
  {
    path: '',
    component: HomeComponent
  },
  { path: '**', component: PageNotFoundComponent }
];
</code></pre>
<p>By pushing new content to the routes collection we risk adding it after the <code>catch-all</code> path,
and so the routes are not going to be available at runtime.</p>
<p>That is why we <code>prepend</code> new routes by using <code>Array.prototype.unshift</code>
rather than appending them with <code>Array.prototype.push</code> function.</p>
<p>Let's try the route generator out with the SettingsComponent we have recently created.</p>
<p>Update the main application component class with the necessary imports,
and call the <code>createRoute</code> method in the class constructor
to prepend the <code>Settings</code> route pointing to the <code>/settings</code> URL like in the next snippet:</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...

import { SettingsComponent } from './settings/settings.component';

@Component({/*...*/})
export class AppComponent {
  // ...

  constructor(private compiler: Compiler, private router: Router) {
    // ...
    this.createRoute('Settings', 'settings', SettingsComponent);
  }

  createView(name: string) {
    // ...
  }

  createRoute(text: string, path: string, componentType: any) {
    this.router.config.unshift({
      path: path,
      component: componentType
    });

    this.links.push({ text, path });
  }
}
</code></pre>
<p>Finally, we need to create a list of new routes on the main page.</p>
<p>You should already have an unordered list with the <code>Home</code> and <code>About</code> links,
let's update it with the dynamic portion now:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;h1&gt;Routes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;

  &lt;li *ngFor=&quot;let link of links&quot;&gt;
    &lt;a [routerLink]=&quot;link.path&quot;&gt;
      {{ link.text }}
    &lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>
<p>As soon as you reload the page, you are going to see three links in the <code>Routes</code> section:
<code>Home</code>, <code>About</code> and the newly introduced <code>Settings</code>.</p>
<p>Click on the <code>Settings</code> one, and you are going to see the <code>setting works!</code> label in the router outlet area.
That means your application successfully renders the content you provide at runtime, congratulations!</p>
<p><img src="images/ng-plugins-05.png" alt="Dynamic route" /></p>
<p>We have walked through a simplified scenario for route creation.</p>
<p>As you can now imagine, that approach can be used in more sophisticated cases,
when you store route names, paths and component aliases in the external configuration files,
and load them on demand together with new route generation, as we did earlier in this chapter.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/plugins">angular/plugins</a></strong> folder.</p>
</blockquote>
<h2 id="external-plugins"><a class="header" href="#external-plugins">External plugins</a></h2>
<p>We have finally approached the most advanced and the most valuable area -
plugins that are loaded by the application at runtime from external sources,
and provide new features based on specific extension points.</p>
<p>For generic plugin capabilities we need to have application support at least for the following items:</p>
<ul>
<li>defining an extension point in the application</li>
<li>essential plugin registration and management APIs</li>
<li>loading external modules at runtime</li>
<li>executing or instantiating external components</li>
</ul>
<p>Traditionally, application or framework developers provide a set of extension points
that third-party developers can use to build plugins or extensions.
Let's take the Routing example we used across this chapter as a perfect scenario for extensibility.</p>
<p>We are going to enable other developers to build extra components and register new routes in our application.
Ultimately it should be possible to drop the JavaScript file in some specialized <code>modules</code> folder
and register the module in the application configuration file.
The application should not &quot;know&quot; about loaded types, and the whole plugin integration should happen dynamically,
without recompiling the application or even restarting the web server.</p>
<h3 id="extension-decorator"><a class="header" href="#extension-decorator">Extension decorator</a></h3>
<p>It is essential to keep the plugin feature as simple as possible
so that your third-party developers do not study a new programming language
or the practices and patterns that are relevant only to your particular implementation.
The ES2016 <code>decorator</code> pattern might be the best choice, as Angular developers
are already familiar with decorators and annotations.</p>
<p>Let's imagine we have a unique <code>@Extension</code> decorator to mark all the components
we want the target application to discover and use.
We could also provide some extra metadata for such a decorator,
for example, public alias to use in the configuration files,
maybe an icon or even a list of dependencies on other plugins or modules.</p>
<p>For example, it can look like the following when applied to a class:</p>
<pre><code class="language-js">@Extension('my-extension')
class MyExtension {
  // ...
}
</code></pre>
<p>Decorators can be chained, so that means we can use them with Angular components like this as well:</p>
<pre><code class="language-ts">@Extension('my-button')
@Component({
  selector: 'my-button,
  templateUrl: 'my-button.html'
})
export class MyButtonComponent {
  // ...
}
</code></pre>
<p>As you can see, we need at least one project to hold the Extension and other APIs
that we share across all plugin implementations, let's call it <code>Plugins Core</code>.
It can also contain some management services, like <code>Plugin Manager</code>
to help the end application maintain plugins easily.</p>
<p>Finally, we are going to extend the main application to allow adding new routes and components via the configuration file.
For the current scenario, our simple extension point is a Router extension and new pages for the application,
but there can be many different extension points in the future.</p>
<p><img src="images/ng-plugins-19.png" alt="Simple dependency flow" /></p>
<h3 id="creating-a-plugins-core-library"><a class="header" href="#creating-a-plugins-core-library">Creating a Plugins Core library</a></h3>
<p>Create a separate <code>plugins-core</code> folder for the shared Extension APIs to use with all new plugins.
I am going to use the <a href="https://rollupjs.org/">Rollup.js</a> to build and bundle the code.
However, you can use any other means to create a redistributable Angular library.</p>
<p>You can refer to the <strong><a href="ch12-00-reusable-component-libraries.html">Reusable component libraries</a></strong> chapter for more details.</p>
<blockquote>
<p><strong>Rollup.js</strong></p>
<p>Rollup is a module bundler for JavaScript which compiles small pieces of code
into something larger and more complex, such as a library or application.</p>
<p>To get more information about Rollup, please refer to the official documentation:
<a href="https://rollupjs.org">https://rollupjs.org</a></p>
</blockquote>
<p>Note, however, that <code>Rollup</code> is not the only option for building redistributable libraries. You can also check the following alternatives:</p>
<ul>
<li><a href="http://spektrakel.de/ng-packagr">ng-packagr</a></li>
<li><a href="https://nrwl.io/nx">Nx extensions for Angular</a></li>
</ul>
<p>Create a new <code>package.json</code> file with the following content to configure dependencies for the new project:</p>
<p><strong>package.json</strong>:</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;plugins-core&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;main&quot;: &quot;dist/bundle.js&quot;,
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;scripts&quot;: {
      &quot;build&quot;: &quot;rimraf dist/bundle.js &amp;&amp; rollup -c&quot;
    },
    &quot;devDependencies&quot;: {
      &quot;babel-core&quot;: &quot;^6.26.0&quot;,
      &quot;babel-plugin-external-helpers&quot;: &quot;^6.22.0&quot;,
      &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,
      &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,
      &quot;rimraf&quot;: &quot;^2.6.2&quot;,
      &quot;rollup-plugin-babel&quot;: &quot;^3.0.3&quot;,
      &quot;rollup-plugin-json&quot;: &quot;^2.3.0&quot;,
      &quot;rollup-plugin-node-resolve&quot;: &quot;^3.0.2&quot;
    }
}
</code></pre>
<p>Note the <code>scripts</code> section and the &quot;build&quot; command.
You are going to need it later to produce the bundle to use with the main application.</p>
<p>Run the following command now to install all dependencies:</p>
<pre><code class="language-sh">npm install
</code></pre>
<p>The Rollup is using Babel libraries under the hood.
We need to provide the following configuration to enable support for decorators:</p>
<p><strong>.babelrc</strong>:</p>
<pre><code class="language-json">{
    &quot;presets&quot;: [
      [&quot;env&quot;, {
        &quot;modules&quot;: false
      }]
    ],
    &quot;plugins&quot;: [
      &quot;external-helpers&quot;,
      &quot;transform-decorators-legacy&quot;
    ]
}
</code></pre>
<p>The last project preparation step is the configuration file for the Rollup itself.
Use the following source code for the minimal working configuration that takes <code>src/main.js</code> file as an input,
and produces the <code>dist/bundle.js</code> file as the bundled output.</p>
<pre><code class="language-js">// rollup.config.js

import json from 'rollup-plugin-json';
import resolve from 'rollup-plugin-node-resolve';
import babel from 'rollup-plugin-babel';

export default {
    input: 'src/main.js',
    output: {
        file: 'dist/bundle.js',
        format: 'system'
    },
    plugins: [
        json(),
        resolve({
            // pass custom options to the resolve plugin
            customResolveOptions: {
                moduleDirectory: 'node_modules'
            }
        }),
        babel({
            exclude: 'node_modules/**' // only transpile our source code
        })
    ]
}
</code></pre>
<p>Finally, we are ready to start implementing our <code>Extension</code> decorator.
The code is pretty simple, given that decorators are JavaScript functions:</p>
<pre><code class="language-js">// src/extension.js

export function Extension(name, deps) {
    return (constructor) =&gt; {
        Extension.prototype.registry[name] = {
            ctor: constructor,
            deps: deps || []
        };
    };
}

Extension.prototype.registry = {};
</code></pre>
<p>As per our design, the <code>Extension</code> decorator is going to keep a registry of all the classes it has decorated.
That enables quick access to all the <code>registered</code> extensions at runtime
without extra initialization overhead for each decorated class or component.</p>
<p>Our decorator requires a public name of the decorated element, to use within application configurations.
We also reserve an optional array of dependencies that our plugin requires when loaded into the application.
Feel free to add more properties later on when your plugin architecture evolves.</p>
<p>While we are here, let's also provide a couple of utility functions to generate a list of providers.</p>
<p>One is <code>getProviders</code>, to be able using it within the Angular Injectors and modules.
Another one is <code>getExtensionType</code> to allow us quickly resolving extension type (or constructor) based on the public name.
You are going to see both of them in action shortly.</p>
<pre><code class="language-js">// src/extension.js
// ...

Extension.prototype.getProviders = function () {
    var registry = this.registry;
    return Object.keys(registry).map(function (key) {
        return {
            provide: key,
            useClass: registry[key].ctor,
            deps: registry[key].deps
        };
    });
};

Extension.prototype.getExtensionType = function (name) {
    return this.registry[name].ctor;
}
</code></pre>
<p>For the next step, we introduce a <code>PluginManager</code> class to provide a single place
for controlling and using our plugins at runtime.</p>
<p>Typically it is the end application that calls these methods when setting up the extension points
or resolving and compiling components coming from the plugin library.</p>
<pre><code class="language-js">// src/plugin-manager.js

import { Extension } from './extension';

export class PluginManager {

  getType(name) {
    return Extension.prototype.getExtensionType(name);
  }

  getProviders() {
    return Extension.prototype.getProviders();
  }

}
</code></pre>
<p>Finally, create the <code>main</code> library entry point and export the classes and functions we have created.</p>
<p>Note that we export the instance of the PluginManager as a singleton.
That is not mandatory but saves time for creating new instances at the application level,
especially when accessing plugins from multiple places and files in the code.</p>
<pre><code class="language-js">// src/main.js

import { PluginManager } from './plugin-manager';

export { Extension } from './extension';
export const pluginManager = new PluginManager();
</code></pre>
<p>That is pretty much all. You can now build the redistributable bundle with the <code>build</code> script:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>The console output should be similar to the following one:</p>
<pre><code class="language-text">src/main.js =&gt; dist/bundle.js...
created dist/bundle.js in 369ms
</code></pre>
<p>For real-life scenarios, you may probably want to publish your redistributable library to NPM,
so that developers can install it as part of the application and use as a third party addon.</p>
<p>For demonstration and quick testing purposes let's emulate the NPM deployment behavior
by running the <code>npm link</code> command in the root project folder:</p>
<pre><code class="language-sh">npm link
</code></pre>
<p>Now you can run <code>npm link plugins-core</code> in any of your local projects folders,
and emulate the process of installing from NPM.</p>
<p>The main benefit is that you can keep working on the library code, all applications
and libraries that link it are going to get updates automatically.</p>
<p>Once you are have finished with the development, you can, of course,
use the real publishing via <code>npm publish</code> commands, but this is out of our current scope.</p>
<p>You shall see the linking example later in this chapter.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/plugins-core">angular/plugins-core</a></strong> folder.</p>
</blockquote>
<h3 id="creating-an-example-plugin-library"><a class="header" href="#creating-an-example-plugin-library">Creating an example Plugin library</a></h3>
<p>We have created a shared Plugins Core library with the previous steps.
It is now time to build our first plugin library.</p>
<p>Create a separate <code>plugins-example</code> folder and place the following <code>package.json</code> file there:</p>
<p><strong>package.json</strong>:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;plugins-example&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;dist/bundle.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rimraf dist &amp;&amp; rollup -c&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;rimraf&quot;: &quot;^2.6.2&quot;,
    &quot;rollup-plugin-node-resolve&quot;: &quot;^3.0.2&quot;,
    &quot;rollup-plugin-typescript&quot;: &quot;^0.8.1&quot;,
    &quot;rollup-plugin-typescript2&quot;: &quot;^0.10.0&quot;,
    &quot;typescript&quot;: &quot;^2.6.2&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@angular/core&quot;: &quot;^5.2.2&quot;,
    &quot;rollup&quot;: &quot;^0.55.1&quot;
  }
}
</code></pre>
<p>As with the previous project, install the dependencies running the command below:</p>
<pre><code class="language-sh">npm install
</code></pre>
<p>Our project needs to depend on the <code>plugins-core</code> library.</p>
<p>Typically we should be adding it to the package file and installing with all other dependencies,
however for the sake of simplicity we are going to use &quot;npm link&quot; feature to provide a live link to the library.
That helps to work on both projects at the same time without publishing to NPM.</p>
<p>Run the following command in the project root to establish a link:</p>
<pre><code class="language-sh">npm link plugins-core
</code></pre>
<p>As we are going to create Angular components, we need to setup the TypeScript integration for the Rollup.
Put the following <code>tsconfig.json</code> file in the project root to enable basic support we need right now:</p>
<p><strong>tsconfig.json</strong>:</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;es5&quot;,
        &quot;module&quot;: &quot;system&quot;,
        &quot;lib&quot;: [&quot;es2017&quot;, &quot;dom&quot;],
        &quot;declaration&quot;: true,
        &quot;sourceMap&quot;: true,
        &quot;removeComments&quot;: true,
        &quot;moduleResolution&quot;: &quot;node&quot;,
        &quot;typeRoots&quot;: [ &quot;node_modules/@types&quot; ],
        &quot;experimentalDecorators&quot;: true,
        &quot;emitDecoratorMetadata&quot;: true
    }
}
</code></pre>
<blockquote>
<p><strong>TypeScript Configuration</strong></p>
<p>You can always generate a recommended configuration file by running the <code>tsc --init</code> command in any folder.</p>
<p>That requires, however, a TypeScript to be installed globally via <code>npm install -g typescript</code> command.</p>
</blockquote>
<p>Now finish the project scaffold setup by also adding the Rollup configuration file like below:</p>
<pre><code class="language-js">// rollup.config.js

import resolve from 'rollup-plugin-node-resolve';
import typescript from 'rollup-plugin-typescript2';

export default {
    input: 'src/main.ts',
    output: {
        file: 'dist/bundle.js',
        format: 'system'
    },
    plugins: [
        resolve({
            // pass custom options to the resolve plugin
            customResolveOptions: {
                moduleDirectory: 'node_modules'
            }
        }),
        typescript({
            typescript: require('typescript')
        })
    ],
    external: [
        'plugins-core',
        '@angular/core'
    ]
}
</code></pre>
<p>Please pay attention to the <code>external</code> section of the Rollup configuration.</p>
<p>It contains references to the libraries in your <code>package.json</code> that should never get bundled into the resulting output.
That means that every plugin library is not going to contain the full copy of the Angular or another version of the <code>plugins-core</code>.
Having such dependencies marked as <code>external</code>, however, requires the main application to import them alongside our plugins.</p>
<p>If your library depends on other Angular libraries, like <code>@angular/forms</code> or <code>@angular/http</code>,
include those in the <code>external</code> section too.</p>
<p>Let's now create the first plugin component marked with our <code>Extension</code> decorator.
It is going to be a dummy button element that we reference as <code>my-button</code> extension.</p>
<pre><code class="language-ts">// src/my-button/my-button.component.ts

import { Component, OnInit, NgModule } from '@angular/core';
import { Extension } from 'plugins-core';

@Extension('my-button', [])
@Component({
    selector: 'my-button',
    template: `&lt;button&gt;My Button&lt;/button&gt;`
})
export class MyButtonComponent implements OnInit {

    ngOnInit() {
        console.log('My Button Init');
    }

}
</code></pre>
<p>Create one more component with a label element and called <code>my-label</code>:</p>
<pre><code class="language-ts">// src/my-label/my-label.component.ts

import { Component, OnInit, NgModule } from '@angular/core';
import { Extension } from 'plugins-core';

@Extension('my-label', [])
@Component({
    selector: 'my-label',
    template: `&lt;h1&gt;My Label&lt;/h1&gt;`
})
export class MyLabelComponent implements OnInit {

    ngOnInit() {
        console.log('My Label Init');
    }

}
</code></pre>
<p>Both components also produce log messages to the browser console for testing purposes.
The only thing that is now left is to export both components in the <code>main</code> class.</p>
<pre><code class="language-ts">// src/main.ts

export { MyLabelComponent } from './my-label/my-label.component';
export { MyButtonComponent } from './my-button/my-button.component';
</code></pre>
<p>Now run the <code>build</code> script to create a redistributable bundle:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>Once the compilation completes, the console output should be as follows:</p>
<pre><code class="language-text">src/main.ts =&gt; dist/bundle.js...
created dist/bundle.js in 980ms
</code></pre>
<p>Finally, you should also create a link to this project to test the library
without publishing to NPM every time you make changes to the project.</p>
<pre><code class="language-sh">npm link
</code></pre>
<p>We now got the <code>plugins-core</code> and <code>plugins-example</code> libraries compiled
and ready for use with an Angular application as external plugins.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/plugins-example">angular/plugins-example</a></strong> folder.</p>
</blockquote>
<h3 id="extra-libraries-and-dependencies"><a class="header" href="#extra-libraries-and-dependencies">Extra libraries and dependencies</a></h3>
<p>Your component library does not restrict you to a particular set of dependencies.
You can add many additional libraries to the <code>rollup</code> configuration,
and plugin components can also have own <code>providers</code> sections to get additional services imported.</p>
<p>For example, you can add a FormBuilder integration using the following steps.</p>
<p>First, update the <code>rollup.config.js</code> file and add <code>@angular/forms</code> to the exclusion list.
That prevents entire forms library from getting bundled into your library output.</p>
<pre><code class="language-js">export default {
  // ...,

  external: [
      'plugins-core',
      '@angular/core',
      '@angular/forms'
  ]
}
</code></pre>
<p>Next, import the Forms related types, and update your component decorator to include the <code>FormBuilder</code> provider:</p>
<pre><code class="language-ts">// src/my-label/my-label.component.ts

import { Component, OnInit, NgModule } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Extension } from 'plugins-core';

@Extension('my-label', [])
@Component({
    selector: 'my-label',
    template: `&lt;h1&gt;My Label&lt;/h1&gt;`,
    providers: [ FormBuilder ]
})
export class MyLabelComponent implements OnInit {

    ngOnInit() {
        console.log('My Label Init');
    }

}
</code></pre>
<p>Once you have component configuration set, you can import the <code>FormBuilder</code> and use its APIs from within the plugin component.</p>
<pre><code class="language-ts">// src/my-label/my-label.component.ts

export class MyLabelComponent implements OnInit {

    form: FormGroup;

    constructor(private fb: FormBuilder) {
        this.form = fb.group({
            name: fb.group({
                first: ['Nancy', Validators.minLength(2)],
                last: 'Drew'
            }),
            email: ''
        });
    }

    ngOnInit() {
        console.log('My Label Init');
        console.log('FB:', this.fb);
        console.log('Form:', this.form);
    }

}
</code></pre>
<p>Finally, you need updating the <code>SystemJS</code> settings of the main application to include extra libraries to use for plugins.</p>
<p>In the example below I am adding <code>@angular/common</code>, <code>@angular/forms</code> and <code>@angular/platform-browser</code> to the list.
Those libraries will get available for all the loaded plugins.</p>
<p><strong>src/assets/plugins.config.json</strong>:</p>
<pre><code class="language-json">{
  ...,

  &quot;system&quot;: {
    &quot;baseURL&quot;: &quot;/assets/modules&quot;,
    &quot;paths&quot;: {
      &quot;npm:&quot;: &quot;https://unpkg.com/&quot;
    },
    &quot;map&quot;: {
      &quot;@angular/core&quot;: &quot;npm:@angular/core/bundles/core.umd.js&quot;,
      &quot;@angular/common&quot;: &quot;npm:@angular/common/bundles/common.umd.js&quot;,
      &quot;@angular/forms&quot;: &quot;npm:@angular/forms/bundles/forms.umd.js&quot;,
      &quot;@angular/platform-browser&quot;: &quot;npm:@angular/platform-browser/bundles/platform-browser.umd.js&quot;,
      &quot;rxjs&quot;: &quot;npm:rxjs&quot;,

      &quot;plugins-core&quot;: &quot;/modules/plugins-core/bundle.js&quot;,
      &quot;plugins-example&quot;: &quot;/modules/plugins-example/bundle.js&quot;
    }
  },
}
</code></pre>
<p>You might need to import <code>FormsModule</code> and <code>ReactiveFormsModule</code> also to the root application module.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { FormsModule, ReactiveFormsModule } from '@angular/forms';

@NgModule({
  // ...,

  imports: [
    BrowserModule,
    HttpModule,
    FormsModule, ReactiveFormsModule
  ],

  // ...
})
export class AppModule { }
</code></pre>
<h3 id="providing-dependencies-for-your-plugins"><a class="header" href="#providing-dependencies-for-your-plugins">Providing dependencies for your plugins</a></h3>
<p>As I have mentioned earlier, you have full control over what the dynamic module contains.
This opens the door to at least two great scenarios for injecting external content into your plugins at run-time.</p>
<p>We have already touched the first one.
That is the <code>imports</code> section and extra libs you can provide for every plugin you construct.
That can be Forms modules, Material modules, you custom or third-party libraries.</p>
<p>Every time we create an instance of the plugin component of the <code>componentType</code>,
the component templates can use form fields, and material buttons provided with the <code>MatButtonModule</code> module.</p>
<pre><code class="language-ts">const RuntimeModule = NgModule({
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    MatButtonModule
  ],
  declarations: [
    componentType
  ]
})(class {})
</code></pre>
<p>Another way to inject data into the plugin components is by utilizing &quot;providers&quot; section.
You can create and pre-configure the services prior to exposing them to components and other services
that you resolve and create on the fly.</p>
<pre><code class="language-ts">const RuntimeModule = NgModule({
  declarations: [
    componentType
  ],
  providers: [
    { provide: Injector, useValue: this.injector },
    { provide: FormBuilder, useValue: this.fb },
    { ... }
  ]
})(class {})
</code></pre>
<p>That is a powerful feature that allows you having complete control
over the dependency resolution process for external components.</p>
<h3 id="loading-plugins-into-the-application"><a class="header" href="#loading-plugins-into-the-application">Loading plugins into the Application</a></h3>
<p>Switch to the <code>plugins</code> application we earlier in this chapter.
Use the following commands to link both <code>plugins-core</code> and <code>plugins-example</code> libraries to emulate installation from NPM:</p>
<pre><code class="language-sh">npm link plugins-core
npm link plugins-example
</code></pre>
<p>Also, you need to install a <code>systemjs</code> library.
That is a module loader we are going to use to get our plugins into the running application.</p>
<pre><code class="language-sh">npm install systemjs
</code></pre>
<blockquote>
<p><strong>SystemJS</strong></p>
<p>Configurable module loader enabling dynamic ES module workflows in browsers and NodeJS.
Built with the ES Module Loader project, which is based on principles and APIs
from the WhatWG Loader specification, modules in HTML and NodeJS.</p>
<p>For more details please refer to the official <strong><a href="https://github.com/systemjs/systemjs/blob/master/README.md">project page</a></strong>.</p>
</blockquote>
<p>As we are using Angular CLI for the application, the <code>systemjs</code> library needs to be present
within the <code>scripts</code> section of the <code>angular.json</code> configuration file.</p>
<p><strong>angular.json</strong>:</p>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;./node_modules/@angular/cli/lib/config/schema.json&quot;,
  &quot;project&quot;: {
    &quot;name&quot;: &quot;plugins&quot;
  },
  &quot;apps&quot;: [
    {
      ...,
      &quot;scripts&quot;: [
        &quot;../node_modules/systemjs/dist/system.js&quot;
      ],
      ...
    }
  ],
  ...
}
</code></pre>
<p>It would be much easier if we also automate plugin bundle copying process.</p>
<p>According to our design, all external plugins need to reside in the <code>modules</code> folder
of the application, either local or running at the server side.
As we continuously develop our plugin libraries, it is much easier
if Angular CLI automatically copies resulting bundles into appropriate places.</p>
<p>We already linked the libraries via the <code>npm link</code> command, the only thing
that is left is to add extra rules for the <code>assets</code> folder:</p>
<p><strong>angular.json</strong>:</p>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;./node_modules/@angular/cli/lib/config/schema.json&quot;,
  &quot;project&quot;: {
    &quot;name&quot;: &quot;plugins&quot;
  },
  &quot;apps&quot;: [
    {
      ...,
      &quot;assets&quot;: [
        ...,
        {
          &quot;glob&quot;: &quot;bundle.js&quot;,
          &quot;input&quot;: &quot;../node_modules/plugins-core/dist&quot;,
          &quot;output&quot;: &quot;./modules/plugins-core&quot;
        },
        {
          &quot;glob&quot;: &quot;bundle.js&quot;,
          &quot;input&quot;: &quot;../node_modules/plugins-example/dist&quot;,
          &quot;output&quot;: &quot;./modules/plugins-example&quot;
        }
      ],
      ...,
      &quot;scripts&quot;: [
        &quot;../node_modules/systemjs/dist/system.js&quot;
      ],
      ...
    }
  ],
  ...
}
</code></pre>
<p>For the next step, we need to provide some basic configuration for SystemJS loader.</p>
<p>The best way would be to re-use the same <code>plugins.config.json</code> configuration file we have created earlier.
In this case, you can manage both the loader and the plugin configuration in the same place,
and also without rebuilding the application.</p>
<p>To keep the configuration short, we are going to load all missing dependencies
directly from the <code>[UNPKG](https://unpkg.com/)</code>, a fast CDN for NPM libraries.</p>
<p>The <code>plugins-core</code> and <code>plugins-example</code> point to the local bundle files we copy with the Angular CLI.</p>
<p><strong>src/assets/plugins.config.json</strong>:</p>
<pre><code class="language-json">{
  &quot;system&quot;: {
    &quot;baseURL&quot;: &quot;/assets/modules&quot;,
    &quot;paths&quot;: {
      &quot;npm:&quot;: &quot;https://unpkg.com/&quot;
    },
    &quot;map&quot;: {
      &quot;@angular/core&quot;: &quot;npm:@angular/core/bundles/core.umd.js&quot;,
      &quot;rxjs&quot;: &quot;npm:rxjs&quot;,

      &quot;plugins-core&quot;: &quot;/modules/plugins-core/bundle.js&quot;,
      &quot;plugins-example&quot;: &quot;/modules/plugins-example/bundle.js&quot;
    }
  },
  &quot;sidebar&quot;: {
    &quot;components&quot;: [
      &quot;app-page2&quot;,
      &quot;app-page1&quot;
    ]
  }
}
</code></pre>
<p>Update the application component imports section with the <code>SystemJS</code> type declaration.
That allows us using auto-completion and type checking for the SystemJS APIs:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import {/*...,*/ AfterViewInit} from '@angular/core';
import { HttpClient } from '@angular/common/http';

import { System } from 'systemjs';
declare var SystemJS: System;
</code></pre>
<p>As you remember, we can load configuration using HttpClient, and use a TypeScript interface
to enable static type checks and IDE support. Let's start with the basic one:</p>
<pre><code class="language-ts">interface PluginsConfig {
  system: any;
}
</code></pre>
<p>To finish the preparations, add the <code>HttpClient</code> and mark the <code>ngAfterViewInit</code> handler as <code>async</code>,
like in the next example:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent implements AfterViewInit {
  // ...

  constructor(/*...,*/ private http: HttpClient) {
    // ...
  }

  async ngAfterViewInit() {
  }
}
</code></pre>
<p>Let's try to load the configuration and log its content to the browser console to ensure the file loads fine:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent implements AfterViewInit {
  // ...

  constructor(/*...,*/ private http: HttpClient) {
    // ...
  }

  async ngAfterViewInit() {
    const url = '/assets/plugins.config.json';
    const config = &lt;PluginsConfig&gt; await this.http.get(url).toPromise();
    console.log(config);
  }
}
</code></pre>
<p>Run the application or reload the page. The developer tools console should look similar to the one below:</p>
<p><img src="images/ng-plugins-10.png" alt="Loaded configuration" /></p>
<p>Before we load a plugin, the SystemJS loader needs to get configured.
We load and apply settings using the <code>config</code> method like in the next example:</p>
<pre><code class="language-ts">SystemJS.config(config.system);
</code></pre>
<p>You can test the loader by importing the <code>plugins-core</code> library:</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent implements AfterViewInit {

  async ngAfterViewInit() {
    const url = '/assets/plugins.config.json';
    const config = &lt;PluginsConfig&gt; await this.http.get(url).toPromise();
    console.log(config);

    SystemJS.config(config.system);

    const core = await SystemJS.import('plugins-core');
    console.log(core);
  }

}
</code></pre>
<p>This time the browser console output should contain the <code>plugins-core</code> library content:</p>
<p><img src="images/ng-plugins-11.png" alt="Loaded core module" /></p>
<p>Try expanding the <code>Extension</code> and <code>prototype</code> sections in the console to check the <code>registry</code> content.
It should be an empty object like this:</p>
<p><img src="images/ng-plugins-12.png" alt="Extension decorator registry" /></p>
<p>Next, import the <code>plugins-example</code> right after the <code>plugins-core</code>:</p>
<pre><code class="language-ts">// src/app/app.component.ts

const core = await SystemJS.import('plugins-core');
const pluginExample = await SystemJS.import('plugins-example');
console.log(core);
</code></pre>
<p>Now, the Extension decorator should contain two entries in the registry.
As you can see from the console output they are <code>my-button</code> and <code>my-label</code>:</p>
<p><img src="images/ng-plugins-13.png" alt="Registry with entries" /></p>
<p>You already know the names of the extensions, because you have defined them in the decorators for each component.
Also, you have the corresponding libraries loaded into the application at runtime.</p>
<p>It is now possible to use the same technique for dynamic module compilation
with the component constructors, fetched using Plugin Manager APIs.</p>
<p>The code below demonstrates the <code>my-label</code> plugin compiled and rendered within the <code>content</code> element,
similar to what we did earlier in this chapter.</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent implements AfterViewInit {

  async ngAfterViewInit() {
    // ...

    SystemJS.config(config.system);

    const core = await SystemJS.import('plugins-core');
    const pluginExample = await SystemJS.import('plugins-example');
    console.log(core);

    const componentType = core.pluginManager.getType('my-label');

    const RuntimeModule = NgModule({
      imports: [
        // extra modules if needed by your plugins
        // for example: FormsModule, HttpClientModule, etc
      ],
      declarations: [componentType]
    })(class {});

    const module = this.compiler.compileModuleAndAllComponentsSync(
      RuntimeModule
    );

    const factory = module.componentFactories.find(
      f =&gt; f.componentType === componentType
    );

    this.content.clear();
    this.content.createComponent(factory, 0);
  }

}
</code></pre>
<blockquote>
<p><strong>Dynamic modules and NgModule decorator</strong></p>
<p>Please keep in mind that with the &quot;RuntimeModule&quot; you are creating a real Angular module.</p>
<p>Besides &quot;declarations&quot; section you can reuse all other metadata properties exposed by the &quot;NgModule&quot; decorator.</p>
<p>For example, you can use &quot;imports&quot; to store a set of extra dependencies for your plugins.
Or &quot;providers&quot; where you add new, redefine or configure existing providers.</p>
</blockquote>
<p>Switch to the running application and reload the page, if you do not have live reloading enabled.
The main page now contains the <code>My Label</code> element.
That is the content of the plugin we have just dynamically loaded.</p>
<p><img src="images/ng-plugins-14.png" alt="Live plugin content" /></p>
<p>Another challenge to address - dependencies for your plugins.</p>
<p>In most common scenarios the plugin branch needs to be attached to the running application tree,
and have access to all the shared infrastructure.</p>
<p>The perfect examples are Authentication layer, Translation services, User Preferences, Application Configuration.
Every loaded plugin should not create a new copy, but reuse already configured instances of the services.</p>
<p>You can achieve tight integration of the plugins by using custom Injector instances.
It is possible to create the Injector that inherits the main application tree of Injectors,
and at the same time contains custom settings that a plugin brings if you need that level of control.</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { /*...,*/ Injector } from '@angular/core';

export class AppComponent implements AfterViewInit {

  constructor(private compiler: Compiler,
              private router: Router,
              private http: HttpClient,
              private injector: Injector) {
    // ...
  }

  async ngAfterViewInit() {
    // ...

    const pluginInjector = Injector.create([
      ...core.pluginManager.getProviders()
    ], this.injector);

    this.content.clear();
    this.content.createComponent(factory, 0, pluginInjector);
  }

}
</code></pre>
<p>First of all, we import an instance of the Injector into the component class constructor.</p>
<p>That is the same Injector that provides all other dependencies for the given class by the way.
It is created for every component and resolves all the required dependencies.</p>
<p>If there are no values registered with the component Injector, the Angular goes up the component tree
to the parent component and checks its Injector.
It repeats the same procedure until it reaches the top of the application tree and its module.</p>
<p>We take the component injector and create a new instance based on it.
Moreover, we populate the <code>providers</code> section of the current plugin.
That allows a plugin to register new or override existing providers if needed,
and allows Angular traverse the whole injector tree.</p>
<pre><code class="language-ts">const pluginInjector = Injector.create([
  ...core.pluginManager.getProviders()
], this.injector);
</code></pre>
<p>As soon as you have your custom injector, it becomes trivial to create a new component
with the factory, corresponding element position and injector instance:</p>
<pre><code class="language-ts">this.content.clear();
this.content.createComponent(factory, 0, pluginInjector);
</code></pre>
<p>Note the usage of the <code>Extension.prototype.getProviders</code> that we have created earlier.</p>
<p>That method allows us to collect all components marked with the <code>Extension</code> decorator,
and produce a list of <code>providers</code> and their <code>dependencies</code>, to attach to any custom injector or dynamic module:</p>
<pre><code class="language-js">// plugins-core:/src/extension.js

Extension.prototype.getProviders = function () {
    var registry = this.registry;

    return Object.keys(registry).map(function (key) {
        return {
            provide: key,
            useClass: registry[key].ctor,
            deps: registry[key].deps
        };
    });
};
</code></pre>
<p>Visually the hierarchy of dependencies and injectors should look like the following:</p>
<p><img src="images/ng-plugins-15.png" alt="Injectors" /></p>
<h3 id="setting-plugin-properties-at-runtime"><a class="header" href="#setting-plugin-properties-at-runtime">Setting plugin properties at runtime</a></h3>
<p>We have already used a few times the <code>ViewContainerRef.createContent</code> method to create and inject content.</p>
<pre><code class="language-ts">this.content.clear();
this.content.createComponent(factory, 0, pluginInjector);
</code></pre>
<p>The biggest feature of this method is that it returns the instance of the <code>ComponentRef</code> type.
That allows you accessing the real instance of the component you have just created, and setting its properties, or calling methods.</p>
<p><img src="images/ng-plugins-component-ref.png" alt="ComponentRef Members" /></p>
<p>You can try to check how it works by logging the value of one property the plugin defines, for example a <code>form</code>:</p>
<pre><code class="language-ts">console.log(componentRef.instance.form);
</code></pre>
<p>Use this technique to set up dynamic components after theyÂ get created.
You can set any properties and call any methods to provide post-constructor setup,
or prime your component with extra infrastructure references.</p>
<p>Sometimes it might be easier for you to set the corresponding properties at run time than piping all injectors and dependencies.</p>
<p>As plugins can be of many types unknown at compile time,
you can create a set of interfaces to provide a contract for the external developers.
For example, you may want all plugin developers to inherit a <code>PluginComponent</code> interface
with a set of properties your application can rely at run-time.</p>
<h3 id="dynamic-routes-with-plugin-content"><a class="header" href="#dynamic-routes-with-plugin-content">Dynamic Routes with plugin content</a></h3>
<p>We have been using manual import of the plugins by their names so far.
In real life, you are most probably going to make the application fully automatic,
based on multiple extension points and configuration settings that are coming either from the file or RESTful service call.</p>
<p>Let's introduce an application Router extension point similar to the one we have been using before.</p>
<p>This time, however, the application is going to load routes from the configuration file.
Every route now should be powered by the content exposed by the plugin, and not known to the application at compile time.</p>
<p>There may be many ways to express plugins setup in the configuration.
Here's a simple example for you to get started:</p>
<pre><code class="language-json">{
  &quot;system&quot;: {...},
  &quot;sidebar&quot;: {...},

  &quot;plugins&quot;: {
    &quot;modules&quot;: {
      &quot;plugins-core&quot;: &quot;/modules/plugins-core/bundle.js&quot; ,
      &quot;plugins-example&quot;: &quot;/modules/plugins-example/bundle.js&quot;
    },
    &quot;routes&quot;: [
      {
        &quot;name&quot;: &quot;Plugin 1 (label)&quot;,
        &quot;path&quot;: &quot;plugin1&quot;,
        &quot;component&quot;: {
          &quot;module&quot;: &quot;plugins-example&quot;,
          &quot;componentType&quot;: &quot;my-label&quot;
        }
      },
      {
        &quot;name&quot;: &quot;Plugin 2&quot;,
        &quot;path&quot;: &quot;plugin2 (button)&quot;,
        &quot;component&quot;: {
          &quot;module&quot;: &quot;plugins-example&quot;,
          &quot;componentType&quot;: &quot;my-button&quot;
        }
      }
    ]
  }
}
</code></pre>
<p>In our case, we introduce an extra section <code>plugins</code> to our existing <code>plugin.config.json</code> file.
It contains the list of available modules and a couple of routes that we want to create when the application starts.</p>
<p>Each route instance consists of the name, route path, and component information:
module and alias that we used within the <code>Extension</code> decorator.</p>
<p>To enable static checks, let's also extend the <code>PluginsConfig</code> interface:</p>
<pre><code class="language-ts">interface PluginsConfig {
  system: any;
  plugins: {
    modules: any,
    routes: Array&lt;{
      name: string,
      path: string,
      component: {
        module: string,
        componentType: string
      }
    }&gt;
  };
}
</code></pre>
<p>Next, edit the <code>ngAfterViewInit</code> hook for the main application component class,
and add the <code>loadExternalRoutes</code> call right after the SystemJS configuration:</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent implements AfterViewInit {
  // ...

  async ngAfterViewInit() {
    const url = '/assets/plugins.config.json';
    const config = &lt;PluginsConfig&gt; await this.http.get(url).toPromise();

    SystemJS.config(config.system);
    this.loadExternalRoutes(config);

    // ...
  }

}
</code></pre>
<p>At runtime, we can now quickly get a list of the plugins, their modules and custom routes.
Also, you can now get the corresponding component type using its alias and calling the <code>pluginManager.getType</code> method.</p>
<p>We have already implemented a way to create a dynamic route and display it on the page.
The challenging part is that Angular requires the route component to be a <code>known</code> type.
Due to some architectural reasons, it does not allow us to put an entirely dynamic component type as the <code>route.componentType</code> value.</p>
<p>You can solve the difficulty with the route components by introducing a statically known
to the application component, that has dynamic content.</p>
<p>Let's imagine we have a <code>DynamicPageComponent</code> component that has an empty template
and serves as a wrapper for the dynamic content exported by the external plugin.
We already know it is technically feasible, given the dynamic sidebar component we have previously created.</p>
<p>The <code>loadExternalRoutes</code> implementation may look like the following one:</p>
<pre><code class="language-ts">// src/app/app.component.ts
// ...

import { DynamicPageComponent } from './dynamic-page/dynamic-page.component';

export class AppComponent implements AfterViewInit {
  // ...

  private async loadExternalRoutes(config: PluginsConfig) {
    const core = await SystemJS.import('plugins-core');

    for (const route of config.plugins.routes) {
      const module = await SystemJS.import(route.component.module);
      const componentType = core.pluginManager.getType(
        route.component.componentType
      );

      this.createRoute(
        route.name,
        route.path,
        DynamicPageComponent,
        componentType
      );
    }
  }

}
</code></pre>
<p>Let's now adopt the <code>createRoute</code> to match our scenario:</p>
<pre><code class="language-ts">// src/app/app.component.ts

export class AppComponent implements AfterViewInit {
  // ...

  createRoute(text: string,
              path: string,
              componentType: any,
              factoryType?: any) {
    this.router.config.unshift({
      path: path,
      component: componentType,
      data: {
        factory: factoryType
      }
    });

    this.links.push({ text, path });
  }
}
</code></pre>
<p>As you can see from the example above, we use a known <code>DynamicPageComponent</code> for the route,
and also provide the required factory from the <code>Extension</code> decorator.</p>
<p>The <code>data</code> value contains a property bag with arbitrary data that any other component can access,
a handy way passing different optional configurations.
In our case, the dynamic page component is going to build its content using the factory provided in the property bag.</p>
<p>Next, you can generate the <code>DynamicPageComponent</code> by running the next Angular CLI command:</p>
<pre><code class="language-sh">ng g component dynamic-page --module=app
</code></pre>
<p>The component must also be declared as &quot;dynamically created&quot; by putting it
to the <code>entryComponents</code> section of the top-level module:</p>
<pre><code class="language-ts">// src/app/app.module.ts

@NgModule({
  // ...,

  entryComponents: [
    // ...,
    
    DynamicPageComponent
  ],
  
  //...
})
export class AppModule { }
</code></pre>
<p>According to our design, the only thing that we need in the component's template is the container element:</p>
<pre><code class="language-html">&lt;!-- src/app/dynamic-page/dynamic-page.component.html --&gt;

&lt;div #content&gt;&lt;/div&gt;
</code></pre>
<p>Similar to the dynamic sidebar, the component class implementation needs to get a reference
to the corresponding DOM element, and import injector and compile services, alongside the current route data:</p>
<pre><code class="language-ts">// src/app/dynamic-page/dynamic-page.component.ts

import {
  Component, OnInit, OnDestroy,
  Injector, ViewChild, ViewContainerRef,
  Compiler, NgModule, ComponentRef
} from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({/*...*/})
export class DynamicPageComponent implements OnInit, OnDestroy {

  @ViewChild('content',  { read: ViewContainerRef })
  content: ViewContainerRef;

  component: ComponentRef&lt;any&gt;;

  constructor(
    private route: ActivatedRoute,
    private injector: Injector,
    private compiler: Compiler) {
  }

  ngOnInit() {
  }

  ngOnDestroy() {
  }

}
</code></pre>
<p>The <code>ActivatedRoute</code> represents the current route.</p>
<p>We can import it to get access to the underlying details, including the property bag defined earlier,
by using the <code>route.snapshot.data</code> property value.</p>
<p>The code to create and render a dynamic component should already be familiar to you:</p>
<pre><code class="language-ts">// src/app/dynamic-page/dynamic-page.component.ts

@Component({/*...*/})
export class DynamicPageComponent implements OnInit, OnDestroy {
  // ...

  ngOnInit() {
    const componentType = this.route.snapshot.data['factory'];

    if (componentType) {
      this.compiler.clearCacheFor(componentType);

      const RuntimeModule = NgModule({
        imports: [/* extra libs */],
        providers: [/* extra providers */],
        declarations: [componentType]
      })(class {});

      const module = this.compiler.compileModuleAndAllComponentsSync(
        RuntimeModule
      );

      const factory = module.componentFactories.find(
        f =&gt; f.componentType === componentType
      );

      this.content.clear();
      this.component = this.content.createComponent(
        factory, 0, this.injector
      );
    }
  }

  ngOnDestroy() {
  }

}
</code></pre>
<p>A critical thing to keep in mind - users might visit the route multiple times,
so we need to manage all dynamically created resources and clean them up as soon as possible.</p>
<p>That is why we call the following code every time we build a new component:</p>
<pre><code class="language-ts">this.compiler.clearCacheFor(componentType);
</code></pre>
<p>As soon as the user leaves the page, the component needs to be released from memory as well:</p>
<pre><code class="language-ts">// src/app/dynamic-page/dynamic-page.component.ts

@Component({/*...*/})
export class DynamicPageComponent implements OnInit, OnDestroy {
  // ...

  ngOnDestroy() {
     if (this.component) {
      this.component.destroy();
      this.component = null;
    }
  }

}
</code></pre>
<p>Now start the application and take a look at the main page.</p>
<p>The <code>Routes</code> section now contains 5 links - the <code>Home</code>, <code>About</code> and <code>Settings</code> we created earlier,
and two more links created with the plugins:</p>
<p><img src="images/ng-plugins-16.png" alt="Generated routes" /></p>
<p>Now click the <code>Plugin 1 (label)</code> link, and you should see the <code>My Label</code> component automatically created underneath.
That content is coming from the plugin, and our application has just compiled and created it on demand!</p>
<p><img src="images/ng-plugins-17.png" alt="Dynamic route with the Label" /></p>
<p>Next, click the second link to see another component provided by the plugin:</p>
<p><img src="images/ng-plugins-18.png" alt="Dynamic route with the Button" /></p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>We have successfully finished the most advanced application setup with fully dynamic external plugins in action.</p>
<p>Feel free to enhance your applications with extension points,
and plugins that other developers can create and run with your apps.</p>
<blockquote>
<p><strong>Source Code</strong></p>
<p>You can find the source code in the
<strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/plugins">angular/plugins</a></strong> folder.</p>
</blockquote>
<h1 id="using-with-docker"><a class="header" href="#using-with-docker">Using with Docker</a></h1>
<p>In this chapter, we are going to provide Docker support for an Angular application.</p>
<p>We are about to create a Docker image that contains the prebuilt code, test it in the container,
publish and consume from Docker Hub, and even automate builds and publishing with Travis CI.</p>
<p>As a prerequisite, you need to get a community edition of the Docker for your platform:</p>
<ul>
<li><a href="https://store.docker.com/editions/community/docker-ce-desktop-mac">Docker CE for Mac</a></li>
<li><a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Docker CE for Windows</a></li>
</ul>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<p>If you want to get more information on the Docker and how to use it, please refer to the following Udemy course:
<a href="https://www.udemy.com/docker-mastery/">Docker Mastery: The Complete Toolset From a Docker Captain</a>.</p>
<p>If you use Visual Studio Code for development, the &quot;Docker&quot; extension might help you a lot:
<a href="https://marketplace.visualstudio.com/items?itemName=PeterJausovec.vscode-docker">Docker for VS Code</a>.
The Docker extension makes it easy to build and deploy containerized applications from Visual Studio Code.</p>
<h2 id="preparing-new-project-1"><a class="header" href="#preparing-new-project-1">Preparing New Project</a></h2>
<p>Let's start by using an Angular CLI to create a new project scaffold.
We are going to name it &quot;ng-docker&quot;.</p>
<pre><code class="language-sh">ng new ng-docker
cd ng-docker
</code></pre>
<p>Before we continue, please ensure the project builds and runs successfully on your local machine by running the following command:</p>
<pre><code class="language-sh">npm start
</code></pre>
<p>Next, visit the <code>http://localhost:4200/</code> to see the default application content that Angular CLI provides you out of the box.</p>
<h2 id="creating-dockerfile"><a class="header" href="#creating-dockerfile">Creating Dockerfile</a></h2>
<p>First of all, you need to build an application to get the &quot;dist&quot; folder with the content ready to redistribute.</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>In the project root, create a file named &quot;Dockerfile&quot; with the following content:</p>
<p><strong>Dockerfile</strong>:</p>
<pre><code class="language-text">FROM nginx

COPY nginx.conf /etc/nginx/nginx.conf

WORKDIR /usr/share/nginx/html
COPY dist/ .
</code></pre>
<p>The image extends the public <a href="https://hub.docker.com/_/nginx/">nginx</a> one.
Besides, we provide an external configuration to serve our application and copy the contents of the <code>dist</code> folder into the image.</p>
<p>The minimal <code>nginx</code> configuration can be as following:</p>
<p><strong>nginx.conf</strong>:</p>
<pre><code class="language-text">worker_processes  1;

events {
    worker_connections  1024;
}

http {
    server {
        listen 80;
        server_name  localhost;

        root   /usr/share/nginx/html;
        index  index.html index.htm;
        include /etc/nginx/mime.types;

        gzip on;
        gzip_min_length 1000;
        gzip_proxied expired no-cache no-store private auth;
        gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;

        location / {
            try_files $uri $uri/ /index.html;
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Deployment</strong></p>
<p>There are multiple deployment scenarios documented in the official documentation: &quot;<a href="https://angular.io/guide/deployment">Deployment</a>&quot;.
Please refer to that article if you want to get more information on available options and best practices.</p>
</blockquote>
<p>Now, let's build the image using the next command:</p>
<pre><code class="language-sh">docker image build -t ng-docker .
</code></pre>
<p>Note the dot character at the end of the command as it is essential.</p>
<p>You can also list your local images to ensure the <code>ng-docker</code> got created successfully.</p>
<pre><code class="language-sh">docker image ls
</code></pre>
<p>Excluding the images you may already have created or pulled, you should see the at least the following output:</p>
<table><thead><tr><th>REPOSITORY</th><th>TAG</th><th>IMAGE ID</th><th>CREATED</th><th>SIZE</th></tr></thead><tbody>
<tr><td>ng-docker</td><td>latest</td><td>98b129bff2fc</td><td>24 seconds ago</td><td>114MB</td></tr>
</tbody></table>
<h2 id="testing-in-a-container"><a class="header" href="#testing-in-a-container">Testing in a Container</a></h2>
<p>It is now an excellent time to test our image in a container.
Use the following command to create a temporary container out of our image, and run the application at port 3000:</p>
<pre><code class="language-sh">docker container run -p 3000:80 --rm ng-docker
</code></pre>
<p>Once you stop the process with <code>Ctrl+C</code>, the Docker is going to perform a cleanup.</p>
<p>Running the container should not take much time. If you now visit the <code>http://localhost:3000/</code> in your browser,
you should see the Angular CLI application up and running.</p>
<p>Note that the log output gets redirected to your console.
You should see the <code>nginx</code> output if you switch to the console right now:</p>
<pre><code class="language-text">172.17.0.1 - - [16/Dec/2017:11:41:33 +0000] &quot;GET / HTTP/1.1&quot; 200 611 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot;
172.17.0.1 - - [16/Dec/2017:11:41:33 +0000] &quot;GET /inline.bundle.js HTTP/1.1&quot; 200 1863 &quot;http://localhost:3000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot;
172.17.0.1 - - [16/Dec/2017:11:41:33 +0000] &quot;GET /polyfills.bundle.js HTTP/1.1&quot; 200 50339 &quot;http://localhost:3000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot;
172.17.0.1 - - [16/Dec/2017:11:41:33 +0000] &quot;GET /styles.bundle.js HTTP/1.1&quot; 200 3930 &quot;http://localhost:3000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot;
172.17.0.1 - - [16/Dec/2017:11:41:33 +0000] &quot;GET /vendor.bundle.js HTTP/1.1&quot; 200 492190 &quot;http://localhost:3000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot;
172.17.0.1 - - [16/Dec/2017:11:41:33 +0000] &quot;GET /main.bundle.js HTTP/1.1&quot; 200 2526 &quot;http://localhost:3000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot;
</code></pre>
<p>You can now stop the process and let Docker cleanup the data, or continue experimenting with the application.</p>
<h2 id="docker-compose"><a class="header" href="#docker-compose">Docker Compose</a></h2>
<blockquote>
<p>For more details on the Docker Compose,
please refer to the <a href="https://docs.docker.com/compose/">Overview of Docker Compose</a> article.</p>
</blockquote>
<p>For the next step, let's create a simple Compose file with our Angular application.</p>
<pre><code class="language-yml">version: '3.1'

services:
    app:
        image: 'ng-docker'
        build: '.'
        ports:
            - 3000:80
</code></pre>
<p>Note that we have put the <code>build</code> parameter so that Docker builds our local image instead of pulling it from the repository.
The Application runs on port 3000 and maps to port 80 inside the container.</p>
<p>You can now run the following command to test the container and docker compose file:</p>
<pre><code class="language-sh">docker-compose up
</code></pre>
<p>The console output should be similar to the following:</p>
<pre><code class="language-text">Creating network &quot;ngdocker_default&quot; with the default driver
Creating ngdocker_app_1 ...
Creating ngdocker_app_1 ... done
Attaching to ngdocker_app_1
</code></pre>
<p>Once again, visit the <code>http://localhost:3000</code> address and ensure the application is up and running.</p>
<p>As soon as you are done testing, press <code>Ctrl+C</code> to stop the process,
and run the next command if you want to perform a cleanup operation:</p>
<pre><code class="language-sh">docker-compose down
</code></pre>
<p>The Docker cleans only the containers created by our docker-compose file.
Add the <code>--rmi all</code> parameter if you want to remove the images as well.</p>
<pre><code class="language-sh">docker-compose down --rmi all
</code></pre>
<p>The console output, in this case, should be similar to the example below:</p>
<pre><code class="language-text">Removing ngdocker_app_1 ... done
Removing network ngdocker_default
Removing image ng-docker
</code></pre>
<p>You now need to publish your image to the docker hub to allow other people use your docker-compose file
or build their custom containers with your Angular application image.</p>
<h2 id="publishing-to-docker-hub"><a class="header" href="#publishing-to-docker-hub">Publishing to Docker Hub</a></h2>
<p>In this section, we are going to publish our application image to the public <a href="https://hub.docker.com/">Docker Hub</a>.
You can create a new account if you do not yet have one, this takes a couple of minutes.</p>
<p>If you clone a new copy of the project to publish it directly to the Docker Hub, don't forget to install dependencies.
In all the cases you should also create a fresh build of the application
to be sure the resulting image contains all the latest source code changes.</p>
<pre><code class="language-sh">npm install
npm run build
</code></pre>
<p>Let's now build the image and tag it for publishing:</p>
<pre><code class="language-sh">docker image build -t account/ng-docker:1.0 .
</code></pre>
<p>Note that typically you are going to replace the <code>account</code> prefix with your account name.</p>
<p>To publish the image run the next command with your account name instead of the &quot;account&quot; prefix:</p>
<pre><code class="language-sh">docker push account/ng-docker:1.0
</code></pre>
<p>In less than a minute your image should be published and available online.</p>
<h2 id="consuming-from-docker-hub"><a class="header" href="#consuming-from-docker-hub">Consuming from Docker Hub</a></h2>
<p>You have successfully published your Angular application image to the Docker Hub,
and before testing it out locally, you should remove the one created earlier before publishing.</p>
<p>Please use the following command to remove the existing image:</p>
<pre><code class="language-sh">docker image rm account/ng-docker:1.0
</code></pre>
<p>Now let's create a temporary container and pull the image from the public repository.
Replace the <code>account</code> prefix with your Docker Hub account name.</p>
<pre><code class="language-sh">docker container run -p 3000:80 --rm account/ng-docker:1.0
</code></pre>
<p>This time you should see Docker downloading and unpacking your image from the internet.
Once the setup is over, visit the <code>http://localhost:3000</code> and ensure the application is available and running fine.</p>
<h2 id="automating-with-travis"><a class="header" href="#automating-with-travis">Automating with Travis</a></h2>
<p>If you use <a href="https://travis-ci.org/">Travis CI</a> for your development and testing,
you can set it up to automatically build and deploy images to the Docker Hub.</p>
<p>You can refer to the following &quot;.travis.yml&quot; template as an example:</p>
<p><strong>.travis.yml</strong>:</p>
<pre><code class="language-yml">sudo: required

language: node_js
node_js:
  - &quot;8&quot;

cache:
  directories:
    - ./node_modules

services:
  - docker

before_install:
  - &quot;export DISPLAY=:99.0&quot;
  - &quot;sh -e /etc/init.d/xvfb start&quot;

script:
  - npm install
  - npm run build
  - npm run test -- --single-run --no-progress

after_success:
  - docker build -t account/ng-docker .
  - docker login -u &quot;$DOCKER_USERNAME&quot; -p &quot;$DOCKER_PASSWORD&quot;
  - docker push account/ng-docker
</code></pre>
<p>The configuration file allows to build your Angular application and run unit tests.</p>
<pre><code class="language-yml">script:
  - npm install
  - npm run build
  - npm run test -- --single-run --no-progress
</code></pre>
<p>As soon as test run is successful, we instruct Travis to build a new Docker image,
log in to Docker Hub and push the image to your account.</p>
<pre><code class="language-yml">after_success:
  - docker build -t account/ng-docker .
  - docker login -u &quot;$DOCKER_USERNAME&quot; -p &quot;$DOCKER_PASSWORD&quot;
  - docker push account/ng-docker
</code></pre>
<p>Note that we store credentials as encrypted environment variables, and refer to as <code>$DOCKER_USERNAME</code> and <code>$DOCKER_PASSWORD</code>.</p>
<p>Also, you can either provide the correct <code>account</code> prefix or use the <code>$DOCKER_USERNAME</code> value there as well.</p>
<p><img src="images/ng-docker-01.png" alt="Travis Variables" /></p>
<p>Now, if you push the code and switch to the Travis output, you are going to see something like the following:</p>
<p><img src="images/ng-docker-02.png" alt="Travis Output" /></p>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<p><a href="https://docs.travis-ci.com/user/docker/">Using Docker in Builds</a></p>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<p>You can find the source code in the
<a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/ng-docker">angular/ng-docker</a> folder.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-23X2CQXZ48', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
