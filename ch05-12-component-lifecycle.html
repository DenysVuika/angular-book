<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Component Lifecycle - Angular Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Angular Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="ch01-02-vscode.html"><strong aria-hidden="true">1.2.</strong> Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-es6.html"><strong aria-hidden="true">2.</strong> ES6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-classes.html"><strong aria-hidden="true">2.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch02-02-inheritance.html"><strong aria-hidden="true">2.2.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="ch02-03-arrow-functions.html"><strong aria-hidden="true">2.3.</strong> Arrow Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-template-literals.html"><strong aria-hidden="true">2.4.</strong> Template Literals</a></li><li class="chapter-item expanded "><a href="ch02-05-extended-parameters.html"><strong aria-hidden="true">2.5.</strong> Extended Parameter Handling</a></li><li class="chapter-item expanded "><a href="ch02-06-destructuring.html"><strong aria-hidden="true">2.6.</strong> Destructuring Assignment</a></li><li class="chapter-item expanded "><a href="ch02-07-modules.html"><strong aria-hidden="true">2.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch02-08-see-also.html"><strong aria-hidden="true">2.8.</strong> See Also</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-typescript.html"><strong aria-hidden="true">3.</strong> TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch03-02-features.html"><strong aria-hidden="true">3.2.</strong> TypeScript Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-03-types.html"><strong aria-hidden="true">3.2.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="ch03-04-classes.html"><strong aria-hidden="true">3.2.2.</strong> Classes</a></li><li class="chapter-item expanded "><a href="ch03-05-interfaces.html"><strong aria-hidden="true">3.2.3.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch03-06-abstract-classes.html"><strong aria-hidden="true">3.2.4.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="ch03-07-modules.html"><strong aria-hidden="true">3.2.5.</strong> Modules</a></li><li class="chapter-item expanded "><a href="ch03-08-decorators.html"><strong aria-hidden="true">3.2.6.</strong> Decorators</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-angular-cli.html"><strong aria-hidden="true">4.</strong> Angular CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-installing.html"><strong aria-hidden="true">4.1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="ch04-02-first-application.html"><strong aria-hidden="true">4.2.</strong> Your First Application</a></li><li class="chapter-item expanded "><a href="ch04-03-running-application.html"><strong aria-hidden="true">4.3.</strong> Running Application</a></li><li class="chapter-item expanded "><a href="ch04-04-linting.html"><strong aria-hidden="true">4.4.</strong> Code Linting</a></li><li class="chapter-item expanded "><a href="ch04-05-testing.html"><strong aria-hidden="true">4.5.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="ch04-06-coverage.html"><strong aria-hidden="true">4.6.</strong> Code Coverage</a></li><li class="chapter-item expanded "><a href="ch04-07-development-and-production-builds.html"><strong aria-hidden="true">4.7.</strong> Development and Production Builds</a></li><li class="chapter-item expanded "><a href="ch04-08-using-blueprints.html"><strong aria-hidden="true">4.8.</strong> Using Blueprints</a></li><li class="chapter-item expanded "><a href="ch04-09-creating-modules.html"><strong aria-hidden="true">4.9.</strong> Creating Modules</a></li><li class="chapter-item expanded "><a href="ch04-10-routing-support.html"><strong aria-hidden="true">4.10.</strong> Routing Support</a></li><li class="chapter-item expanded "><a href="ch04-11-generating-standalone-scripts.html"><strong aria-hidden="true">4.11.</strong> Generating Standalone Scripts</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-angular.html"><strong aria-hidden="true">5.</strong> Angular</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-components.html"><strong aria-hidden="true">5.1.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-02-creating-a-simple-component.html"><strong aria-hidden="true">5.1.1.</strong> Creating a Simple Component</a></li><li class="chapter-item expanded "><a href="ch05-03-generating-components-with-angular-cli.html"><strong aria-hidden="true">5.1.2.</strong> Generating Components with Angular CLI</a></li><li class="chapter-item expanded "><a href="ch05-04-component-metadata.html"><strong aria-hidden="true">5.1.3.</strong> Component Metadata</a></li><li class="chapter-item expanded "><a href="ch05-05-templates.html"><strong aria-hidden="true">5.1.4.</strong> Templates</a></li><li class="chapter-item expanded "><a href="ch05-06-styles.html"><strong aria-hidden="true">5.1.5.</strong> Styles</a></li><li class="chapter-item expanded "><a href="ch05-07-input-properties.html"><strong aria-hidden="true">5.1.6.</strong> Input Properties</a></li><li class="chapter-item expanded "><a href="ch05-08-output-events.html"><strong aria-hidden="true">5.1.7.</strong> Output Events</a></li><li class="chapter-item expanded "><a href="ch05-09-providers.html"><strong aria-hidden="true">5.1.8.</strong> Providers</a></li><li class="chapter-item expanded "><a href="ch05-10-host.html"><strong aria-hidden="true">5.1.9.</strong> Host</a></li><li class="chapter-item expanded "><a href="ch05-11-queries.html"><strong aria-hidden="true">5.1.10.</strong> Queries</a></li><li class="chapter-item expanded "><a href="ch05-12-component-lifecycle.html" class="active"><strong aria-hidden="true">5.1.11.</strong> Component Lifecycle</a></li><li class="chapter-item expanded "><a href="ch05-13-content-projection.html"><strong aria-hidden="true">5.1.12.</strong> Content Projection</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-dependency-injection.html"><strong aria-hidden="true">5.2.</strong> Dependency Injection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-preparing-a-project.html"><strong aria-hidden="true">5.2.1.</strong> Preparing a Project</a></li><li class="chapter-item expanded "><a href="ch06-02-services.html"><strong aria-hidden="true">5.2.2.</strong> Services</a></li><li class="chapter-item expanded "><a href="ch06-03-providers.html"><strong aria-hidden="true">5.2.3.</strong> Providers</a></li><li class="chapter-item expanded "><a href="ch06-04-injection-tokens.html"><strong aria-hidden="true">5.2.4.</strong> Injection Tokens</a></li><li class="chapter-item expanded "><a href="ch06-05-injecting-multiple-instances.html"><strong aria-hidden="true">5.2.5.</strong> Injecting Multiple Instances</a></li><li class="chapter-item expanded "><a href="ch06-06-optional-dependencies.html"><strong aria-hidden="true">5.2.6.</strong> Optional Dependencies</a></li><li class="chapter-item expanded "><a href="ch06-07-manual-injection.html"><strong aria-hidden="true">5.2.7.</strong> Manual Injection</a></li><li class="chapter-item expanded "><a href="ch06-08-summary.html"><strong aria-hidden="true">5.2.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.1.</strong> Component Events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.2.</strong> DOM Events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.3.</strong> Service Events</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Directives</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.1.</strong> Introduction to Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.2.</strong> Attribute Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.3.</strong> Structural Directives</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.4.</strong> Modifying Host Element Layout</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Walkthrough: Upload Directive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Pipes</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.</strong> Introduction to Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.2.</strong> Pipes with Parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.3.</strong> Chaining Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.4.</strong> Built-in Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.5.</strong> Custom Pipes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.6.</strong> Pure And Impure Pipes</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Global Application Configuration</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.1.</strong> Preparing the Configuration File</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.2.</strong> Creating the Configuration Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.3.</strong> Loading Server-Side Configuration File</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.4.</strong> Registering Configuration Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.5.</strong> Using Configuration Settings</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Internationalisation (i18n)</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.1.</strong> Creating Translate Service</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.2.</strong> Creating Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.3.</strong> Using Translate Pipe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.4.</strong> Switching Languages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.5.</strong> Summary</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Reusable Component Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Creating new application</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Creating component libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Building the packages</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Publishing to NPM</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Advanced Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Dynamic Content in Angular</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Using with Docker</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Additional Resources</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Preparing new project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Creating Dockerfile</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Testing in a container</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> Creating docker-compose.yml</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.6.</strong> Consuming from Docker Hub</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.7.</strong> Automating with Travis</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.8.</strong> See also</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Webpack</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Initial project structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Typescript configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Basic webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Advanced webpack setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Unit testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Building a Mobile App with Cordova and Angular</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Installing command-line tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Generating a new Angular App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Routing support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Summary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Angular Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/DenysVuika/angular-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="component-lifecycle"><a class="header" href="#component-lifecycle">Component Lifecycle</a></h2>
<p>Angular supports multiple lifecycle events for components, directives and services.</p>
<p>For the Components, the Angular invokes the following methods at runtime, in the order of execution:</p>
<ul>
<li>ngOnChanges</li>
<li>ngOnInit</li>
<li>ngDoCheck</li>
<li>ngAfterContentInit</li>
<li>ngAfterContentChecked</li>
<li>ngAfterViewInit</li>
<li>ngAfterViewChecked</li>
<li>ngOnDestroy</li>
</ul>
<p>As Directives do not have UI templates, they get the following set of lifecycle methods supported out of the box:</p>
<ul>
<li>ngOnChanges</li>
<li>ngOnInit</li>
<li>ngDoCheck</li>
<li>ngOnDestroy</li>
</ul>
<p>Finally, the Services get the next methods:</p>
<ul>
<li>ngOnDestroy</li>
</ul>
<p>Every method represents a separate interface in the <code>@angular/core</code> namespace and contains a <code>ng</code> prefix appended to the interface name.</p>
<p>For example, the <code>OnInit</code> interface declares a <code>ngOnInit</code> method, and so on.
We are going to dive deeper into details on each method and interface below.</p>
<p>Technically, the interfaces for the lifecycle events are optional.
The Angular is going to call those events in any case, and if the corresponding methods are present, they get automatically invoked.
It is a good practice, however, to still expose those interfaces in your classes to enable static checks by TypeScript.</p>
<p>You can find additional information on the lifecycle events in the following official docs: <a href="https://angular.io/guide/lifecycle-hooks#component-lifecycle-hooks-overview">Lifecycle Hooks</a></p>
<blockquote>
<p><strong>Source code</strong></p>
<p>You can find the source code as an Angular CLI project in the <strong><a href="https://github.com/DenysVuika/developing-with-angular/tree/master/angular/components/lifecycle">angular/components/lifecycle</a></strong> folder.</p>
</blockquote>
<h3 id="ngonchanges"><a class="header" href="#ngonchanges">ngOnChanges</a></h3>
<p>The <code>ngOnChanges</code> method is related to the <code>OnChanges</code> hook.
Angular calls it every time an input property of the component or directive gets changed.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface OnChanges {
    ngOnChanges(changes: SimpleChanges): void;
}
</code></pre>
<p>Let's create a new Angular CLI project and generate an <code>on-changes-demo</code> component to see the <code>OnChanges</code> hook in action.</p>
<pre><code class="language-sh">ng g component on-changes-demo
</code></pre>
<p>To visualize the property change, we need two properties to store the current and old values.</p>
<p>The <code>text</code> property stores current string value and is decorated with the <code>@Input</code>
to enable two-way bindings with template components, or external input.</p>
<p>The <code>previous</code> property provides the one-way binding support to display the old string.</p>
<pre><code class="language-ts">// src/app/on-changes-demo/on-changes-demo.component.ts

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-on-changes-demo',
  templateUrl: './on-changes-demo.component.html',
  styleUrls: ['./on-changes-demo.component.css']
})
export class OnChangesDemoComponent {

  @Input()
  text = 'hello world';

  previous: string;

}
</code></pre>
<p>Now that we have a code defined, the minimal component implementation can look like in the following example:</p>
<pre><code class="language-html">&lt;!-- src/app/on-changes-demo/on-changes-demo.component.html --&gt;

&lt;p&gt;
  Text: {{ text }}
  &lt;br&gt;
  Previous: {{ previous }}
&lt;/p&gt;
</code></pre>
<p>At this point, we are ready to implement the <code>OnChanges</code> interface from the <code>@angular/core</code> package.
Your <code>ngOnChanges</code> method can look like the next one:</p>
<pre><code class="language-ts">// src/app/on-changes-demo/on-changes-demo.component.ts
import { /*...,*/ OnChanges, SimpleChanges } from '@angular/core';

@Component({...})
export class OnChangesDemoComponent implements OnChanges {

  @Input()
  text = 'hello world';

  previous: string;

  ngOnChanges(changes: SimpleChanges) {
    if (changes.text) {
      this.previous = changes.text.previousValue;
    }
  }

}
</code></pre>
<p>As you already know, the Angular keeps track of all property changes.</p>
<p>In our current case, the framework collects the changes made to the <code>OnChangesDemoComponent</code> component properties and,
wraps into a special <code>SimpleChanges</code> map and passes to the corresponding hook method.</p>
<pre><code class="language-ts">interface SimpleChanges {
    [propName: string]: SimpleChange;
}
</code></pre>
<p>Every value of the <code>SimpleChanges</code> map implements a <code>SimpleChange</code> interface with at least the following properties and methods:</p>
<ul>
<li>previousValue: any;</li>
<li>currentValue: any;</li>
<li>firstChange: boolean;</li>
<li>isFirstChange(): boolean;</li>
</ul>
<p>As you can see the <code>SimpleChange</code> API allows you to inspect the current and previous values,
as well as to check whether this is the first time the particular property gets changed.
The <code>firstChange</code> property allows you to distinguish between setting default property
value within the class initializer as opposed to the changes caused by user interaction or runtime changes.</p>
<p>Now let's use our newly created component with the main application one.
The simple way to test value changes is to bind an input element to the &quot;text&quot; property like in the example below:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;

&lt;input [(ngModel)]=&quot;text&quot;&gt;
&lt;app-on-changes-demo [text]=&quot;text&quot;&gt;&lt;/app-on-changes-demo&gt;
</code></pre>
<p>Note that you are going to need an extra <code>text</code> property for the application component controller class:</p>
<pre><code class="language-ts">// src/app/app.component.ts

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  @Input()
  text: string;

}
</code></pre>
<p>Run the application with the <code>ng serve --open</code> command and try typing text in the main page.
Notice that our component displays both old and new values as you type them into the input element.</p>
<p><img src="images/lifecycle-01.png" alt="OnChanges example" /></p>
<h3 id="ngoninit"><a class="header" href="#ngoninit">ngOnInit</a></h3>
<p>The <code>OnInit</code> is the most common lifecycle hook. You are probably going to use it a lot in your custom components.</p>
<p>It is a good practice to perform component initialization in the <code>ngOnInit</code> method and not in the constructor.
Angular invokes the &quot;ngOnInit&quot; after the construction and once all input properties set,
so you can setup your component based on the property values from the outside.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface OnInit {
    ngOnInit(): void;
}
</code></pre>
<p>In the same project, we created earlier, generate a new &quot;on-init-demo&quot; component with the following command:</p>
<pre><code class="language-sh">ng g component on-init-demo
</code></pre>
<p>Next, define a property <code>currentDate</code> of the <code>Date</code> type, and set its value in the <code>ngOnInit</code> method like in the following example:</p>
<pre><code class="language-ts">// src/app/on-init-demo/on-init-demo.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-on-init-demo',
  templateUrl: './on-init-demo.component.html',
  styleUrls: ['./on-init-demo.component.css']
})
export class OnInitDemoComponent implements OnInit {

  currentDate: Date;

  constructor() { }

  ngOnInit() {
    this.currentDate = new Date();
  }

}
</code></pre>
<p>Update the component template to render the value of the <code>currentDate</code>:</p>
<pre><code class="language-html">&lt;!-- src/app/on-init-demo/on-init-demo.component.html --&gt;

&lt;p&gt;
  Date: {{ currentDate }}
&lt;/p&gt;
</code></pre>
<p>Given that we do not have any input properties, the main application component template can contain just the empty tag.</p>
<p>Append the following code to the existing template HTML:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngOnInit&lt;/h2&gt;

&lt;app-on-init-demo&gt;&lt;/app-on-init-demo&gt;
</code></pre>
<p>If you run the application right now, you should see current date and time with default string formatting:</p>
<p><img src="images/lifecycle-02.png" alt="" /></p>
<p>Let's now try creating the component multiple times on the fly to see the <code>ngOnInit</code> method calls in practice.
We can wrap our custom <code>OnInitDemoComponent</code> with the <code>ng-container</code> element decorated by the <code>ngIf</code> directive.</p>
<p>Add a new <code>showNgOnInit</code> property of the <code>boolean</code> type to the component controller class,
and bind the checkbox to toggle component at runtime:</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({...)
export class AppComponent {

  // ...

  showNgOnInit = true;

}
</code></pre>
<p>Update the application controller template to look like the following code:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngOnInit&lt;/h2&gt;

&lt;label&gt;
  &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;showNgOnInit&quot;&gt;
  Toggle ngOnInit demo
&lt;/label&gt;

&lt;ng-container *ngIf=&quot;showNgOnInit&quot;&gt;
  &lt;app-on-init-demo&gt;&lt;/app-on-init-demo&gt;
&lt;/ng-container&gt;
</code></pre>
<blockquote>
<p><strong>ngModel</strong></p>
<p>Don't forget that you need to import <code>FormsModule</code> to your root application module so that you can use the <code>ngModel</code> with components.</p>
</blockquote>
<p>Now, every time you tick the checkbox element a new <code>OnInitDemoComponent</code> is created and displayed,
and a new date value assigned by the <code>ngOnInit</code> method.</p>
<p><img src="images/lifecycle-03.png" alt="" /></p>
<p>As you can imagine, we used a pretty basic scenario for component setup.
In real life, your <code>ngOnInit</code> content might be more complex.</p>
<h3 id="ngdocheck"><a class="header" href="#ngdocheck">ngDoCheck</a></h3>
<p>The <code>DoCheck</code> hook allows you to integrate into the change detection cycle and find changes within the objects references
or any areas where Angular did not detect changes automatically.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface DoCheck {
    ngDoCheck(): void;
}
</code></pre>
<blockquote>
<p><strong>Performance Penalty</strong></p>
<p>Please keep in mind that, depending on the component tree size and complexity,
the &quot;ngDoCheck&quot; method is going to execute enormous amount of times
and may become a performance bottleneck if you poorly implement the code.
Avoid using &quot;ngDoCheck&quot; method unless necessary.</p>
</blockquote>
<p>When using properties of the object type, the Angular is going to watch the changes by value reference,
meaning detects the change of the entire value, but not the changes in the child properties.
That is the case where we are going to use <code>DoCheck</code> lifecycle hook and detect changes in the object.</p>
<p>For the next exercise, we need a new component called &quot;DoCheckDemoComponent&quot; that you can generate using the following command:</p>
<pre><code class="language-sh">ng g component do-check-demo
</code></pre>
<p>Let's integrate it into the main application template now to save the time later.
Append the next HTML snippet to the content of the component template:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;
&lt;hr&gt;
&lt;h2&gt;ngDoCheck&lt;/h2&gt;
&lt;app-do-check-demo&gt;&lt;/app-do-check-demo&gt;
</code></pre>
<p>Next, we need an object value and custom properties.
For the sake of simplicity let's create a &quot;User&quot; object featuring first and last names as separate properties.</p>
<p>The component should have the <code>current</code> and <code>previous</code> values to facilitate property checks.</p>
<pre><code class="language-ts">// src/app/do-check-demo/do-check-demo.component.ts

import { Component, Input, DoCheck } from '@angular/core';

@Component({
  selector: 'app-do-check-demo',
  templateUrl: './do-check-demo.component.html',
  styleUrls: ['./do-check-demo.component.css']
})
export class DoCheckDemoComponent implements DoCheck {

  currentUser = {
    firstName: 'John',
    lastName: 'Doe'
  };

  previousUser = {
    firstName: '',
    lastName: ''
  };

  ngDoCheck() {
  }

}
</code></pre>
<p>For the first iteration leave the <code>ngDoCheck</code> method empty and switch to the component template.
Our component needs to display values for both current and previous property values.</p>
<pre><code class="language-html">&lt;!-- src/app/do-check-demo/do-check-demo.component.html --&gt;

&lt;p&gt;
  Current user: {{ currentUser.firstName + ' ' + currentUser.lastName }}
  &lt;br&gt;
  Previous user: {{ previousUser.firstName + ' ' + previousUser.lastName }}
&lt;/p&gt;
</code></pre>
<p>You can run the application and check that component works as expected.
The main page should contain the full name of the user stored in the <code>currentUser</code> property.
The text for the <code>previousUser</code> property should be empty because we have not yet changed anything.</p>
<p><img src="images/lifecycle-04.png" alt="" /></p>
<p>As mentioned earlier, Angular calls <code>DoCheck</code> many times based on the change detection cycle.</p>
<p>To see that in practice, let's introduce a new field <code>checks</code> that should hold a count of checks performed for our component.
We are going to increment this field every time the <code>ngDoCheck</code> get called.</p>
<p>Next, we create a field <code>updates</code> to hold a count of the <code>currentUser</code> updates detected by our custom <code>ngDoCheck</code> implementation.
The method checks both <code>firstName</code> and <code>lastName</code> property values and updates the counter,
in addition to setting a new instance of the <code>previousUser</code> value.</p>
<p>Finally, let's introduce an &quot;Update user&quot; button that changes the value of the current user
and so triggers the change detection cycle and our custom checks. The button calls <code>updateUser</code> method upon every click.</p>
<p>Below is the implementation of all the mentioned class members and behavior:</p>
<pre><code class="language-ts">// src/app/do-check-demo/do-check-demo.component.ts

@Component({/*...*/})
export class DoCheckDemoComponent implements DoCheck {

  currentUser = {
    firstName: 'John',
    lastName: 'Doe'
  };

  previousUser = {
    firstName: '',
    lastName: ''
  };

  checks = 0;
  updates = 0;

  updateUser() {
    this.currentUser = {
      firstName: 'James',
      lastName: 'Bond'
    };
  }

  ngDoCheck() {
    this.checks ++;
    
    if (
      this.previousUser.firstName !== this.currentUser.firstName
      || this.previousUser.lastName !== this.currentUser.lastName
    ) {
      this.updates ++;
      this.previousUser = Object.assign({}, this.currentUser);
    }
  }

}
</code></pre>
<p>Now, edit the component HTML template to add necessary labels and a button to update the underlying user.</p>
<pre><code class="language-html">&lt;!-- src/app/do-check-demo/do-check-demo.component.html --&gt;

&lt;p&gt;
  Current user: {{ currentUser.firstName + ' ' + currentUser.lastName }}
  &lt;br&gt;
  Previous user: {{ previousUser.firstName + ' ' + previousUser.lastName }}
&lt;/p&gt;

&lt;p&gt;
  Checks: {{ checks }} &lt;br&gt;
  Updates: {{ updates }} &lt;br&gt;
  &lt;button (click)=&quot;updateUser()&quot;&gt;Update user&lt;/button&gt;
&lt;/p&gt;
</code></pre>
<p>Run the application or switch to the corresponding browser tab if it is already running.
You should see something like the following:</p>
<p><img src="images/lifecycle-05.png" alt="" /></p>
<p>Now click the &quot;Update user&quot; button one time and check that both counters got incremented.</p>
<p><img src="images/lifecycle-06.png" alt="" /></p>
<p>If you continue clicking the button, you should notice that the <code>checked</code> counter keeps incrementing.
Note that it increments even if you click some other buttons or clickable Angular components.
That demonstrates that our custom component reacts on change detection cycle managed by Angular, and increments the counter as designed.</p>
<p><img src="images/lifecycle-07.png" alt="" /></p>
<p>The <code>update</code> counter, however, should remain the same.
That is obvious as we change the values of the user only once.</p>
<h3 id="ngaftercontentinit"><a class="header" href="#ngaftercontentinit">ngAfterContentInit</a></h3>
<p>The <code>ngAfterContentInit</code> method belongs to the <code>AfterContentInit</code> hook in Angular,
and is part of the &quot;Content Projection&quot; feature.</p>
<p>Angular raises <code>AfterContentInit</code> every time an injected child component gets initialized
and is ready for use and access from the code if needed.</p>
<blockquote>
<p><strong>Content Projection</strong></p>
<p>Content projection is the process of injection of the external HTML content and other Angular components into the body of your component template.
You can get more information in the <a href="#ng-content-projection">Content Projection</a> section later in this chapter.</p>
</blockquote>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface AfterContentInit {
  ngAfterContentInit(): void;
}
</code></pre>
<p>As all in all previous cases, let's start by generating a separate component to experiment with the hook:</p>
<pre><code class="language-sh">ng g component after-content-init-demo
</code></pre>
<p>For our exercise, we do not need a &quot;constructor&quot; and the <code>OnInit</code> implementation.
You can clean the component class and replace with the <code>AfterContentInit</code> interface implementation.</p>
<pre><code class="language-ts">// src/app/after-content-init-demo/after-content-init-demo.component.ts

import { Component, AfterContentInit } from '@angular/core';

@Component({/*...*/})
export class AfterContentInitDemoComponent implements AfterContentInit {

  ngAfterContentInit() {
  }

}
</code></pre>
<p>The <code>ng-content</code> element is going to be an injection point for external content.
Update the component template to look like the following markup:</p>
<pre><code class="language-html">&lt;!-- src/app/after-content-init-demo/after-content-init-demo.component.html --&gt;

Projected content below:
&lt;div&gt;
  &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/div&gt;
</code></pre>
<p>We now need to generate a second component to test the Angular lifecycle hook.</p>
<pre><code class="language-sh">ng g component after-content-init-child
</code></pre>
<p>You can clean the component class code as we need just a default implementation.</p>
<pre><code class="language-ts">// src/app/after-content-init-child/after-content-init-child.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-after-content-init-child',
  templateUrl: './after-content-init-child.component.html',
  styleUrls: ['./after-content-init-child.component.css']
})
export class AfterContentInitChildComponent {
}
</code></pre>
<p>Also, the default component template should work fine as well.
The Angular CLI usually generates a <code>&lt;component&gt; works!</code> label out of the box.</p>
<pre><code class="language-html">&lt;!-- src/app/after-content-init-child/after-content-init-child.component.html --&gt;

&lt;p&gt;
  after-content-init-child works!
&lt;/p&gt;
</code></pre>
<p>Finally, let's extend the main application template with the testing parent-child hierarchy with our newly introduced components.
Just append the following HTML snippet to existing template markup.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngAfterContentInit&lt;/h2&gt;

&lt;app-after-content-init-demo&gt;

    &lt;app-after-content-init-child&gt;
    &lt;/app-after-content-init-child&gt;

&lt;/app-after-content-init-demo&gt;
</code></pre>
<p>Serve the application with the <code>ng serve --open</code> command or switch to a running one in the browser.
You should see the next layout at the bottom of your page:</p>
<p><img src="images/lifecycle-08.png" alt="" /></p>
<p>Typically you are going to use <code>AfterContentInit</code> hook with the <code>@ContentChild</code> decorator.
While we use the <code>ngAfterContentInit</code> to detect when an injected component finished initializing,
the <code>ContentChild</code> allows getting references to the component instance.</p>
<p>Please refer to the example below to get a better understanding of how both APIs work together.</p>
<pre><code class="language-ts">// src/app/after-content-init-demo/after-content-init-demo.component.ts
import { Component, OnInit, AfterContentInit, ContentChild } from '@angular/core';
import { AfterContentInitChildComponent } from '../after-content-init-child/after-content-init-child.component';

@Component({/*...*/})
export class AfterContentInitDemoComponent implements AfterContentInit {

  @ContentChild(AfterContentInitChildComponent)
  child: AfterContentInitChildComponent;

  ngAfterContentInit() {
    console.log('AfterContentInit:', this.child);
  }

}
</code></pre>
<p>Once you run your application and open the developer tools,
you should see the following content in the browser console output:</p>
<p><img src="images/lifecycle-09.png" alt="" /></p>
<p>At this point, your parent component can perform additional setup for the child one,
like changing properties, subscribing to events or calling methods.</p>
<h3 id="ngaftercontentchecked"><a class="header" href="#ngaftercontentchecked">ngAfterContentChecked</a></h3>
<p>The <code>ngAfterContentChecked</code> method belongs to the <code>AfterContentChecked</code> interface in Angular, and is part of the &quot;Content Projection&quot; feature.</p>
<p>The <code>AfterContentChecked</code> lifecycle hook allows you to provide a custom mechanism for checking changes in the projected components.
The behavior is similar to the <code>DoCheck</code> but applied to the components that are part of the <code>ng-content</code> container.</p>
<blockquote>
<p><strong>Content Projection</strong></p>
<p>Content projection is the process of injection of the external HTML content and other Angular components into the body of your component template.
You can get more information in the <a href="#ng-content-projection">Content Projection</a> section later in this chapter.</p>
</blockquote>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface AfterContentChecked {
  ngAfterContentChecked(): void;
}
</code></pre>
<p>Let's use the same <code>AfterContentInitDemoComponent</code> we created earlier.
For the sake of simplicity, we are going to add the <code>checked</code> counter field and update it on every change detection cycle.</p>
<pre><code class="language-ts">// src/app/after-content-init-demo/after-content-init-demo.component.ts
import { /*...,*/ AfterContentChecked } from '@angular/core';
...

@Component({/*...*/})
export class AfterContentInitDemoComponent implements AfterContentInit, AfterContentChecked {

  checked = 0;

  // ...

  ngAfterContentChecked() {
    this.checked ++;
  }

}
</code></pre>
<p>Update the component template to also display the <code>checked</code> counter after the projected content.</p>
<pre><code class="language-html">&lt;!-- src/app/after-content-init-demo/after-content-init-demo.component.html --&gt;

Projected content below:
&lt;div&gt;
  &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/div&gt;
&lt;div&gt;
  Checked (times): {{ checked }}
&lt;/div&gt;
</code></pre>
<p>Once your application starts or reloads, the bottom of the page should look similar to the following:</p>
<p><img src="images/lifecycle-10.png" alt="" /></p>
<p>Please note that the counter is going to update multiple times even if you interact with some other components or elements on the page.
You should keep the code inside <code>ngAfterContentChecked</code> method body fast and small not to introduce a performance bottleneck for the entire application.</p>
<h3 id="ngafterviewinit"><a class="header" href="#ngafterviewinit">ngAfterViewInit</a></h3>
<p>Angular invokes the <code>ngAfterViewInit</code> hook once the view of the component is ready.
That also includes the child components that may be part of the template.</p>
<p>You can access child instance members and perform additional tasks in the code,
for example changing properties or subscribing to events.</p>
<p>Check out the code of the interface below:</p>
<pre><code class="language-ts">interface AfterViewInit {
  ngAfterViewInit(): void;
}
</code></pre>
<p>Let's introduce a basic scenario that requires us to access view elements and update their properties.
We are going to have two buttons in the component template that have no text,
and once the view gets initialized our component should update the text of each button.</p>
<p>We need a separate <code>AfterViewInitDemoComponent</code> component that gets generated with the next Angular CLI command:</p>
<pre><code class="language-sh">ng g component after-view-init-demo
</code></pre>
<p>Import and implement the <code>AfterViewInit</code> interface from the <code>@angular/core</code> package.
The <code>ngAfterViewInit</code> method can be blank for now, and we are going to implement it shortly.</p>
<pre><code class="language-ts">// src/app/after-view-init-demo/after-view-init-demo.component.ts

import { Component, OnInit, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-after-view-init-demo',
  templateUrl: './after-view-init-demo.component.html',
  styleUrls: ['./after-view-init-demo.component.css']
})
export class AfterViewInitDemoComponent implements AfterViewInit {

  ngAfterViewInit() {
  }

}
</code></pre>
<p>Next, add two buttons to the template.
Each of the button needs to have a template reference id
so that our component class can access each button using the <code>prevPageButton</code> and <code>nextPageButton</code> id values.</p>
<pre><code class="language-html">&lt;!-- src/app/after-view-init-demo/after-view-init-demo.component.html --&gt;

&lt;div&gt;
  after-view-init-demo works!
  &lt;div&gt;
      &lt;button #prevPageButton&gt;&lt;/button&gt;
      &lt;button #nextPageButton&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>As a next step, declare the newly generated component within the main application template
by appending the following code to the existing markup:</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngAfterViewInit&lt;/h2&gt;
&lt;app-after-view-init-demo&gt;&lt;/app-after-view-init-demo&gt;
</code></pre>
<p>Serve the application right now and ensure the component renders its template with a default label
and two buttons with missing labels as in the picture below:</p>
<p><img src="images/lifecycle-11.png" alt="" /></p>
<p>You also need importing the <code>ViewChild</code> decorator type.
This decorator is used to get a reference to the native element of the component template.</p>
<p>Also, create two separate properties <code>prevButton</code> and <code>nextButton</code> of the <code>ElementRef</code> type.
Every instance of the <code>ElementRef</code> exposes a <code>nativeElement</code> property that you can use to access the DOM element,
in our case HTML button inputs.</p>
<p>The component sets the <code>innerText</code> values for both buttons inside the <code>ngAfterViewInit</code> method body like in the next example:</p>
<pre><code class="language-ts">// src/app/after-view-init-demo/after-view-init-demo.component.ts

import { /*...,*/ ViewChild, ElementRef } from '@angular/core';

@Component({...})
export class AfterViewInitDemoComponent implements AfterViewInit {

  @ViewChild('prevPageButton')
  prevButton: ElementRef;

  @ViewChild('nextPageButton')
  nextButton: ElementRef;

  ngAfterViewInit() {
    this.prevButton.nativeElement.innerText = 'Left Page';
    this.nextButton.nativeElement.innerText = 'Right Page';
  }

}
</code></pre>
<p>This time, when you run the application, both buttons should have correct labels:</p>
<p><img src="images/lifecycle-12.png" alt="" /></p>
<p>The <code>AfterViewInit</code> is usually used to modify the behavior of the view elements once the corresponding component is ready.</p>
<h3 id="ngafterviewchecked"><a class="header" href="#ngafterviewchecked">ngAfterViewChecked</a></h3>
<p>The <code>ngAfterViewChecked</code> method represents the <code>AfterViewChecked</code> lifecycle hook and interface.
It allows you to provide custom change tracking that is not handled by Angular due to some reason.
The behavior is similar to the <code>AfterContentChecked</code> hook but applies to the view template children rather than projected content.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface AfterViewChecked {
  ngAfterViewChecked(): void;
}
</code></pre>
<p>As with previous examples, let's introduce a &quot;checked&quot; field to hold the number of checks,
and use the previous component with two buttons to demonstrate the lifecycle hook in practice.</p>
<pre><code class="language-ts">// src/app/after-view-init-demo/after-view-init-demo.component.ts

import { /*...,*/ AfterViewChecked } from '@angular/core';

@Component({/*...*/})
export class AfterViewInitDemoComponent implements AfterViewInit, AfterViewChecked {

  checked = 0;

  // ...

  ngAfterViewChecked() {
    this.checked ++;
  }

}
</code></pre>
<p>Don't forget to update the component template by appending the label like in the next snippet:</p>
<pre><code class="language-html">&lt;!-- src/app/after-view-init-demo/after-view-init-demo.component.html --&gt;
&lt;!-- ... --&gt;

&lt;div&gt;
  Checked (times): {{ checked }}
&lt;/div&gt;
</code></pre>
<p>Now run the application and try clicking the buttons.
You should notice that the counter updates every time you interact with the button inside the component template,
or any other Angular component on the page.</p>
<p><img src="images/lifecycle-13.png" alt="" /></p>
<p>Needless to say that your custom change tracking code should be highly optimized and run fast.
Otherwise, you risk getting a performance bottleneck.</p>
<h3 id="ngondestroy"><a class="header" href="#ngondestroy">ngOnDestroy</a></h3>
<p>The <code>OnDestroy</code> lifecycle hook provides you with a way to run cleanup operations for your component,
directive or service to reduce resources and avoid potential memory leaks.</p>
<p>If your component controller subscribes to various event handlers,
the <code>ngOnDestroy</code> method is the most appropriate place to tear down all event subscriptions.</p>
<p>You can find the code of the interface below:</p>
<pre><code class="language-ts">interface OnDestroy {
  ngOnDestroy(): void;
}
</code></pre>
<p>Let's generate a new component to see how <code>OnDestroy</code> hook works in practice.
We are going to produce two log entries for the browser console log,
one during the <code>OnInit</code> call and one for the <code>OnDestroy</code>.</p>
<pre><code class="language-sh">ng g component on-destroy-demo
</code></pre>
<pre><code class="language-ts">// src/app/on-destroy-demo/on-destroy-demo.component.ts

import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-on-destroy-demo',
  templateUrl: './on-destroy-demo.component.html',
  styleUrls: ['./on-destroy-demo.component.css']
})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  constructor() { }

  ngOnInit() {
    console.log('OnInit');
  }

  ngOnDestroy() {
    console.log('OnDestroy');
  }

}
</code></pre>
<p>Next, declare a <code>showNgOnDestroy</code> property for the main application component class
to control the visibility of our generated component.</p>
<pre><code class="language-ts">// src/app/app.component.ts

@Component({/*...*/})
export class AppComponent {
  // ...

  showNgOnDestroy = true;

}
</code></pre>
<p>For the last step, declare a checkbox with the label to control the value of the <code>showNgOnDestroy</code> property,
and a <code>ng-container</code> element that wraps the <code>app-on-destroy-demo</code>.</p>
<pre><code class="language-html">&lt;!-- src/app/app.component.html --&gt;
&lt;!-- ... --&gt;

&lt;hr&gt;
&lt;h2&gt;ngOnDestroy&lt;/h2&gt;
&lt;label&gt;
  &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;showNgOnDestroy&quot;&gt;
  Toggle ngOnDestroy demo
&lt;/label&gt;

&lt;ng-container *ngIf=&quot;showNgOnDestroy&quot;&gt;
  &lt;app-on-destroy-demo&gt;&lt;/app-on-destroy-demo&gt;
&lt;/ng-container&gt;
</code></pre>
<p>At runtime, the component should look like the following once the application starts:</p>
<p><img src="images/lifecycle-14.png" alt="" /></p>
<p>As soon as you untick the checkbox, the Angular is going to tear down the component
that should no longer be on the page and call the &quot;ngOnDestroy&quot; method.</p>
<p>Open the development tools for your current browser and try clicking the checkbox multiple times.
The console output should look like the one below:</p>
<p><img src="images/lifecycle-15.png" alt="" /></p>
<h4 id="cleaning-up-subscriptions"><a class="header" href="#cleaning-up-subscriptions">Cleaning up subscriptions</a></h4>
<p>Also, the <code>OnDestroy</code> event is also used to cleanup subscriptions to external service or component events.
It is very important to unsubscribe from all the events to prevent memory leaks and performance degradation.</p>
<p>Let's take an example of a service that exposes multiple events.</p>
<pre><code class="language-ts">// src/app/on-destroy-demo/simple.service.ts

import { Injectable } from '@angular/core';
import { Subject } from 'rxjs/Subject';

@Injectable()
export class SimpleService {

  loaded = new Subject();
  changed = new Subject();
  somethingElse = new Subject();

}
</code></pre>
<p>We use dependency injection to get an instance of this service injected into the component constructor.
And we use the <code>OnInit</code> hook to set upthe event handlers.</p>
<pre><code class="language-ts">// src/app/on-destroy-demo/on-destroy-demo.component.ts

@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  constructor(private service: SimpleService) {}

  ngOnInit() {
    this.service.loaded.subscribe(() =&gt; {/*...*/});
    this.service.changed.subscribe(() =&gt; {/*...*/});
  }

  ngOnDestroy() {/*...*/}
}
</code></pre>
<p>It is sometimes difficult to spot the problem in such an approach, but we may get a memory leak with the code above.</p>
<p>The issue is that the service we inject is a singleton one, and Angular keeps its instance somewhere.
It also means that now service instance will keep a reference to our component alive due to the event handler and subscription.
That is why we need to clean all subscriptions during destroy phase.</p>
<p>When using Observables, you get an instance of the Subscription each time you call <code>subscribe</code> method of the <code>Observable</code> or <code>Subject</code>.</p>
<blockquote>
<p><strong>Subscription</strong></p>
<p>Represents a disposable resource, such as the execution of an Observable.
Subscription has one important method, <code>unsubscribe</code>, that takes no argument and just disposes the resource held by the subscription.</p>
</blockquote>
<p>The easiest way to process multiple subscriptions is to use them in bulk, wrapping into a private array variable.
That saves a lot of time and prevents issues related to missed variables or <code>unsubscribe</code> calls.</p>
<p>First, let's create a private property <code>subscriptions</code> of the array type that will hold all our subscriptions to external events.</p>
<pre><code class="language-ts">@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  private subscriptions: Subscription[] = [];

}
</code></pre>
<p>Now you can push multiple subscriptions into the array like in the next example:</p>
<pre><code class="language-ts">@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  private subscriptions: Subscription[] = [];

  constructor(private service: SimpleService) {}

  ngOnInit() {
    this.subscriptions.push(
      this.service.loaded.subscribe(() =&gt; {/*...*/}),
      this.service.changed.subscribe(() =&gt; {/*...*/}),
      this.service.somethingElse.subscribe(() =&gt; {{/*...*/})
    );
  }

  ngOnDestroy() {/*...*/}

}
</code></pre>
<p>Keeping all subscriptions in one place makes it easy to cleanup them in bulk when Angular invokes <code>ngOnDestroy</code> life-cycle hook.</p>
<pre><code class="language-ts">@Component({/*...*/})
export class OnDestroyDemoComponent implements OnInit, OnDestroy {

  private subscriptions: Subscription[] = [];

  constructor(private service: SimpleService) {}

  ngOnInit() {/*...*/}

  ngOnDestroy() {
    this.subscriptions.forEach(s =&gt; s.unsubscribe());
    this.subscriptions = [];
  }

}
</code></pre>
<p>Do not forget about the technique above when dealing with subscriptions.
It should prevent memory leaks and performance issues when the component is re-created or gets destroyed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch05-11-queries.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch05-13-content-projection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch05-11-queries.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch05-13-content-projection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-23X2CQXZ48', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
